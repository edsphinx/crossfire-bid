{
  "language": "Solidity",
  "sources": {
    "@1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\n/**\n * @title IAmountGetter\n * @notice Interface for external logic to determine actual making and taking amounts for orders.\n */\ninterface IAmountGetter {\n    /**\n     * @notice View method that gets called to determine the actual making amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     * @return makingAmount Actual making amount that should be used for the order\n     */\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n\n    /**\n     * @notice View method that gets called to determine the actual taking amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     * @return takingAmount Actual taking amount that should be used for the order\n     */\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n}\n"
    },
    "@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport \"../libraries/MakerTraitsLib.sol\";\nimport \"../libraries/TakerTraitsLib.sol\";\n\n/**\n * @title IOrderMixin\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\n */\ninterface IOrderMixin {\n    struct Order {\n        uint256 salt;\n        Address maker;\n        Address receiver;\n        Address makerAsset;\n        Address takerAsset;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        MakerTraits makerTraits;\n    }\n\n    error InvalidatedOrder();\n    error TakingAmountExceeded();\n    error PrivateOrder();\n    error BadSignature();\n    error OrderExpired();\n    error WrongSeriesNonce();\n    error SwapWithZeroAmount();\n    error PartialFillNotAllowed();\n    error OrderIsNotSuitableForMassInvalidation();\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\n    error ReentrancyDetected();\n    error PredicateIsNotTrue();\n    error TakingAmountTooHigh();\n    error MakingAmountTooLow();\n    error TransferFromMakerToTakerFailed();\n    error TransferFromTakerToMakerFailed();\n    error MismatchArraysLengths();\n    error InvalidPermit2Transfer();\n    error SimulationResults(bool success, bytes res);\n\n    /**\n     * @notice Emitted when order gets filled\n     * @param orderHash Hash of the order\n     * @param remainingAmount Amount of the maker asset that remains to be filled\n     */\n    event OrderFilled(\n        bytes32 orderHash,\n        uint256 remainingAmount\n    );\n\n    /**\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\n     * @param orderHash Hash of the order\n     */\n    event OrderCancelled(\n        bytes32 orderHash\n    );\n\n    /**\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\n     * @param maker Maker address\n     * @param slotIndex Slot index that was updated\n     * @param slotValue New slot value\n     */\n    event BitInvalidatorUpdated(\n        address indexed maker,\n        uint256 slotIndex,\n        uint256 slotValue\n    );\n\n    /**\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\n     * @dev The function always reverts and returns the simulation results in revert data.\n     * @param target Addresses that will be delegated\n     * @param data Data that will be passed to delegatee\n     */\n    function simulate(address target, bytes calldata data) external;\n\n    /**\n     * @notice Cancels order's quote\n     * @param makerTraits Order makerTraits\n     * @param orderHash Hash of the order to cancel\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\n\n    /**\n     * @notice Cancels orders' quotes\n     * @param makerTraits Orders makerTraits\n     * @param orderHashes Hashes of the orders to cancel\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\n\n    /**\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\n     * @param makerTraits Order makerTraits\n     * @param additionalMask Additional bitmask to invalidate orders\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\n\n    /**\n     * @notice Fills order's quote, fully or partially (whichever is possible).\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrder(\n        Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but uses contract-based signatures.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrder(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param maker Maker address\n     * @param slot Slot number to return bitmask for\n     * @return result Each bit represents whether corresponding was already invalidated\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remaining Remaining amount of the order\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\n\n    /**\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\n     * @param order Order\n     * @return orderHash Hash of the order\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\n}\n"
    },
    "@1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\ninterface IPostInteraction {\n    /**\n     * @notice Callback method that gets called after all fund transfers\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "@1inch/limit-order-protocol-contract/contracts/interfaces/IPreInteraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\ninterface IPreInteraction {\n    /**\n     * @notice Callback method that gets called before any funds transfers\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "@1inch/limit-order-protocol-contract/contracts/libraries/MakerTraitsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype MakerTraits is uint256;\n\n/**\n * @title MakerTraitsLib\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\n * @dev\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\n * High bits are used for flags\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\n * 253 bit                                  - unused\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\n\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n * uint80 last 10 bytes of allowed sender address (0 if any)\n * uint40 expiration timestamp (0 if none)\n * uint40 nonce or epoch\n * uint40 series\n */\nlibrary MakerTraitsLib {\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\n    uint256 private constant _EXPIRATION_OFFSET = 80;\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\n    uint256 private constant _SERIES_OFFSET = 160;\n    uint256 private constant _SERIES_MASK = type(uint40).max;\n\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\n\n    /**\n     * @notice Checks if the order has the extension flag set.\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the flag is set.\n     */\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker allows a specific taker to fill the order.\n     * @param makerTraits The traits of the maker.\n     * @param sender The address of the taker to be checked.\n     * @return result A boolean indicating whether the taker is allowed.\n     */\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\n    }\n\n    /**\n     * @notice Returns the expiration time of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The expiration timestamp of the order.\n     */\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\n    }\n\n    /**\n     * @notice Checks if the order has expired.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the order has expired.\n     */\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\n        uint256 expiration = getExpirationTime(makerTraits);\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the nonce or epoch of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The nonce or epoch of the order.\n     */\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\n    }\n\n    /**\n     * @notice Returns the series of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The series of the order.\n     */\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\n    }\n\n    /**\n      * @notice Determines if the order allows partial fills.\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows partial fills.\n      */\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs pre-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\n     */\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs post-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\n     */\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if the order allows multiple fills.\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows multiple fills.\n      */\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the bit invalidator should be used.\n      * True if the order requires the use of the bit invalidator.\n      */\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\n    }\n\n    /**\n     * @notice Checks if the maker needs to check the epoch.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\n     */\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker uses permit2.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker uses permit2.\n     */\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs to unwraps WETH.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\n     */\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\n    }\n}\n"
    },
    "@1inch/limit-order-protocol-contract/contracts/libraries/TakerTraitsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype TakerTraits is uint256;\n\n/**\n * @title TakerTraitsLib\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\n * @dev The TakerTraits are structured as follows:\n * High bits are used for flags\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker’s funds transfer.\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\n */\nlibrary TakerTraitsLib {\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\n\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\n\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @notice Checks if the args should contain target address.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the args should contain target address.\n     */\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\n    }\n\n    /**\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\n     * @param takerTraits The traits of the taker.\n     * @return result The length of the extension calldata encoded in the takerTraits.\n     */\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\n     * @param takerTraits The traits of the taker.\n     * @return result The length of the interaction calldata encoded in the takerTraits.\n     */\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Checks if the taking amount should be calculated based on making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\n     */\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order should unwrap WETH.\n     */\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should skip maker's permit execution.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order don't apply permit.\n     */\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order uses the permit2 instead of permit.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order uses the permit2.\n     */\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\n    }\n\n    /**\n     * @notice Retrieves the threshold amount from the takerTraits.\n     * The maximum amount a taker agrees to give in exchange for a making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result The threshold amount encoded in the takerTraits.\n     */\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IDaiLikePermit\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\n */\ninterface IDaiLikePermit {\n    /**\n     * @notice Approves spending of tokens via off-chain signatures.\n     * @param holder Token holder's address.\n     * @param spender Spender's address.\n     * @param nonce Current nonce of the holder.\n     * @param expiry Time when the permit expires.\n     * @param allowed True to allow, false to disallow spending.\n     * @param v, r, s Signature components.\n     */\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@1inch/solidity-utils/contracts/interfaces/IERC20MetadataUppercase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IERC20MetadataUppercase\n * @dev Interface for ERC20 token metadata with uppercase naming convention.\n */\ninterface IERC20MetadataUppercase {\n    /**\n     * @notice Gets the token name.\n     * @return Token name.\n     */\n    function NAME() external view returns (string memory); // solhint-disable-line func-name-mixedcase\n\n    /**\n     * @notice Gets the token symbol.\n     * @return Token symbol.\n     */\n    function SYMBOL() external view returns (string memory); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IERC7597Permit\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\n */\ninterface IERC7597Permit {\n    /**\n     * @notice Update allowance with a signed permit.\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\n     * @param owner Token owner's address (Authorizer).\n     * @param spender Spender's address.\n     * @param value Amount of allowance.\n     * @param deadline The time at which the signature expires (unixtime).\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n}\n"
    },
    "@1inch/solidity-utils/contracts/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPermit2\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\n */\ninterface IPermit2 {\n    /**\n     * @dev Struct for holding permit details.\n     * @param token ERC20 token address for which the permit is issued.\n     * @param amount The maximum amount allowed to spend.\n     * @param expiration Timestamp until which the permit is valid.\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\n     */\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @dev Struct for a single token allowance permit.\n     * @param details Permit details including token, amount, expiration, and nonce.\n     * @param spender Address authorized to spend the tokens.\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\n     */\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    /**\n     * @dev Struct for packed allowance data to optimize storage.\n     * @param amount Amount allowed.\n     * @param expiration Permission expiry timestamp.\n     * @param nonce Unique incrementing value for tracking allowances.\n     */\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @notice Executes a token transfer from one address to another.\n     * @param user The token owner's address.\n     * @param spender The address authorized to spend the tokens.\n     * @param amount The amount of tokens to transfer.\n     * @param token The address of the token being transferred.\n     */\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    /**\n     * @notice Issues a permit for spending tokens via a signed authorization.\n     * @param owner The token owner's address.\n     * @param permitSingle Struct containing the permit details.\n     * @param signature The signature proving the owner authorized the permit.\n     */\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Retrieves the allowance details between a token owner and spender.\n     * @param user The token owner's address.\n     * @param token The token address.\n     * @param spender The spender's address.\n     * @return The packed allowance details.\n     */\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n\n    /**\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\n     * @param token The token to approve\n     * @param spender The spender address to approve\n     * @param amount The approved amount of the token\n     * @param expiration The timestamp at which the approval is no longer valid\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\n     */\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n}\n"
    },
    "@1inch/solidity-utils/contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IWETH\n * @dev Interface for wrapper as WETH-like token.\n */\ninterface IWETH is IERC20 {\n    /**\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\n     */\n    event Deposit(address indexed dst, uint256 wad);\n\n    /**\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\n     */\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /**\n     * @notice Deposit Ether to get wrapper tokens.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw wrapped tokens as Ether.\n     * @param amount Amount of wrapped tokens to withdraw.\n     */\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "@1inch/solidity-utils/contracts/libraries/AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype Address is uint256;\n\n/**\n* @notice AddressLib\n* @notice Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\n*/\nlibrary AddressLib {\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\n\n    /**\n    * @notice Returns the address representation of a uint256.\n    * @param a The uint256 value to convert to an address.\n    * @return The address representation of the provided uint256 value.\n    */\n    function get(Address a) internal pure returns (address) {\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\n    }\n\n    /**\n    * @notice Checks if a given flag is set for the provided address.\n    * @param a The address to check for the flag.\n    * @param flag The flag to check for in the provided address.\n    * @return True if the provided flag is set in the address, false otherwise.\n    */\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\n        return (Address.unwrap(a) & flag) != 0;\n    }\n\n    /**\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint32 value.\n    * @param offset The bit offset at which the uint32 value is stored.\n    * @return The uint32 value stored in the address at the specified bit offset.\n    */\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\n        return uint32(Address.unwrap(a) >> offset);\n    }\n\n    /**\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint64 value.\n    * @param offset The bit offset at which the uint64 value is stored.\n    * @return The uint64 value stored in the address at the specified bit offset.\n    */\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\n        return uint64(Address.unwrap(a) >> offset);\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/libraries/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\n/**\n * @title ECDSA signature operations\n * @notice Provides functions for recovering addresses from signatures and verifying signatures, including support for EIP-2098 compact signatures.\n */\nlibrary ECDSA {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;\n    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant _COMPACT_V_SHIFT = 255;\n\n    /**\n     * @notice Recovers the signer's address from the signature.\n     * @dev Recovers the address that has signed a hash with `(v, r, s)` signature.\n     * @param hash The keccak256 hash of the data signed.\n     * @param v The recovery byte of the signature.\n     * @param r The first 32 bytes of the signature.\n     * @param s The second 32 bytes of the signature.\n     * @return signer The address of the signer.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address signer) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), v)\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    /**\n     * @notice Recovers the signer's address from the signature using `r` and `vs` components.\n     * @dev Recovers the address that has signed a hash with `r` and `vs`, where `vs` combines `v` and `s`.\n     * @param hash The keccak256 hash of the data signed.\n     * @param r The first 32 bytes of the signature.\n     * @param vs The combined `v` and `s` values of the signature.\n     * @return signer The address of the signer.\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (address signer) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let s := and(vs, _COMPACT_S_MASK)\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    /**\n     * @notice Recovers the signer's address from a hash and a signature.\n     * @param hash The keccak256 hash of the signed data.\n     * @param signature The full signature from which the signer will be recovered.\n     * @return signer The address of the signer.\n     */\n    /// @dev WARNING!!!\n    /// There is a known signature malleability issue with two representations of signatures!\n    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures\n    /// one should never use raw signatures for any kind of invalidation logic in their code.\n    /// As the standard and compact representations are interchangeable any invalidation logic that relies on\n    /// signature uniqueness will get rekt.\n    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address signer) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // memory[ptr:ptr+0x80] = (hash, v, r, s)\n            switch signature.length\n            case 65 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)\n            }\n            case 64 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                let vs := calldataload(add(signature.offset, 0x20))\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)\n                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))\n            }\n            default {\n                ptr := 0\n            }\n\n            if ptr {\n                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {\n                    // memory[ptr:ptr+0x20] = (hash)\n                    mstore(ptr, hash)\n\n                    mstore(0, 0)\n                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                    signer := mload(0)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\n     * @param signer The address to validate the signature against.\n     * @param hash The hash of the signed data.\n     * @param signature The signature to verify.\n     * @return success True if the signature is verified, false otherwise.\n     */\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, signature);\n    }\n\n    /**\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\n     * @param signer The address to validate the signature against.\n     * @param hash The hash of the signed data.\n     * @param v The recovery byte of the signature.\n     * @param r The first 32 bytes of the signature.\n     * @param s The second 32 bytes of the signature.\n     * @return success True if the signature is verified, false otherwise.\n     */\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, v, r, s) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, v, r, s);\n    }\n\n    /**\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\n     * @param signer The address to validate the signature against.\n     * @param hash The hash of the signed data.\n     * @param r The first 32 bytes of the signature.\n     * @param vs The combined `v` and `s` values of the signature.\n     * @return success True if the signature is verified, false otherwise.\n     */\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, r, vs);\n    }\n\n    /**\n     * @notice Verifies the signature for a given hash, attempting to recover the signer's address or validates it using EIP-1271 for 65-byte signatures.\n     * @dev Attempts to recover the signer's address from the signature. If the address is a contract, checks if the signature is valid according to EIP-1271.\n     * @param signer The expected signer's address.\n     * @param hash The keccak256 hash of the signed data.\n     * @param r The first 32 bytes of the signature.\n     * @param vs The last 32 bytes of the signature, with the last byte being the recovery id.\n     * @return success True if the signature is valid, false otherwise.\n     */\n    function recoverOrIsValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature65(signer, hash, r, vs);\n    }\n\n    /**\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\n     * @param hash The hash of the signed data.\n     * @param signature The signature to validate.\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\n     */\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), signature.length)\n            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)\n            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    /**\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\n     * @param hash The hash of the signed data.\n     * @param v The recovery byte of the signature.\n     * @param r The first 32 bytes of the signature.\n     * @param s The second 32 bytes of the signature.\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\n     */\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), s)\n            mstore8(add(ptr, 0xa4), v)\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    /**\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\n     * @param hash The hash of the signed data.\n     * @param r The first 32 bytes of the signature.\n     * @param vs The last 32 bytes of the signature, with the last byte being the recovery id.\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\n     */\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 64)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), vs)\n            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    /**\n     * @notice Verifies if a 65-byte signature is valid for a given hash, according to EIP-1271.\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\n     * @param hash The hash of the signed data.\n     * @param r The first 32 bytes of the signature.\n     * @param vs The combined `v` (recovery id) and `s` component of the signature, packed into the last 32 bytes.\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\n     */\n    function isValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))\n            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a hash compatible with Ethereum's signed message format.\n     * @dev Prepends the hash with Ethereum's message prefix before hashing it.\n     * @param hash The hash of the data to sign.\n     * @return res The Ethereum signed message hash.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {\n        // 32 is the length in bytes of hash, enforced by the type signature above\n        // return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // \"\\x19Ethereum Signed Message:\\n32\"\n            mstore(28, hash)\n            res := keccak256(0, 60)\n        }\n    }\n\n    /**\n     * @notice Generates an EIP-712 compliant hash.\n     * @dev Encodes the domain separator and the struct hash according to EIP-712.\n     * @param domainSeparator The EIP-712 domain separator.\n     * @param structHash The EIP-712 struct hash.\n     * @return res The EIP-712 compliant hash.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {\n        // return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // \"\\x19\\x01\"\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            res := keccak256(ptr, 66)\n        }\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title RevertReasonForwarder\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\n */\nlibrary RevertReasonForwarder {\n    /**\n     * @dev Forwards the revert reason from the latest external call.\n     * This method allows propagating the revert reason of a failed external call to the caller.\n     */\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n\n    /**\n     * @dev Retrieves the revert reason from the latest external call.\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\n     * @return reason The latest external call revert reason.\n     */\n    function reReason() internal pure returns (bytes memory reason) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            reason := mload(0x40)\n            let length := returndatasize()\n            mstore(reason, length)\n            returndatacopy(add(reason, 0x20), 0, length)\n            mstore(0x40, add(reason, add(0x20, length)))\n        }\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IERC7597Permit.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    address private constant _PERMIT2_ZKSYNC = 0x0000000000225e31D15943971F47aD3022F714Fa;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 0x64, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        address permit2 = _getPermit2Address();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), permit2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(permit2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, amount)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        address permit2 = _getPermit2Address();\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\n            }\n            // Dynamic length\n            default {\n                mstore(ptr, erc7597PermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.deposit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    function _getPermit2Address() private view returns (address permit2) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            switch chainid()\n            case 324 { // zksync mainnet\n                permit2 := _PERMIT2_ZKSYNC\n            }\n            case 300 { // zksync testnet\n                permit2 := _PERMIT2_ZKSYNC\n            }\n            case 260 { // zksync fork network\n                permit2 := _PERMIT2_ZKSYNC\n            }\n            default {\n                permit2 := _PERMIT2\n            }\n        }\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/libraries/StringUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title StringUtil\n * @dev Library with gas-efficient string operations.\n */\nlibrary StringUtil {\n    /**\n     * @notice Converts a uint256 value to its hexadecimal string representation.\n     * @param value The uint256 value to convert.\n     * @return The hexadecimal string representation of the input value.\n     */\n    function toHex(uint256 value) internal pure returns (string memory) {\n        return toHex(abi.encodePacked(value));\n    }\n\n    /**\n     * @notice Converts an address to its hexadecimal string representation.\n     * @param value The address to convert.\n     * @return The hexadecimal string representation of the input address.\n     */\n    function toHex(address value) internal pure returns (string memory) {\n        return toHex(abi.encodePacked(value));\n    }\n\n    /**\n     * @dev Converts arbitrary bytes to their hexadecimal string representation.\n     * This is an assembly adaptation of highly optimized toHex16 code by Mikhail Vladimirov.\n     * Reference: https://stackoverflow.com/a/69266989\n     * @param data The bytes to be converted to hexadecimal string.\n     * @return result The hexadecimal string representation of the input bytes.\n     */\n    function toHex(bytes memory data) internal pure returns (string memory result) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            function _toHex16(input) -> output {\n                output := or(\n                    and(input, 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000),\n                    shr(64, and(input, 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000))\n                )\n                output := or(\n                    and(output, 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000),\n                    shr(32, and(output, 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000))\n                )\n                output := or(\n                    and(output, 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000),\n                    shr(16, and(output, 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000))\n                )\n                output := or(\n                    and(output, 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000),\n                    shr(8, and(output, 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000))\n                )\n                output := or(\n                    shr(4, and(output, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\n                    shr(8, and(output, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\n                )\n                output := add(\n                    add(0x3030303030303030303030303030303030303030303030303030303030303030, output),\n                    mul(\n                        and(\n                            shr(4, add(output, 0x0606060606060606060606060606060606060606060606060606060606060606)),\n                            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\n                        ),\n                        7 // Change 7 to 39 for lower case output\n                    )\n                )\n            }\n\n            result := mload(0x40)\n            let length := mload(data)\n            let resultLength := shl(1, length)\n            let toPtr := add(result, 0x22) // 32 bytes for length + 2 bytes for '0x'\n            mstore(0x40, add(toPtr, resultLength)) // move free memory pointer\n            mstore(add(result, 2), 0x3078) // 0x3078 is right aligned so we write to `result + 2`\n            // to store the last 2 bytes in the beginning of the string\n            mstore(result, add(resultLength, 2)) // extra 2 bytes for '0x'\n\n            for {\n                let fromPtr := add(data, 0x20)\n                let endPtr := add(fromPtr, length)\n            } lt(fromPtr, endPtr) {\n                fromPtr := add(fromPtr, 0x20)\n            } {\n                let rawData := mload(fromPtr)\n                let hexData := _toHex16(rawData)\n                mstore(toPtr, hexData)\n                toPtr := add(toPtr, 0x20)\n                hexData := _toHex16(shl(128, rawData))\n                mstore(toPtr, hexData)\n                toPtr := add(toPtr, 0x20)\n            }\n        }\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/libraries/UniERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IERC20MetadataUppercase.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./StringUtil.sol\";\n\n/**\n * @title UniERC20\n * @dev Library to abstract the handling of ETH and ERC20 tokens, enabling unified interaction with both. It allows usage of ETH as ERC20.\n * Utilizes SafeERC20 for ERC20 interactions and provides additional utility functions.\n */\nlibrary UniERC20 {\n    using SafeERC20 for IERC20;\n\n    error InsufficientBalance();\n    error ApproveCalledOnETH();\n    error NotEnoughValue();\n    error FromIsNotSender();\n    error ToIsNotThis();\n    error ETHTransferFailed();\n\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\n\n    /**\n     * @dev Determines if the specified token is ETH.\n     * @param token The token to check.\n     * @return bool True if the token is ETH, false otherwise.\n     */\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    /**\n     * @dev Retrieves the balance of the specified token for an account.\n     * @param token The token to query the balance of.\n     * @param account The address of the account.\n     * @return uint256 The balance of the token for the specified account.\n     */\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    /**\n     * @dev Transfers a specified amount of the token to a given address.\n     * Note: Does nothing if the amount is zero.\n     * @param token The token to transfer.\n     * @param to The address to transfer the token to.\n     * @param amount The amount of the token to transfer.\n     */\n    function uniTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (address(this).balance < amount) revert InsufficientBalance();\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = to.call{value: amount}(\"\");\n                if (!success) revert ETHTransferFailed();\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a specified amount of the token from one address to another.\n     * Note: Does nothing if the amount is zero.\n     * @param token The token to transfer.\n     * @param from The address to transfer the token from.\n     * @param to The address to transfer the token to.\n     * @param amount The amount of the token to transfer.\n     */\n    function uniTransferFrom(\n        IERC20 token,\n        address payable from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (msg.value < amount) revert NotEnoughValue();\n                if (from != msg.sender) revert FromIsNotSender();\n                if (to != address(this)) revert ToIsNotThis();\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    unchecked {\n                        // solhint-disable-next-line avoid-low-level-calls\n                        (bool success, ) = from.call{value: msg.value - amount}(\"\");\n                        if (!success) revert ETHTransferFailed();\n                    }\n                }\n            } else {\n                token.safeTransferFrom(from, to, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Retrieves the symbol from ERC20 metadata of the specified token.\n     * @param token The token to retrieve the symbol of.\n     * @return string The symbol of the token.\n     */\n    function uniSymbol(IERC20 token) internal view returns (string memory) {\n        return _uniDecode(token, IERC20Metadata.symbol.selector, IERC20MetadataUppercase.SYMBOL.selector);\n    }\n\n    /**\n     * @dev Retrieves the name from ERC20 metadata of the specified token.\n     * @param token The token to retrieve the name of.\n     * @return string The name of the token.\n     */\n    function uniName(IERC20 token) internal view returns (string memory) {\n        return _uniDecode(token, IERC20Metadata.name.selector, IERC20MetadataUppercase.NAME.selector);\n    }\n\n    /**\n     * @dev forceApprove the specified amount of the token to a given address.\n     * Reverts if the token is ETH.\n     * @param token The token to approve.\n     * @param to The address to approve the token to.\n     * @param amount The amount of the token to approve.\n     */\n    function uniApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isETH(token)) revert ApproveCalledOnETH();\n\n        token.forceApprove(to, amount);\n    }\n\n    /**\n     * @dev Internal function to decode token metadata (name or symbol).\n     * 20K gas is provided to account for possible implementations of name/symbol\n     * (token implementation might be behind proxy or store the value in storage)\n     * @param token The token to decode metadata for.\n     * @param lowerCaseSelector The selector for the lowercase metadata function.\n     * @param upperCaseSelector The selector for the uppercase metadata function.\n     * @return result The decoded metadata value.\n     */\n    function _uniDecode(\n        IERC20 token,\n        bytes4 lowerCaseSelector,\n        bytes4 upperCaseSelector\n    ) private view returns (string memory result) {\n        if (isETH(token)) {\n            return \"ETH\";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 20000}(\n            abi.encodeWithSelector(lowerCaseSelector)\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(upperCaseSelector));\n        }\n\n        if (success && data.length >= 0x40) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            /*\n                return data is padded up to 32 bytes with ABI encoder also sometimes\n                there is extra 32 bytes of zeros padded in the end:\n                https://github.com/ethereum/solidity/issues/10170\n                because of that we can't check for equality and instead check\n                that overall data length is greater or equal than string length + extra 64 bytes\n            */\n            if (offset == 0x20 && data.length >= 0x40 + len) {\n                assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                    result := add(data, 0x40)\n                }\n                return result;\n            }\n        }\n        if (success && data.length == 32) {\n            uint256 len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                unchecked {\n                    len++;\n                }\n            }\n\n            if (len > 0) {\n                assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                    mstore(data, len)\n                }\n                return string(data);\n            }\n        }\n\n        return StringUtil.toHex(address(token));\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/mixins/EthReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title EthReceiver\n * @dev Abstract contract for rejecting direct ETH transfers from EOAs.\n * Implements a custom error and logic to reject ETH deposits from non-contract addresses.\n */\nabstract contract EthReceiver {\n    /// @dev Error thrown when an ETH deposit from an EOA is attempted.\n    error EthDepositRejected();\n\n    /// @dev External payable function to receive ETH, automatically rejects deposits from EOAs.\n    receive() external payable {\n        _receive();\n    }\n\n    /**\n     * @dev Internal function containing the logic to reject ETH deposits.\n     * Can be overridden by derived contracts for specific behaviors while maintaining the base rejection mechanism.\n     */\n    function _receive() internal virtual {\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender == tx.origin) revert EthDepositRejected();\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/mixins/OnlyWethReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./EthReceiver.sol\";\n\n/**\n * @title OnlyWethReceiver\n * @dev Abstract contract extending EthReceiver to accept only ETH deposits from a specified WETH contract.\n * This contract ensures that only wrapped ETH (WETH) can be deposited, rejecting all other direct ETH transfers.\n */\nabstract contract OnlyWethReceiver is EthReceiver {\n    /// @notice Address of the WETH contract allowed to deposit ETH.\n    address private immutable _WETH; // solhint-disable-line var-name-mixedcase\n\n    /**\n     * @dev Sets the WETH contract address during construction.\n     * @param weth Address of the WETH contract.\n     */\n    constructor(address weth) {\n        _WETH = address(weth);\n    }\n\n    /**\n     * @dev Overrides _receive to restrict ETH transfers solely to the WETH contract.\n     * Reverts with EthDepositRejected if ETH is sent from any other address.\n     */\n    function _receive() internal virtual override {\n        if (msg.sender != _WETH) revert EthDepositRejected();\n    }\n}\n"
    },
    "@1inch/solidity-utils/contracts/mixins/PermitAndCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"../libraries/SafeERC20.sol\";\n\n/**\n * @title PermitAndCall\n * @dev Abstract contract to support permit and action execution in a single transaction.\n * Allows tokens that implement EIP-2612 permits, DAI-like permits, USDC-like permits and Permit2 to be approved and spent in a single transaction.\n */\nabstract contract PermitAndCall {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Executes a permit for an ERC20 token and then a specified action in a single transaction.\n     * @param permit ERC20 token address (20 bytes) concatenated with the permit data, allowing this contract to spend the token.\n     * Format: [token address (20 bytes)][permit data]\n     * @param action The data representing the action to be executed after the permit.\n     */\n    function permitAndCall(bytes calldata permit, bytes calldata action) external payable {\n        IERC20(address(bytes20(permit))).tryPermit(permit[20:]);\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, action.offset, action.length)\n            let success := delegatecall(gas(), address(), ptr, action.length, 0, 0)\n            returndatacopy(ptr, 0, returndatasize())\n            switch success\n            case 0 {\n                revert(ptr, returndatasize())\n            }\n            default {\n                return(ptr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallbacks calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\n\ninterface Guard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/examples/libraries/GnosisSafeStorage.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title GnosisSafeStorage - Storage layout of the Safe contracts to be used in libraries\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeStorage {\n    // From /common/Singleton.sol\n    address internal singleton;\n    // From /common/ModuleManager.sol\n    mapping(address => address) internal modules;\n    // From /common/OwnerManager.sol\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    // From /GnosisSafe.sol\n    bytes32 internal nonce;\n    bytes32 internal domainSeparator;\n    mapping(bytes32 => uint256) internal signedMessages;\n    mapping(address => mapping(bytes32 => uint256)) internal approvedHashes;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/external/GnosisSafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/EtherPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    nonce\n                );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    SAFE_TX_TYPEHASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Not enough balance for performing a CREATE2 deploy.\n     */\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error Create2FailedDeployment();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Create2InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Create2FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/BaseEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AddressLib, Address } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport { SafeERC20 } from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\nimport { Timelocks, TimelocksLib } from \"./libraries/TimelocksLib.sol\";\n\nimport { IBaseEscrow } from \"./interfaces/IBaseEscrow.sol\";\n\n/**\n * @title Base abstract Escrow contract for cross-chain atomic swap.\n * @dev {IBaseEscrow-withdraw}, {IBaseEscrow-cancel} and _validateImmutables functions must be implemented in the derived contracts.\n * @custom:security-contact security@1inch.io\n */\nabstract contract BaseEscrow is IBaseEscrow {\n    using AddressLib for Address;\n    using SafeERC20 for IERC20;\n    using TimelocksLib for Timelocks;\n    using ImmutablesLib for Immutables;\n\n    // Token that is used to access public withdraw or cancel functions.\n    IERC20 private immutable _ACCESS_TOKEN;\n\n    /// @notice See {IBaseEscrow-RESCUE_DELAY}.\n    uint256 public immutable RESCUE_DELAY;\n    /// @notice See {IBaseEscrow-FACTORY}.\n    address public immutable FACTORY = msg.sender;\n\n    constructor(uint32 rescueDelay, IERC20 accessToken) {\n        RESCUE_DELAY = rescueDelay;\n        _ACCESS_TOKEN = accessToken;\n    }\n\n    modifier onlyTaker(Immutables calldata immutables) {\n        if (msg.sender != immutables.taker.get()) revert InvalidCaller();\n        _;\n    }\n\n    modifier onlyValidImmutables(Immutables calldata immutables) virtual {\n        _validateImmutables(immutables);\n        _;\n    }\n\n    modifier onlyValidSecret(bytes32 secret, Immutables calldata immutables) {\n        if (_keccakBytes32(secret) != immutables.hashlock) revert InvalidSecret();\n        _;\n    }\n\n    modifier onlyAfter(uint256 start) {\n        if (block.timestamp < start) revert InvalidTime();\n        _;\n    }\n\n    modifier onlyBefore(uint256 stop) {\n        if (block.timestamp >= stop) revert InvalidTime();\n        _;\n    }\n\n    modifier onlyAccessTokenHolder() {\n        if (_ACCESS_TOKEN.balanceOf(msg.sender) == 0) revert InvalidCaller();\n        _;\n    }\n\n    /**\n     * @notice See {IBaseEscrow-rescueFunds}.\n     */\n    function rescueFunds(\n        address token,\n        uint256 amount,\n        Immutables calldata immutables\n    )\n        external\n        onlyTaker(immutables)\n        onlyValidImmutables(immutables)\n        onlyAfter(immutables.timelocks.rescueStart(RESCUE_DELAY))\n    {\n        _uniTransfer(token, msg.sender, amount);\n        emit FundsRescued(token, amount);\n    }\n\n    /**\n     * @dev Transfers ERC20 or native tokens to the recipient.\n     */\n    function _uniTransfer(address token, address to, uint256 amount) internal {\n        if (token == address(0)) {\n            _ethTransfer(to, amount);\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev Transfers native tokens to the recipient.\n     */\n    function _ethTransfer(address to, uint256 amount) internal {\n        (bool success, ) = to.call{ value: amount }(\"\");\n        if (!success) revert NativeTokenSendingFailure();\n    }\n\n    /**\n     * @dev Should verify that the computed escrow address matches the address of this contract.\n     */\n    function _validateImmutables(Immutables calldata immutables) internal view virtual;\n\n    /**\n     * @dev Computes the Keccak-256 hash of the secret.\n     * @param secret The secret that unlocks the escrow.\n     * @return ret The computed hash.\n     */\n    function _keccakBytes32(bytes32 secret) private pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            mstore(0, secret)\n            ret := keccak256(0, 0x20)\n        }\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/BaseEscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport { Address, AddressLib } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport { SafeERC20 } from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\nimport { IOrderMixin } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\";\nimport { MakerTraitsLib } from \"@1inch/limit-order-protocol-contract/contracts/libraries/MakerTraitsLib.sol\";\nimport { ResolverValidationExtension } from \"../limit-order-settlement/extensions/ResolverValidationExtension.sol\";\n\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\nimport { Timelocks, TimelocksLib } from \"./libraries/TimelocksLib.sol\";\n\nimport { IEscrowFactory } from \"./interfaces/IEscrowFactory.sol\";\nimport { IBaseEscrow } from \"./interfaces/IBaseEscrow.sol\";\nimport { SRC_IMMUTABLES_LENGTH } from \"./EscrowFactoryContext.sol\";\nimport { MerkleStorageInvalidator } from \"./MerkleStorageInvalidator.sol\";\n\n/**\n * @title Abstract contract for escrow factory\n * @notice Contract to create escrow contracts for cross-chain atomic swap.\n * @dev Immutable variables must be set in the constructor of the derived contracts.\n * @custom:security-contact security@1inch.io\n */\nabstract contract BaseEscrowFactory is IEscrowFactory, ResolverValidationExtension, MerkleStorageInvalidator {\n    using AddressLib for Address;\n    using Clones for address;\n    using ImmutablesLib for IBaseEscrow.Immutables;\n    using SafeERC20 for IERC20;\n    using TimelocksLib for Timelocks;\n\n    /// @notice See {IEscrowFactory-ESCROW_SRC_IMPLEMENTATION}.\n    address public immutable ESCROW_SRC_IMPLEMENTATION;\n    /// @notice See {IEscrowFactory-ESCROW_DST_IMPLEMENTATION}.\n    address public immutable ESCROW_DST_IMPLEMENTATION;\n    bytes32 internal immutable _PROXY_SRC_BYTECODE_HASH;\n    bytes32 internal immutable _PROXY_DST_BYTECODE_HASH;\n\n    /**\n     * @notice Creates a new escrow contract for maker on the source chain.\n     * @dev The caller must be whitelisted and pre-send the safety deposit in a native token\n     * to a pre-computed deterministic address of the created escrow.\n     * The external postInteraction function call will be made from the Limit Order Protocol\n     * after all funds have been transferred. See {IPostInteraction-postInteraction}.\n     * `extraData` consists of:\n     *   - ExtraDataArgs struct\n     *   - whitelist\n     *   - 0 / 4 bytes for the fee\n     *   - 1 byte for the bitmap\n     */\n    function _postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal override(ResolverValidationExtension) {\n        uint256 superArgsLength = extraData.length - SRC_IMMUTABLES_LENGTH;\n        super._postInteraction(\n            order,\n            extension,\n            orderHash,\n            taker,\n            makingAmount,\n            takingAmount,\n            remainingMakingAmount,\n            extraData[:superArgsLength]\n        );\n\n        ExtraDataArgs calldata extraDataArgs;\n        assembly (\"memory-safe\") {\n            extraDataArgs := add(extraData.offset, superArgsLength)\n        }\n\n        bytes32 hashlock;\n\n        if (MakerTraitsLib.allowMultipleFills(order.makerTraits)) {\n            uint256 partsAmount = uint256(extraDataArgs.hashlockInfo) >> 240;\n            if (partsAmount < 2) revert InvalidSecretsAmount();\n            bytes32 key = keccak256(abi.encodePacked(orderHash, uint240(uint256(extraDataArgs.hashlockInfo))));\n            ValidationData memory validated = lastValidated[key];\n            hashlock = validated.leaf;\n            if (\n                !_isValidPartialFill(\n                    makingAmount,\n                    remainingMakingAmount,\n                    order.makingAmount,\n                    partsAmount,\n                    validated.index\n                )\n            ) {\n                revert InvalidPartialFill();\n            }\n        } else {\n            hashlock = extraDataArgs.hashlockInfo;\n        }\n\n        IBaseEscrow.Immutables memory immutables = IBaseEscrow.Immutables({\n            orderHash: orderHash,\n            hashlock: hashlock,\n            maker: order.maker,\n            taker: Address.wrap(uint160(taker)),\n            token: order.makerAsset,\n            amount: makingAmount,\n            safetyDeposit: extraDataArgs.deposits >> 128,\n            timelocks: extraDataArgs.timelocks.setDeployedAt(block.timestamp)\n        });\n\n        DstImmutablesComplement memory immutablesComplement = DstImmutablesComplement({\n            maker: order.receiver.get() == address(0) ? order.maker : order.receiver,\n            amount: takingAmount,\n            token: extraDataArgs.dstToken,\n            safetyDeposit: extraDataArgs.deposits & type(uint128).max,\n            chainId: extraDataArgs.dstChainId\n        });\n\n        emit SrcEscrowCreated(immutables, immutablesComplement);\n\n        bytes32 salt = immutables.hashMem();\n        address escrow = _deployEscrow(salt, 0, ESCROW_SRC_IMPLEMENTATION);\n        if (\n            escrow.balance < immutables.safetyDeposit ||\n            IERC20(order.makerAsset.get()).safeBalanceOf(escrow) < makingAmount\n        ) {\n            revert InsufficientEscrowBalance();\n        }\n    }\n\n    /**\n     * @notice See {IEscrowFactory-createDstEscrow}.\n     */\n    function createDstEscrow(\n        IBaseEscrow.Immutables calldata dstImmutables,\n        uint256 srcCancellationTimestamp\n    ) external payable {\n        address token = dstImmutables.token.get();\n        uint256 nativeAmount = dstImmutables.safetyDeposit;\n        if (token == address(0)) {\n            nativeAmount += dstImmutables.amount;\n        }\n        if (msg.value != nativeAmount) revert InsufficientEscrowBalance();\n\n        IBaseEscrow.Immutables memory immutables = dstImmutables;\n        immutables.timelocks = immutables.timelocks.setDeployedAt(block.timestamp);\n        // Check that the escrow cancellation will start not later than the cancellation time on the source chain.\n        if (immutables.timelocks.get(TimelocksLib.Stage.DstCancellation) > srcCancellationTimestamp)\n            revert InvalidCreationTime();\n\n        bytes32 salt = immutables.hashMem();\n        address escrow = _deployEscrow(salt, msg.value, ESCROW_DST_IMPLEMENTATION);\n        if (token != address(0)) {\n            IERC20(token).safeTransferFrom(msg.sender, escrow, immutables.amount);\n        }\n\n        emit DstEscrowCreated(escrow, dstImmutables.hashlock, dstImmutables.taker);\n    }\n\n    /**\n     * @notice See {IEscrowFactory-addressOfEscrowSrc}.\n     */\n    function addressOfEscrowSrc(IBaseEscrow.Immutables calldata immutables) external view virtual returns (address) {\n        return Create2.computeAddress(immutables.hash(), _PROXY_SRC_BYTECODE_HASH);\n    }\n\n    /**\n     * @notice See {IEscrowFactory-addressOfEscrowDst}.\n     */\n    function addressOfEscrowDst(IBaseEscrow.Immutables calldata immutables) external view virtual returns (address) {\n        return Create2.computeAddress(immutables.hash(), _PROXY_DST_BYTECODE_HASH);\n    }\n\n    /**\n     * @notice Deploys a new escrow contract.\n     * @param salt The salt for the deterministic address computation.\n     * @param value The value to be sent to the escrow contract.\n     * @param implementation Address of the implementation.\n     * @return escrow The address of the deployed escrow contract.\n     */\n    function _deployEscrow(\n        bytes32 salt,\n        uint256 value,\n        address implementation\n    ) internal virtual returns (address escrow) {\n        escrow = implementation.cloneDeterministic(salt);\n    }\n\n    function _isValidPartialFill(\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        uint256 orderMakingAmount,\n        uint256 partsAmount,\n        uint256 validatedIndex\n    ) internal pure returns (bool) {\n        uint256 calculatedIndex = ((orderMakingAmount - remainingMakingAmount + makingAmount - 1) * partsAmount) /\n            orderMakingAmount;\n\n        if (remainingMakingAmount == makingAmount) {\n            // If the order is filled to completion, a secret with index i + 1 must be used\n            // where i is the index of the secret for the last part.\n            return (calculatedIndex + 2 == validatedIndex);\n        } else if (orderMakingAmount != remainingMakingAmount) {\n            // Calculate the previous fill index only if this is not the first fill.\n            uint256 prevCalculatedIndex = ((orderMakingAmount - remainingMakingAmount - 1) * partsAmount) /\n                orderMakingAmount;\n            if (calculatedIndex == prevCalculatedIndex) return false;\n        }\n\n        return calculatedIndex + 1 == validatedIndex;\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\nimport { ProxyHashLib } from \"./libraries/ProxyHashLib.sol\";\n\nimport { IEscrow } from \"./interfaces/IEscrow.sol\";\nimport { BaseEscrow } from \"./BaseEscrow.sol\";\n\n/**\n * @title Abstract Escrow contract for cross-chain atomic swap.\n * @dev {IBaseEscrow-withdraw} and {IBaseEscrow-cancel} functions must be implemented in the derived contracts.\n * @custom:security-contact security@1inch.io\n */\nabstract contract Escrow is BaseEscrow, IEscrow {\n    using ImmutablesLib for Immutables;\n\n    /// @notice See {IEscrow-PROXY_BYTECODE_HASH}.\n    bytes32 public immutable PROXY_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(address(this));\n\n    /**\n     * @dev Verifies that the computed escrow address matches the address of this contract.\n     */\n    function _validateImmutables(Immutables calldata immutables) internal view virtual override {\n        bytes32 salt = immutables.hash();\n        if (Create2.computeAddress(salt, PROXY_BYTECODE_HASH, FACTORY) != address(this)) {\n            revert InvalidImmutables();\n        }\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/EscrowDst.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport { AddressLib, Address } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\n\nimport { Timelocks, TimelocksLib } from \"./libraries/TimelocksLib.sol\";\n\nimport { IEscrowDst } from \"./interfaces/IEscrowDst.sol\";\nimport { BaseEscrow } from \"./BaseEscrow.sol\";\nimport { Escrow } from \"./Escrow.sol\";\n\n/**\n * @title Destination Escrow contract for cross-chain atomic swap.\n * @notice Contract to initially lock funds and then unlock them with verification of the secret presented.\n * @dev Funds are locked in at the time of contract deployment. For this taker calls the `EscrowFactory.createDstEscrow` function.\n * To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.\n * @custom:security-contact security@1inch.io\n */\ncontract EscrowDst is Escrow, IEscrowDst {\n    using SafeERC20 for IERC20;\n    using AddressLib for Address;\n    using TimelocksLib for Timelocks;\n\n    constructor(uint32 rescueDelay, IERC20 accessToken) BaseEscrow(rescueDelay, accessToken) {}\n\n    /**\n     * @notice See {IBaseEscrow-withdraw}.\n     * @dev The function works on the time intervals highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/-- private cancellation ----\n     */\n    function withdraw(\n        bytes32 secret,\n        Immutables calldata immutables\n    )\n        external\n        onlyTaker(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.DstWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.DstCancellation))\n    {\n        _withdraw(secret, immutables);\n    }\n\n    /**\n     * @notice See {IBaseEscrow-publicWithdraw}.\n     * @dev The function works on the time intervals highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/-- private cancellation ----\n     */\n    function publicWithdraw(\n        bytes32 secret,\n        Immutables calldata immutables\n    )\n        external\n        onlyAccessTokenHolder\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.DstPublicWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.DstCancellation))\n    {\n        _withdraw(secret, immutables);\n    }\n\n    /**\n     * @notice See {IBaseEscrow-cancel}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/-- PRIVATE CANCELLATION ----\n     */\n    function cancel(\n        Immutables calldata immutables\n    )\n        external\n        onlyTaker(immutables)\n        onlyValidImmutables(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.DstCancellation))\n    {\n        _uniTransfer(immutables.token.get(), immutables.taker.get(), immutables.amount);\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\n        emit EscrowCancelled();\n    }\n\n    /**\n     * @dev Transfers ERC20 (or native) tokens to the maker and native tokens to the caller.\n     * @param immutables The immutable values used to deploy the clone contract.\n     */\n    function _withdraw(\n        bytes32 secret,\n        Immutables calldata immutables\n    ) internal onlyValidImmutables(immutables) onlyValidSecret(secret, immutables) {\n        _uniTransfer(immutables.token.get(), immutables.maker.get(), immutables.amount);\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\n        emit EscrowWithdrawal(secret);\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/EscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { BaseExtension } from \"../limit-order-settlement/extensions/BaseExtension.sol\";\nimport { ResolverValidationExtension } from \"../limit-order-settlement/extensions/ResolverValidationExtension.sol\";\n\nimport { ProxyHashLib } from \"./libraries/ProxyHashLib.sol\";\n\nimport { BaseEscrowFactory } from \"./BaseEscrowFactory.sol\";\nimport { EscrowDst } from \"./EscrowDst.sol\";\nimport { EscrowSrc } from \"./EscrowSrc.sol\";\nimport { MerkleStorageInvalidator } from \"./MerkleStorageInvalidator.sol\";\n\n/**\n * @title Escrow Factory contract\n * @notice Contract to create escrow contracts for cross-chain atomic swap.\n * @custom:security-contact security@1inch.io\n */\ncontract EscrowFactory is BaseEscrowFactory {\n    constructor(\n        address limitOrderProtocol,\n        IERC20 feeToken,\n        IERC20 accessToken,\n        address owner,\n        uint32 rescueDelaySrc,\n        uint32 rescueDelayDst\n    )\n        BaseExtension(limitOrderProtocol)\n        ResolverValidationExtension(feeToken, accessToken, owner)\n        MerkleStorageInvalidator(limitOrderProtocol)\n    {\n        ESCROW_SRC_IMPLEMENTATION = address(new EscrowSrc(rescueDelaySrc, accessToken));\n        ESCROW_DST_IMPLEMENTATION = address(new EscrowDst(rescueDelayDst, accessToken));\n        _PROXY_SRC_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_SRC_IMPLEMENTATION);\n        _PROXY_DST_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_DST_IMPLEMENTATION);\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/EscrowFactoryContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nuint256 constant SRC_IMMUTABLES_LENGTH = 160;\n"
    },
    "contracts/1inch/cross-chain-swap/EscrowSrc.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport { AddressLib, Address } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\n\nimport { Timelocks, TimelocksLib } from \"./libraries/TimelocksLib.sol\";\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\n\nimport { IEscrowSrc } from \"./interfaces/IEscrowSrc.sol\";\nimport { BaseEscrow } from \"./BaseEscrow.sol\";\nimport { Escrow } from \"./Escrow.sol\";\n\n/**\n * @title Source Escrow contract for cross-chain atomic swap.\n * @notice Contract to initially lock funds and then unlock them with verification of the secret presented.\n * @dev Funds are locked in at the time of contract deployment. For this Limit Order Protocol\n * calls the `EscrowFactory.postInteraction` function.\n * To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.\n * @custom:security-contact security@1inch.io\n */\ncontract EscrowSrc is Escrow, IEscrowSrc {\n    using AddressLib for Address;\n    using ImmutablesLib for Immutables;\n    using SafeERC20 for IERC20;\n    using TimelocksLib for Timelocks;\n\n    constructor(uint32 rescueDelay, IERC20 accessToken) BaseEscrow(rescueDelay, accessToken) {}\n\n    /**\n     * @notice See {IBaseEscrow-withdraw}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/--\n     * --/-- private cancellation --/-- public cancellation ----\n     */\n    function withdraw(\n        bytes32 secret,\n        Immutables calldata immutables\n    )\n        external\n        onlyTaker(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _withdrawTo(secret, msg.sender, immutables);\n    }\n\n    /**\n     * @notice See {IEscrowSrc-withdrawTo}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/--\n     * --/-- private cancellation --/-- public cancellation ----\n     */\n    function withdrawTo(\n        bytes32 secret,\n        address target,\n        Immutables calldata immutables\n    )\n        external\n        onlyTaker(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _withdrawTo(secret, target, immutables);\n    }\n\n    /**\n     * @notice See {IEscrowSrc-publicWithdraw}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/--\n     * --/-- private cancellation --/-- public cancellation ----\n     */\n    function publicWithdraw(\n        bytes32 secret,\n        Immutables calldata immutables\n    )\n        external\n        onlyAccessTokenHolder\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcPublicWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _withdrawTo(secret, immutables.taker.get(), immutables);\n    }\n\n    /**\n     * @notice See {IBaseEscrow-cancel}.\n     * @dev The function works on the time intervals highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/--\n     * --/-- PRIVATE CANCELLATION --/-- PUBLIC CANCELLATION ----\n     */\n    function cancel(\n        Immutables calldata immutables\n    ) external onlyTaker(immutables) onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation)) {\n        _cancel(immutables);\n    }\n\n    /**\n     * @notice See {IEscrowSrc-publicCancel}.\n     * @dev The function works on the time intervals highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/--\n     * --/-- private cancellation --/-- PUBLIC CANCELLATION ----\n     */\n    function publicCancel(\n        Immutables calldata immutables\n    ) external onlyAccessTokenHolder onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcPublicCancellation)) {\n        _cancel(immutables);\n    }\n\n    /**\n     * @dev Transfers ERC20 tokens to the target and native tokens to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param target The address to transfer ERC20 tokens to.\n     * @param immutables The immutable values used to deploy the clone contract.\n     */\n    function _withdrawTo(\n        bytes32 secret,\n        address target,\n        Immutables calldata immutables\n    ) internal onlyValidImmutables(immutables) onlyValidSecret(secret, immutables) {\n        IERC20(immutables.token.get()).safeTransfer(target, immutables.amount);\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\n        emit EscrowWithdrawal(secret);\n    }\n\n    /**\n     * @dev Transfers ERC20 tokens to the maker and native tokens to the caller.\n     * @param immutables The immutable values used to deploy the clone contract.\n     */\n    function _cancel(Immutables calldata immutables) internal onlyValidImmutables(immutables) {\n        IERC20(immutables.token.get()).safeTransfer(immutables.maker.get(), immutables.amount);\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\n        emit EscrowCancelled();\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IBaseEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Address } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\n\nimport { Timelocks } from \"../libraries/TimelocksLib.sol\";\n\n/**\n * @title Base Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IBaseEscrow {\n    struct Immutables {\n        bytes32 orderHash;\n        bytes32 hashlock; // Hash of the secret.\n        Address maker;\n        Address taker;\n        Address token;\n        uint256 amount;\n        uint256 safetyDeposit;\n        Timelocks timelocks;\n    }\n\n    /**\n     * @notice Emitted on escrow cancellation.\n     */\n    event EscrowCancelled();\n\n    /**\n     * @notice Emitted when funds are rescued.\n     * @param token The address of the token rescued. Zero address for native token.\n     * @param amount The amount of tokens rescued.\n     */\n    event FundsRescued(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on successful withdrawal.\n     * @param secret The secret that unlocks the escrow.\n     */\n    event EscrowWithdrawal(bytes32 secret);\n\n    error InvalidCaller();\n    error InvalidImmutables();\n    error InvalidSecret();\n    error InvalidTime();\n    error NativeTokenSendingFailure();\n\n    /* solhint-disable func-name-mixedcase */\n    /// @notice Returns the delay for rescuing funds from the escrow.\n    function RESCUE_DELAY() external view returns (uint256);\n\n    /// @notice Returns the address of the factory that created the escrow.\n    function FACTORY() external view returns (address);\n\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @notice Withdraws funds to a predetermined recipient.\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\n     * The safety deposit is sent to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function withdraw(bytes32 secret, Immutables calldata immutables) external;\n\n    /**\n     * @notice Cancels the escrow and returns tokens to a predetermined recipient.\n     * @dev The escrow can only be cancelled during the cancellation period.\n     * The safety deposit is sent to the caller.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function cancel(Immutables calldata immutables) external;\n\n    /**\n     * @notice Rescues funds from the escrow.\n     * @dev Funds can only be rescued by the taker after the rescue delay.\n     * @param token The address of the token to rescue. Zero address for native token.\n     * @param amount The amount of tokens to rescue.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function rescueFunds(address token, uint256 amount, Immutables calldata immutables) external;\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IBaseEscrow } from \"./IBaseEscrow.sol\";\n\n/**\n * @title Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrow is IBaseEscrow {\n    /// @notice Returns the bytecode hash of the proxy contract.\n    function PROXY_BYTECODE_HASH() external view returns (bytes32); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IEscrowDst.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IEscrow } from \"./IEscrow.sol\";\n\n/**\n * @title Destination Escrow interface for cross-chain atomic swap.\n * @notice Interface implies withdrawing funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrowDst is IEscrow {\n    /**\n     * @notice Withdraws funds to maker\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\n     * @param secret The secret that unlocks the escrow.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function publicWithdraw(bytes32 secret, IEscrow.Immutables calldata immutables) external;\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IEscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Address } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\n\nimport { Timelocks } from \"../libraries/TimelocksLib.sol\";\n\nimport { IBaseEscrow } from \"./IBaseEscrow.sol\";\n\n/**\n * @title Escrow Factory interface for cross-chain atomic swap.\n * @notice Interface to deploy escrow contracts for the destination chain and to get the deterministic address of escrow on both chains.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrowFactory {\n    struct ExtraDataArgs {\n        bytes32 hashlockInfo; // Hash of the secret or the Merkle tree root if multiple fills are allowed\n        uint256 dstChainId;\n        Address dstToken;\n        uint256 deposits;\n        Timelocks timelocks;\n    }\n\n    struct DstImmutablesComplement {\n        Address maker;\n        uint256 amount;\n        Address token;\n        uint256 safetyDeposit;\n        uint256 chainId;\n    }\n\n    error InsufficientEscrowBalance();\n    error InvalidCreationTime();\n    error InvalidPartialFill();\n    error InvalidSecretsAmount();\n\n    /**\n     * @notice Emitted on EscrowSrc deployment to recreate EscrowSrc and EscrowDst immutables off-chain.\n     * @param srcImmutables The immutables of the escrow contract that are used in deployment on the source chain.\n     * @param dstImmutablesComplement Additional immutables related to the escrow contract on the destination chain.\n     */\n    event SrcEscrowCreated(IBaseEscrow.Immutables srcImmutables, DstImmutablesComplement dstImmutablesComplement);\n    /**\n     * @notice Emitted on EscrowDst deployment.\n     * @param escrow The address of the created escrow.\n     * @param hashlock The hash of the secret.\n     * @param taker The address of the taker.\n     */\n    event DstEscrowCreated(address escrow, bytes32 hashlock, Address taker);\n\n    /* solhint-disable func-name-mixedcase */\n    /// @notice Returns the address of implementation on the source chain.\n    function ESCROW_SRC_IMPLEMENTATION() external view returns (address);\n\n    /// @notice Returns the address of implementation on the destination chain.\n    function ESCROW_DST_IMPLEMENTATION() external view returns (address);\n\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @notice Creates a new escrow contract for taker on the destination chain.\n     * @dev The caller must send the safety deposit in the native token along with the function call\n     * and approve the destination token to be transferred to the created escrow.\n     * @param dstImmutables The immutables of the escrow contract that are used in deployment.\n     * @param srcCancellationTimestamp The start of the cancellation period for the source chain.\n     */\n    function createDstEscrow(\n        IBaseEscrow.Immutables calldata dstImmutables,\n        uint256 srcCancellationTimestamp\n    ) external payable;\n\n    /**\n     * @notice Returns the deterministic address of the source escrow based on the salt.\n     * @param immutables The immutable arguments used to compute salt for escrow deployment.\n     * @return The computed address of the escrow.\n     */\n    function addressOfEscrowSrc(IBaseEscrow.Immutables calldata immutables) external view returns (address);\n\n    /**\n     * @notice Returns the deterministic address of the destination escrow based on the salt.\n     * @param immutables The immutable arguments used to compute salt for escrow deployment.\n     * @return The computed address of the escrow.\n     */\n    function addressOfEscrowDst(IBaseEscrow.Immutables calldata immutables) external view returns (address);\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IEscrowSrc.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IEscrow } from \"./IEscrow.sol\";\n\n/**\n * @title Source Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrowSrc is IEscrow {\n    /**\n     * @notice Withdraws funds to a specified target.\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\n     * The safety deposit is sent to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param target The address to withdraw the funds to.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function withdrawTo(bytes32 secret, address target, IEscrow.Immutables calldata immutables) external;\n\n    /**\n     * @notice Withdraws funds to the taker.\n     * @dev Withdrawal can only be made during the public withdrawal period and with secret with hash matches the hashlock.\n     * @param secret The secret that unlocks the escrow.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function publicWithdraw(bytes32 secret, Immutables calldata immutables) external;\n\n    /**\n     * @notice Cancels the escrow and returns tokens to the maker.\n     * @dev The escrow can only be cancelled during the public cancellation period.\n     * The safety deposit is sent to the caller.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function publicCancel(IEscrow.Immutables calldata immutables) external;\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IMerkleStorageInvalidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/**\n * @title Merkle Storage Invalidator interface\n * @notice Interface to invalidate hashed secrets from an order that supports multiple fills.\n * @custom:security-contact security@1inch.io\n */\ninterface IMerkleStorageInvalidator {\n    struct ValidationData {\n        uint256 index;\n        bytes32 leaf;\n    }\n\n    struct TakerData {\n        bytes32[] proof;\n        uint256 idx;\n        bytes32 secretHash;\n    }\n\n    error AccessDenied();\n    error InvalidProof();\n\n    /**\n     * @notice Returns the index of the last validated hashed secret and the hashed secret itself.\n     * @param key Hash of concatenated order hash and 30 bytes of root hash.\n     * @return index Index of the last validated hashed secret.\n     * @return secretHash Last validated hashed secret.\n     */\n    function lastValidated(bytes32 key) external view returns (uint256 index, bytes32 secretHash);\n}\n"
    },
    "contracts/1inch/cross-chain-swap/interfaces/IResolverExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IOrderMixin } from \"../../limit-order-protocol/interfaces/IOrderMixin.sol\";\nimport { TakerTraits } from \"../../limit-order-protocol/libraries/TakerTraitsLib.sol\";\n\nimport { IBaseEscrow } from \"../interfaces/IBaseEscrow.sol\";\n\n/**\n * @title Interface for the sample implementation of a Resolver contract for cross-chain swap.\n * @custom:security-contact security@1inch.io\n */\ninterface IResolverExample {\n    error InvalidLength();\n    error LengthMismatch();\n\n    /**\n     * @notice Deploys a new escrow contract for maker on the source chain.\n     * @param immutables The immutables of the escrow contract that are used in deployment.\n     * @param order Order quote to fill.\n     * @param r R component of signature.\n     * @param vs VS component of signature.\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit).\n     */\n    function deploySrc(\n        IBaseEscrow.Immutables calldata immutables,\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external;\n\n    /**\n     * @notice Deploys a new escrow contract for taker on the destination chain.\n     * @param dstImmutables The immutables of the escrow contract that are used in deployment.\n     * @param srcCancellationTimestamp The start of the cancellation period for the source chain.\n     */\n    function deployDst(\n        IBaseEscrow.Immutables calldata dstImmutables,\n        uint256 srcCancellationTimestamp\n    ) external payable;\n\n    /**\n     * @notice Allows the owner to make arbitrary calls to other contracts on behalf of this contract.\n     * @param targets The addresses of the contracts to call.\n     * @param arguments The arguments to pass to the contract calls.\n     */\n    function arbitraryCalls(address[] calldata targets, bytes[] calldata arguments) external;\n}\n"
    },
    "contracts/1inch/cross-chain-swap/libraries/ImmutablesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IBaseEscrow } from \"../interfaces/IBaseEscrow.sol\";\n\n/**\n * @title Library for escrow immutables.\n * @custom:security-contact security@1inch.io\n */\nlibrary ImmutablesLib {\n    uint256 internal constant ESCROW_IMMUTABLES_SIZE = 0x100;\n\n    /**\n     * @notice Returns the hash of the immutables.\n     * @param immutables The immutables to hash.\n     * @return ret The computed hash.\n     */\n    function hash(IBaseEscrow.Immutables calldata immutables) internal pure returns(bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, immutables, ESCROW_IMMUTABLES_SIZE)\n            ret := keccak256(ptr, ESCROW_IMMUTABLES_SIZE)\n        }\n    }\n\n    /**\n     * @notice Returns the hash of the immutables.\n     * @param immutables The immutables to hash.\n     * @return ret The computed hash.\n     */\n    function hashMem(IBaseEscrow.Immutables memory immutables) internal pure returns(bytes32 ret) {\n        assembly (\"memory-safe\") {\n            ret := keccak256(immutables, ESCROW_IMMUTABLES_SIZE)\n        }\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/libraries/ProxyHashLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title Library to compute the hash of the proxy bytecode.\n * @custom:security-contact security@1inch.io\n */\nlibrary ProxyHashLib {\n    /**\n     * @notice Returns the hash of the proxy bytecode concatenated with the implementation address.\n     * @param implementation The address of the contract to clone.\n     * @return bytecodeHash The hash of the resulting bytecode.\n     */\n    function computeProxyBytecodeHash(address implementation) internal pure returns (bytes32 bytecodeHash) {\n        assembly (\"memory-safe\") {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            bytecodeHash := keccak256(0x09, 0x37)\n        }\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/libraries/TimelocksLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Timelocks for the source and the destination chains plus the deployment timestamp.\n * Timelocks store the number of seconds from the time the contract is deployed to the start of a specific period.\n * For illustrative purposes, it is possible to describe timelocks by two structures:\n * struct SrcTimelocks {\n *     uint256 withdrawal;\n *     uint256 publicWithdrawal;\n *     uint256 cancellation;\n *     uint256 publicCancellation;\n * }\n *\n * struct DstTimelocks {\n *     uint256 withdrawal;\n *     uint256 publicWithdrawal;\n *     uint256 cancellation;\n * }\n *\n * withdrawal: Period when only the taker with a secret can withdraw tokens for taker (source chain) or maker (destination chain).\n * publicWithdrawal: Period when anyone with a secret can withdraw tokens for taker (source chain) or maker (destination chain).\n * cancellation: Period when escrow can only be cancelled by the taker.\n * publicCancellation: Period when escrow can be cancelled by anyone.\n *\n * @custom:security-contact security@1inch.io\n */\ntype Timelocks is uint256;\n\n/**\n * @title Timelocks library for compact storage of timelocks in a uint256.\n */\nlibrary TimelocksLib {\n    enum Stage {\n        SrcWithdrawal,\n        SrcPublicWithdrawal,\n        SrcCancellation,\n        SrcPublicCancellation,\n        DstWithdrawal,\n        DstPublicWithdrawal,\n        DstCancellation\n    }\n\n    uint256 private constant _DEPLOYED_AT_MASK = 0xffffffff00000000000000000000000000000000000000000000000000000000;\n    uint256 private constant _DEPLOYED_AT_OFFSET = 224;\n\n    /**\n     * @notice Sets the Escrow deployment timestamp.\n     * @param timelocks The timelocks to set the deployment timestamp to.\n     * @param value The new Escrow deployment timestamp.\n     * @return The timelocks with the deployment timestamp set.\n     */\n    function setDeployedAt(Timelocks timelocks, uint256 value) internal pure returns (Timelocks) {\n        return Timelocks.wrap((Timelocks.unwrap(timelocks) & ~uint256(_DEPLOYED_AT_MASK)) | value << _DEPLOYED_AT_OFFSET);\n    }\n\n    /**\n     * @notice Returns the start of the rescue period.\n     * @param timelocks The timelocks to get the rescue delay from.\n     * @return The start of the rescue period.\n     */\n    function rescueStart(Timelocks timelocks, uint256 rescueDelay) internal pure returns (uint256) {\n        unchecked {\n            return rescueDelay + (Timelocks.unwrap(timelocks) >> _DEPLOYED_AT_OFFSET);\n        }\n    }\n\n    /**\n     * @notice Returns the timelock value for the given stage.\n     * @param timelocks The timelocks to get the value from.\n     * @param stage The stage to get the value for.\n     * @return The timelock value for the given stage.\n     */\n    function get(Timelocks timelocks, Stage stage) internal pure returns (uint256) {\n        uint256 data = Timelocks.unwrap(timelocks);\n        uint256 bitShift = uint256(stage) * 32;\n        // The maximum uint32 value will be reached in 2106.\n        return (data >> _DEPLOYED_AT_OFFSET) + uint32(data >> bitShift);\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/MerkleStorageInvalidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IOrderMixin } from \"../limit-order-protocol/interfaces/IOrderMixin.sol\";\nimport { ExtensionLib } from \"../limit-order-protocol/libraries/ExtensionLib.sol\";\nimport { ITakerInteraction } from \"../limit-order-protocol/interfaces/ITakerInteraction.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport { IEscrowFactory } from \"./interfaces/IEscrowFactory.sol\";\nimport { IMerkleStorageInvalidator } from \"./interfaces/IMerkleStorageInvalidator.sol\";\nimport { SRC_IMMUTABLES_LENGTH } from \"./EscrowFactoryContext.sol\"; // solhint-disable-line no-unused-import\n\n/**\n * @title Merkle Storage Invalidator contract\n * @notice Contract to invalidate hashed secrets from an order that supports multiple fills.\n * @custom:security-contact security@1inch.io\n */\ncontract MerkleStorageInvalidator is IMerkleStorageInvalidator, ITakerInteraction {\n    using MerkleProof for bytes32[];\n    using ExtensionLib for bytes;\n\n    address private immutable _LIMIT_ORDER_PROTOCOL;\n\n    /// @notice See {IMerkleStorageInvalidator-lastValidated}.\n    mapping(bytes32 key => ValidationData) public lastValidated;\n\n    /// @notice Only limit order protocol can call this contract.\n    modifier onlyLOP() {\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) {\n            revert AccessDenied();\n        }\n        _;\n    }\n\n    constructor(address limitOrderProtocol) {\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\n    }\n\n    /**\n     * @notice See {ITakerInteraction-takerInteraction}.\n     * @dev Verifies the proof and stores the last validated index and hashed secret.\n     * Only Limit Order Protocol can call this function.\n     */\n    function takerInteraction(\n        IOrderMixin.Order calldata /* order */,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address /* taker */,\n        uint256 /* makingAmount */,\n        uint256 /* takingAmount */,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external onlyLOP {\n        bytes calldata postInteraction = extension.postInteractionTargetAndData();\n        IEscrowFactory.ExtraDataArgs calldata extraDataArgs;\n        TakerData calldata takerData;\n        assembly (\"memory-safe\") {\n            extraDataArgs := add(postInteraction.offset, sub(postInteraction.length, SRC_IMMUTABLES_LENGTH))\n            takerData := extraData.offset\n        }\n        uint240 rootShortened = uint240(uint256(extraDataArgs.hashlockInfo));\n        bytes32 key = keccak256(abi.encodePacked(orderHash, rootShortened));\n        bytes32 rootCalculated = takerData.proof.processProofCalldata(\n            keccak256(abi.encodePacked(uint64(takerData.idx), takerData.secretHash))\n        );\n        if (uint240(uint256(rootCalculated)) != rootShortened) revert InvalidProof();\n        lastValidated[key] = ValidationData(takerData.idx + 1, takerData.secretHash);\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/mocks/ERC20True.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\ncontract ERC20True {\n    function transfer(address, uint256) public pure returns (bool) {\n        return true;\n    }\n\n    function transferFrom(address, address, uint256) public pure returns (bool) {\n        return true;\n    }\n\n    function approve(address, uint256) public pure returns (bool) {\n        return true;\n    }\n\n    function balanceOf(address) public pure returns (uint256) {\n        return 0;\n    }\n\n    function allowance(address, address) public pure returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/mocks/NoReceiveCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { RevertReasonForwarder } from \"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\";\n\ncontract NoReceiveCaller {\n    function arbitraryCall(address target, bytes calldata arguments) external {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call(arguments);\n        if (!success) RevertReasonForwarder.reRevert();\n    }\n}\n"
    },
    "contracts/1inch/cross-chain-swap/mocks/ResolverExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*──────────────────────────────────────────────────────────────────────────────\n * WARNING!\n * ----------\n * This smart-contract code has **NOT** undergone a formal security audit and\n * may contain bugs, vulnerabilities, or other defects. It is provided solely\n * as an illustrative example.  No warranties, express or implied, are given.\n * You assume all risks associated with deploying, interacting with, or\n * relying upon this code.  USE AT YOUR OWN RISK.\n *──────────────────────────────────────────────────────────────────────────────*/\n\npragma solidity 0.8.23;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IOrderMixin } from \"../../limit-order-protocol/interfaces/IOrderMixin.sol\";\nimport { TakerTraits } from \"../../limit-order-protocol/libraries/TakerTraitsLib.sol\";\nimport { RevertReasonForwarder } from \"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\";\n\nimport { IBaseEscrow } from \"../interfaces/IBaseEscrow.sol\";\nimport { IEscrowFactory } from \"../interfaces/IEscrowFactory.sol\";\nimport { IResolverExample } from \"../interfaces/IResolverExample.sol\";\nimport { TimelocksLib } from \"../libraries/TimelocksLib.sol\";\n\n/**\n * @title Sample implementation of a Resolver contract for cross-chain swap.\n * @dev It is important when deploying an escrow on the source chain to send the safety deposit and deploy the escrow in the same\n * transaction, since the address of the escrow depends on the block.timestamp.\n * You can find sample code for this in the {ResolverExample-deploySrc}.\n *\n * @custom:security-contact security@1inch.io\n */\ncontract ResolverExample is IResolverExample, Ownable {\n    IEscrowFactory private immutable _FACTORY;\n    IOrderMixin private immutable _LOP;\n\n    constructor(IEscrowFactory factory, IOrderMixin lop, address initialOwner) Ownable(initialOwner) {\n        _FACTORY = factory;\n        _LOP = lop;\n    }\n\n    receive() external payable {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice See {IResolverExample-deploySrc}.\n     */\n    function deploySrc(\n        IBaseEscrow.Immutables calldata immutables,\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external onlyOwner {\n        IBaseEscrow.Immutables memory immutablesMem = immutables;\n        immutablesMem.timelocks = TimelocksLib.setDeployedAt(immutables.timelocks, block.timestamp);\n        address computed = _FACTORY.addressOfEscrowSrc(immutablesMem);\n        (bool success, ) = address(computed).call{ value: immutablesMem.safetyDeposit }(\"\");\n        if (!success) revert IBaseEscrow.NativeTokenSendingFailure();\n\n        // _ARGS_HAS_TARGET = 1 << 251\n        takerTraits = TakerTraits.wrap(TakerTraits.unwrap(takerTraits) | uint256(1 << 251));\n        bytes memory argsMem = abi.encodePacked(computed, args);\n        _LOP.fillOrderArgs(order, r, vs, amount, takerTraits, argsMem);\n    }\n\n    /**\n     * @notice See {IResolverExample-deployDst}.\n     */\n    function deployDst(\n        IBaseEscrow.Immutables calldata dstImmutables,\n        uint256 srcCancellationTimestamp\n    ) external payable onlyOwner {\n        _FACTORY.createDstEscrow{ value: msg.value }(dstImmutables, srcCancellationTimestamp);\n    }\n\n    /**\n     * @notice See {IResolverExample-arbitraryCalls}.\n     */\n    function arbitraryCalls(address[] calldata targets, bytes[] calldata arguments) external onlyOwner {\n        uint256 length = targets.length;\n        if (targets.length != arguments.length) revert LengthMismatch();\n        for (uint256 i = 0; i < length; ++i) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = targets[i].call(arguments[i]);\n            if (!success) RevertReasonForwarder.reRevert();\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/AmountGetterBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IAmountGetter } from \"../interfaces/IAmountGetter.sol\";\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\n\n/// @title Base price getter contract that either calls external getter or applies linear formula\ncontract AmountGetterBase is IAmountGetter {\n    using Math for uint256;\n\n    /**\n     * @notice See {IAmountGetter-getMakingAmount}.\n     */\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        return _getMakingAmount(order, extension, orderHash, taker, takingAmount, remainingMakingAmount, extraData);\n    }\n\n    /**\n     * @notice See {IAmountGetter-getTakingAmount}.\n     */\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        return _getTakingAmount(order, extension, orderHash, taker, makingAmount, remainingMakingAmount, extraData);\n    }\n\n    function _getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view virtual returns (uint256) {\n        if (extraData.length >= 20) {\n            return IAmountGetter(address(bytes20(extraData))).getMakingAmount(\n                order, extension, orderHash, taker, takingAmount, remainingMakingAmount, extraData[20:]\n            );\n        } else {\n            return order.makingAmount.mulDiv(takingAmount, order.takingAmount);\n        }\n    }\n\n    function _getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view virtual returns (uint256) {\n        if (extraData.length >= 20) {\n            return IAmountGetter(address(bytes20(extraData))).getTakingAmount(\n                order, extension, orderHash, taker, makingAmount, remainingMakingAmount, extraData[20:]\n            );\n        } else {\n            return order.takingAmount.mulDiv(makingAmount, order.makingAmount, Math.Rounding.Ceil);\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/AmountGetterWithFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\nimport { AmountGetterBase } from \"./AmountGetterBase.sol\";\n\n/// @title Price getter contract that adds fee calculation\ncontract AmountGetterWithFee is AmountGetterBase {\n    using Math for uint256;\n\n    /// @dev Allows fees in range [1e-5, 0.65535]\n    uint256 internal constant _BASE_1E5 = 1e5;\n    uint256 internal constant _BASE_1E2 = 100;\n\n    error InvalidIntegratorShare();\n    error InvalidWhitelistDiscountNumerator();\n\n    /**\n     * @dev Calculates makingAmount with fee.\n     */\n    function _getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view virtual override returns (uint256) {\n        unchecked {\n            (, uint256 integratorFee, , uint256 resolverFee, bytes calldata tail) = _parseFeeData(extraData, taker, _isWhitelistedGetterImpl);\n            return super._getMakingAmount(order, extension, orderHash, taker, takingAmount, remainingMakingAmount, tail).mulDiv(\n                _BASE_1E5,\n                _BASE_1E5 + integratorFee + resolverFee\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates takingAmount with fee.\n     */\n    function _getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal view virtual override returns (uint256) {\n        unchecked {\n            (, uint256 integratorFee, , uint256 resolverFee, bytes calldata tail) = _parseFeeData(extraData, taker, _isWhitelistedGetterImpl);\n            return super._getTakingAmount(order, extension, orderHash, taker, makingAmount, remainingMakingAmount, tail).mulDiv(\n                _BASE_1E5 + integratorFee + resolverFee,\n                _BASE_1E5,\n                Math.Rounding.Ceil\n            );\n        }\n    }\n\n    /**\n     * @dev `extraData` consists of:\n     * 2 bytes — integrator fee percentage (in 1e5)\n     * 1 byte - integrator share percentage (in 1e2)\n     * 2 bytes — resolver fee percentage (in 1e5)\n     * 1 byte - whitelist discount numerator (in 1e2)\n     * bytes — whitelist structure determined by `_isWhitelisted` implementation\n     * bytes — custom data (optional)\n     * @param _isWhitelisted internal function to parse and check whitelist\n     */\n    function _parseFeeData(\n        bytes calldata extraData,\n        address taker,\n        function (bytes calldata, address) internal view returns (bool, bytes calldata) _isWhitelisted\n    ) internal view returns (bool isWhitelisted, uint256 integratorFee, uint256 integratorShare, uint256 resolverFee, bytes calldata tail) {\n        unchecked {\n            integratorFee = uint256(uint16(bytes2(extraData)));\n            integratorShare = uint256(uint8(extraData[2]));\n            if (integratorShare > _BASE_1E2) revert InvalidIntegratorShare();\n            resolverFee = uint256(uint16(bytes2(extraData[3:])));\n            uint256 whitelistDiscountNumerator = uint256(uint8(extraData[5]));\n            if (whitelistDiscountNumerator > _BASE_1E2) revert InvalidWhitelistDiscountNumerator();\n            (isWhitelisted, tail) = _isWhitelisted(extraData[6:], taker);\n            if (isWhitelisted) {\n                resolverFee = resolverFee * whitelistDiscountNumerator / _BASE_1E2;\n            }\n        }\n    }\n\n    /**\n     * @dev Validates whether the taker is whitelisted.\n     * @param whitelistData Whitelist data is a tightly packed struct of the following format:\n     * ```\n     * 1 byte - size of the whitelist\n     * (bytes10)[N] whitelisted addresses;\n     * ```\n     * Only 10 lowest bytes of the address are used for comparison.\n     * @param taker The taker address to check.\n     * @return isWhitelisted Whether the taker is whitelisted.\n     * @return tail Remaining calldata.\n     */\n    function _isWhitelistedGetterImpl(bytes calldata whitelistData, address taker) internal pure returns (bool isWhitelisted, bytes calldata tail) {\n        unchecked {\n            uint80 maskedTakerAddress = uint80(uint160(taker));\n            uint256 size = uint8(whitelistData[0]);\n            bytes calldata whitelist = whitelistData[1:1 + 10 * size];\n            tail = whitelistData[1 + 10 * size:];\n            for (uint256 i = 0; i < size; i++) {\n                uint80 whitelistedAddress = uint80(bytes10(whitelist[:10]));\n                if (maskedTakerAddress == whitelistedAddress) {\n                    return (true, tail);\n                }\n                whitelist = whitelist[10:];\n            }\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ApprovalPreInteraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\";\n\nimport \"../interfaces/IPreInteraction.sol\";\nimport \"./ImmutableOwner.sol\";\n\ncontract ApprovalPreInteraction is IPreInteraction, ImmutableOwner {\n    using AddressLib for Address;\n\n    error UnathorizedMaker();\n\n    address private immutable _MAKER;\n\n    constructor(address _immutableOwner, address _maker) ImmutableOwner(_immutableOwner) {\n        _MAKER = _maker;\n    }\n\n    /**\n     * @notice See {IPreInteraction-preInteraction}.\n     */\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 /* takingAmount */,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata /* extraData */\n    ) external onlyImmutableOwner {\n        if (order.maker.get() != address(this)) revert UnathorizedMaker();\n        IERC20(order.makerAsset.get()).approve(msg.sender, makingAmount);\n    }\n\n    /**\n     * @notice Checks if orderHash signature was signed with real order maker.\n     */\n    function isValidSignature(bytes32 orderHash, bytes calldata signature) external view returns(bytes4) {\n        if (ECDSA.recoverOrIsValidSignature(_MAKER, orderHash, signature)) {\n            return IERC1271.isValidSignature.selector;\n        } else {\n            return 0xffffffff;\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ChainlinkCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/IOrderMixin.sol\";\nimport \"../interfaces/IAmountGetter.sol\";\n\n// solhint-disable not-rely-on-time\n\n/// @title A helper contract for interactions with https://docs.chain.link\ncontract ChainlinkCalculator is IAmountGetter {\n    using SafeCast for int256;\n\n    error DifferentOracleDecimals();\n    error StaleOraclePrice();\n\n    uint256 private constant _SPREAD_DENOMINATOR = 1e9;\n    uint256 private constant _ORACLE_TTL = 4 hours;\n    bytes1 private constant _INVERSE_FLAG = 0x80;\n    bytes1 private constant _DOUBLE_PRICE_FLAG = 0x40;\n\n    /// @notice Calculates price of token A relative to token B. Note that order is important\n    /// @return result Token A relative price times amount\n    function doublePrice(AggregatorV3Interface oracle1, AggregatorV3Interface oracle2, int256 decimalsScale, uint256 amount) external view returns(uint256 result) {\n        return _doublePrice(oracle1, oracle2, decimalsScale, amount);\n    }\n\n    function getMakingAmount(\n        IOrderMixin.Order calldata /* order */,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        return _getSpreadedAmount(takingAmount, extraData);\n    }\n\n    function getTakingAmount(\n        IOrderMixin.Order calldata /* order */,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        return _getSpreadedAmount(makingAmount, extraData);\n    }\n\n    /// @notice Calculates price of token relative to oracle unit (ETH or USD)\n    /// The first byte of the blob contain inverse and useDoublePrice flags,\n    /// The inverse flag is set when oracle price should be inverted,\n    /// e.g. for DAI-ETH oracle, inverse=false means that we request DAI price in ETH\n    /// and inverse=true means that we request ETH price in DAI\n    /// The useDoublePrice flag is set when needs price for two custom tokens (other than ETH or USD)\n    /// @return Amount * spread * oracle price\n    function _getSpreadedAmount(uint256 amount, bytes calldata blob) internal view returns(uint256) {\n        bytes1 flags = bytes1(blob[:1]);\n        if (flags & _DOUBLE_PRICE_FLAG == _DOUBLE_PRICE_FLAG) {\n            AggregatorV3Interface oracle1 = AggregatorV3Interface(address(bytes20(blob[1:21])));\n            AggregatorV3Interface oracle2 = AggregatorV3Interface(address(bytes20(blob[21:41])));\n            int256 decimalsScale = int256(uint256(bytes32(blob[41:73])));\n            uint256 spread = uint256(bytes32(blob[73:105]));\n            return _doublePrice(oracle1, oracle2, decimalsScale, spread * amount) / _SPREAD_DENOMINATOR;\n        } else {\n            AggregatorV3Interface oracle = AggregatorV3Interface(address(bytes20(blob[1:21])));\n            uint256 spread = uint256(bytes32(blob[21:53]));\n            (, int256 latestAnswer,, uint256 updatedAt,) = oracle.latestRoundData();\n            // solhint-disable-next-line not-rely-on-time\n            if (updatedAt + _ORACLE_TTL < block.timestamp) revert StaleOraclePrice();\n            if (flags & _INVERSE_FLAG == _INVERSE_FLAG) {\n                return spread * amount * (10 ** oracle.decimals()) / latestAnswer.toUint256() / _SPREAD_DENOMINATOR;\n            } else {\n                return spread * amount * latestAnswer.toUint256() / (10 ** oracle.decimals()) / _SPREAD_DENOMINATOR;\n            }\n        }\n    }\n\n    function _doublePrice(AggregatorV3Interface oracle1, AggregatorV3Interface oracle2, int256 decimalsScale, uint256 amount) internal view returns(uint256 result) {\n        if (oracle1.decimals() != oracle2.decimals()) revert DifferentOracleDecimals();\n\n        {\n            (, int256 latestAnswer,, uint256 updatedAt,) = oracle1.latestRoundData();\n            // solhint-disable-next-line not-rely-on-time\n            if (updatedAt + _ORACLE_TTL < block.timestamp) revert StaleOraclePrice();\n            result = amount * latestAnswer.toUint256();\n        }\n\n        if (decimalsScale > 0) {\n            result *= 10 ** decimalsScale.toUint256();\n        } else if (decimalsScale < 0) {\n            result /= 10 ** (-decimalsScale).toUint256();\n        }\n\n        {\n            (, int256 latestAnswer,, uint256 updatedAt,) = oracle2.latestRoundData();\n            // solhint-disable-next-line not-rely-on-time\n            if (updatedAt + _ORACLE_TTL < block.timestamp) revert StaleOraclePrice();\n            result /= latestAnswer.toUint256();\n        }\n    }\n}\n\n// solhint-enable not-rely-on-time\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/DutchAuctionCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IAmountGetter.sol\";\n\n/// @title A helper that implements price decay over time from max to min\n/// @notice The contract implements Dutch auction price calculation for 1inch limit orders, it is used by 1inch Fusion\ncontract DutchAuctionCalculator is IAmountGetter {\n    using Math for uint256;\n\n    uint256 private constant _LOW_128_BITS = 0xffffffffffffffffffffffffffffffff;\n\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        (\n            uint256 startTimeEndTime,\n            uint256 takingAmountStart,\n            uint256 takingAmountEnd\n        ) = abi.decode(extraData, (uint256, uint256, uint256));\n\n        uint256 calculatedTakingAmount = _calculateAuctionTakingAmount(startTimeEndTime, takingAmountStart, takingAmountEnd);\n        return order.makingAmount * takingAmount / calculatedTakingAmount;\n    }\n\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        (\n            uint256 startTimeEndTime,\n            uint256 takingAmountStart,\n            uint256 takingAmountEnd\n        ) = abi.decode(extraData, (uint256, uint256, uint256));\n\n        uint256 calculatedTakingAmount = _calculateAuctionTakingAmount(startTimeEndTime, takingAmountStart, takingAmountEnd);\n        return (calculatedTakingAmount * makingAmount).ceilDiv(order.makingAmount);\n    }\n\n    function _calculateAuctionTakingAmount(uint256 startTimeEndTime, uint256 takingAmountStart, uint256 takingAmountEnd) private view returns(uint256) {\n        uint256 startTime = startTimeEndTime >> 128;\n        uint256 endTime = startTimeEndTime & _LOW_128_BITS;\n        uint256 currentTime = Math.max(startTime, Math.min(endTime, block.timestamp));  // solhint-disable-line not-rely-on-time\n        return (takingAmountStart * (endTime - currentTime) + takingAmountEnd * (currentTime - startTime)) / (endTime - startTime);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ERC1155Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"./ImmutableOwner.sol\";\n\n\n/* solhint-disable func-name-mixedcase */\n\ncontract ERC1155Proxy is ImmutableOwner {\n    error ERC1155ProxyBadSelector();\n\n    constructor(address _immutableOwner) ImmutableOwner(_immutableOwner) {\n        if (ERC1155Proxy.func_301JL5R.selector != IERC20.transferFrom.selector) revert ERC1155ProxyBadSelector();\n    }\n\n    /// @notice Proxy transfer method for `IERC1155.safeTransferFrom`. Selector must match `IERC20.transferFrom`\n    // keccak256(\"func_301JL5R(address,address,uint256,address,uint256,bytes)\") == 0x23b872dd (IERC20.transferFrom)\n    function func_301JL5R(address from, address to, uint256 amount, IERC1155 token, uint256 tokenId, bytes calldata data) external onlyImmutableOwner {\n        token.safeTransferFrom(from, to, tokenId, amount, data);\n    }\n}\n\n/* solhint-enable func-name-mixedcase */\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"./ImmutableOwner.sol\";\n\n\n/* solhint-disable func-name-mixedcase */\n\ncontract ERC721Proxy is ImmutableOwner {\n    error ERC721ProxyBadSelector();\n\n    constructor(address _immutableOwner) ImmutableOwner(_immutableOwner) {\n        if (ERC721Proxy.func_60iHVgK.selector != IERC20.transferFrom.selector) revert ERC721ProxyBadSelector();\n    }\n\n    /// @notice Proxy transfer method for `IERC721.transferFrom`. Selector must match `IERC20.transferFrom`.\n    /// Note that `amount` is unused for security reasons to prevent unintended ERC-721 token sale via partial fill\n    // keccak256(\"func_60iHVgK(address,address,uint256,uint256,address)\") == 0x23b872dd (IERC20.transferFrom)\n    function func_60iHVgK(address from, address to, uint256 /* amount */, uint256 tokenId, IERC721 token) external onlyImmutableOwner {\n        token.transferFrom(from, to, tokenId);\n    }\n}\n\n/* solhint-enable func-name-mixedcase */\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ERC721ProxySafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"./ImmutableOwner.sol\";\n\n\n/* solhint-disable func-name-mixedcase */\n\ncontract ERC721ProxySafe is ImmutableOwner {\n    error ERC721ProxySafeBadSelector();\n\n    constructor(address _immutableOwner) ImmutableOwner(_immutableOwner) {\n        if (ERC721ProxySafe.func_60iHVgK.selector != IERC20.transferFrom.selector) revert ERC721ProxySafeBadSelector();\n    }\n\n    /// @notice Proxy transfer method for `IERC721.transferFrom`. Selector must match `IERC20.transferFrom`.\n    /// Note that `amount` is unused for security reasons to prevent unintended ERC-721 token sale via partial fill\n    // keccak256(\"func_60iHVgK(address,address,uint256,uint256,address)\" == 0x23b872dd (IERC20.transferFrom)\n    function func_60iHVgK(address from, address to, uint256 /* amount */, uint256 tokenId, IERC721 token) external onlyImmutableOwner {\n        token.safeTransferFrom(from, to, tokenId);\n    }\n}\n\n/* solhint-enable func-name-mixedcase */\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ETHOrders.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/mixins/OnlyWethReceiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IPostInteraction.sol\";\nimport \"../OrderLib.sol\";\n\n/// @title Extension that will allow to create limit order that sell ETH. ETH must be deposited into the contract.\ncontract ETHOrders is IPostInteraction, OnlyWethReceiver {\n    using SafeERC20 for IWETH;\n    using OrderLib for IOrderMixin.Order;\n    using MakerTraitsLib for MakerTraits;\n    using ExtensionLib for bytes;\n    using AddressLib for Address;\n\n    error AccessDenied();\n    error InvalidOrder();\n    error NotEnoughBalance();\n    error ExistingOrder();\n    error OrderNotExpired();\n    error RewardIsTooBig();\n    error CancelOrderByResolverIsForbidden();\n\n    /// @notice ETH order struct.\n    struct ETHOrder {\n        address maker;\n        uint96 balance;\n        uint16 maximumPremium;\n        uint32 auctionDuration;\n    }\n\n    uint256 private constant _PREMIUM_BASE = 1e3;\n    uint256 private constant _CANCEL_GAS_LOWER_BOUND = 30000;\n\n    address private immutable _LIMIT_ORDER_PROTOCOL;\n    IWETH private immutable _WETH;\n    IERC20 private immutable _ACCESS_TOKEN;\n\n    mapping(bytes32 orderHash => ETHOrder data) public ordersMakersBalances;\n\n    event ETHDeposited(bytes32 orderHash, uint256 amount);\n    event ETHOrderCancelled(bytes32 orderHash, uint256 amount);\n    event ETHOrderCancelledByThirdParty(bytes32 orderHash, uint256 amount, uint256 reward);\n\n    /// @notice Only limit order protocol can call this contract.\n    modifier onlyLimitOrderProtocol() {\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) revert AccessDenied();\n\n        _;\n    }\n\n    constructor(IWETH weth, address limitOrderProtocol, IERC20 accessToken) OnlyWethReceiver(address(weth)) {\n        _WETH = weth;\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\n        _ACCESS_TOKEN = accessToken;\n        _WETH.approve(limitOrderProtocol, type(uint256).max);\n    }\n\n    /*\n     * @notice Returns batch of eth order for batch of orders hashes.\n     */\n    function ethOrdersBatch(bytes32[] calldata orderHashes) external view returns(ETHOrder[] memory ethOrders) {\n        ethOrders = new ETHOrder[](orderHashes.length);\n        for (uint256 i = 0; i < orderHashes.length; i++) {\n            ethOrders[i] = ordersMakersBalances[orderHashes[i]];\n        }\n    }\n\n    /*\n     * @notice Checks if ETH order is valid, makes ETH deposit for an order, saves real maker and wraps ETH into WETH.\n     */\n    function ethOrderDeposit(\n        IOrderMixin.Order calldata order, \n        bytes calldata extension, \n        uint16 maximumPremium, \n        uint32 auctionDuration\n    ) external payable returns(bytes32 orderHash) {\n        if (!order.makerTraits.needPostInteractionCall()) revert InvalidOrder();\n        {\n            (bool valid, bytes4 validationResult) = order.isValidExtension(extension);\n            if (!valid) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly (\"memory-safe\") {\n                    mstore(0, validationResult)\n                    revert(0, 4)\n                }\n            }\n        }\n        if (order.maker.get() != address(this)) revert AccessDenied();\n        if (order.getReceiver() != msg.sender) revert AccessDenied();\n        if (order.makingAmount != msg.value) revert InvalidOrder();\n        bytes calldata interaction = extension.postInteractionTargetAndData();\n        if (interaction.length != 20 || address(bytes20(interaction)) != address(this)) revert InvalidOrder();\n        orderHash = IOrderMixin(_LIMIT_ORDER_PROTOCOL).hashOrder(order);\n        if (ordersMakersBalances[orderHash].maker != address(0)) revert ExistingOrder();\n        ordersMakersBalances[orderHash] = ETHOrder({\n            maker: msg.sender,\n            balance: uint96(msg.value),\n            maximumPremium: maximumPremium,\n            auctionDuration: auctionDuration\n        });\n        _WETH.safeDeposit(msg.value);\n        emit ETHDeposited(orderHash, msg.value);\n    }\n\n    /**\n     * @notice Sets ordersMakersBalances to 0, refunds ETH and does standard order cancellation on Limit Order Protocol.\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external {\n        if (ordersMakersBalances[orderHash].maker != msg.sender) revert InvalidOrder();\n        IOrderMixin(_LIMIT_ORDER_PROTOCOL).cancelOrder(makerTraits, orderHash);\n        uint256 refundETHAmount = ordersMakersBalances[orderHash].balance;\n        ordersMakersBalances[orderHash].balance = 0;\n        _WETH.safeWithdrawTo(refundETHAmount, msg.sender);\n        emit ETHOrderCancelled(orderHash, refundETHAmount);\n    }\n\n    /**\n     * @notice Allows third-party to cancel an expired order and receive a reward.\n     * @param makerTraits The traits of the maker\n     * @param orderHash Hash of the order to cancel\n     */\n    function cancelOrderByResolver(MakerTraits makerTraits, bytes32 orderHash) external {\n        unchecked {\n            if (_ACCESS_TOKEN.balanceOf(msg.sender) == 0) revert AccessDenied();\n            if (!makerTraits.isExpired()) revert OrderNotExpired();\n            ETHOrder memory ethOrder = ordersMakersBalances[orderHash];\n            if (ethOrder.maker == address(0)) revert InvalidOrder();\n            if (ethOrder.maximumPremium == 0) revert CancelOrderByResolverIsForbidden();\n            IOrderMixin(_LIMIT_ORDER_PROTOCOL).cancelOrder(makerTraits, orderHash);\n            uint256 reward = _CANCEL_GAS_LOWER_BOUND * block.basefee * (_PREMIUM_BASE + _getCurrentPremiumMultiplier(ethOrder, makerTraits.getExpirationTime())) / _PREMIUM_BASE;\n            if (reward > ethOrder.balance) revert RewardIsTooBig();\n            uint256 refundETHAmount = ethOrder.balance - reward;\n            ordersMakersBalances[orderHash].balance = 0;\n            if (reward > 0) {\n                _WETH.safeWithdrawTo(reward, msg.sender);\n            }\n            if (refundETHAmount > 0) {\n                _WETH.safeWithdrawTo(refundETHAmount, ethOrder.maker);\n            }\n            emit ETHOrderCancelledByThirdParty(orderHash, ethOrder.balance, reward);\n        }\n    }\n\n    /**\n     * @notice Checks if orderHash signature was signed with real order maker.\n     */\n    function isValidSignature(bytes32 orderHash, bytes calldata signature) external view returns(bytes4) {\n        if (ECDSA.recoverOrIsValidSignature(ordersMakersBalances[orderHash].maker, orderHash, signature)) {\n            return IERC1271.isValidSignature.selector;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    /**\n     * @notice Callback method that gets called after all funds transfers.\n     * Updates _ordersMakersBalances by makingAmount for order with orderHash.\n     * @param orderHash Hash of the order being processed\n     * @param makingAmount Actual making amount\n     */\n    function postInteraction(\n        IOrderMixin.Order calldata /*order*/,\n        bytes calldata /* extension */,\n        bytes32 orderHash,\n        address /*taker*/,\n        uint256 makingAmount,\n        uint256 /*takingAmount*/,\n        uint256 /*remainingMakingAmount*/,\n        bytes calldata /*extraData*/\n    ) external onlyLimitOrderProtocol {\n        if (ordersMakersBalances[orderHash].balance < makingAmount) revert NotEnoughBalance();\n        unchecked {\n            ordersMakersBalances[orderHash].balance -= uint96(makingAmount);\n        }\n    }\n\n    /**\n     * @notice Calculates the current premium multiplier based on time since expiration.\n     * @param order The ETH order\n     * @param expirationTime The expiration time of the order\n     * @return The current premium multiplier (scaled by 1e3)\n     */\n    function _getCurrentPremiumMultiplier(ETHOrder memory order, uint256 expirationTime) private view returns (uint256) {\n        unchecked {\n            if (block.timestamp <= expirationTime) {\n                return 0;\n            }\n            uint256 timeElapsed = block.timestamp - expirationTime;\n            if (timeElapsed >= order.auctionDuration) {\n                return order.maximumPremium;\n            }\n            return (timeElapsed * order.maximumPremium) / order.auctionDuration;\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/FeeTaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Address, AddressLib } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport { SafeERC20 } from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport { UniERC20 } from \"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\nimport { IPostInteraction } from \"../interfaces/IPostInteraction.sol\";\nimport { MakerTraits, MakerTraitsLib } from \"../libraries/MakerTraitsLib.sol\";\nimport { AmountGetterWithFee } from \"./AmountGetterWithFee.sol\";\n\n/// @title Helper contract that adds feature of collecting fee in takerAsset\ncontract FeeTaker is IPostInteraction, AmountGetterWithFee, Ownable {\n    using AddressLib for Address;\n    using SafeERC20 for IERC20;\n    using UniERC20 for IERC20;\n    using Math for uint256;\n    using MakerTraitsLib for MakerTraits;\n\n    bytes1 private constant _CUSTOM_RECEIVER_FLAG = 0x01;\n\n    /**\n     * @dev The caller is not the limit order protocol contract.\n     */\n    error OnlyLimitOrderProtocol();\n\n    /**\n     * @dev The taker is not whitelisted and does not have access token.\n     */\n    error OnlyWhitelistOrAccessToken();\n\n    /**\n     * @dev Eth transfer failed. The target fallback may have reverted.\n     */\n    error EthTransferFailed();\n\n    /**\n      * @dev Fees are specified but FeeTaker is not set as a receiver.\n      */\n    error InconsistentFee();\n\n    address private immutable _LIMIT_ORDER_PROTOCOL;\n    address private immutable _WETH;\n    /// @notice Contract address whose tokens allow filling limit orders with a fee for resolvers that are outside the whitelist\n    IERC20 private immutable _ACCESS_TOKEN;\n\n    /// @dev Modifier to check if the caller is the limit order protocol contract.\n    modifier onlyLimitOrderProtocol {\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) revert OnlyLimitOrderProtocol();\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @param limitOrderProtocol The limit order protocol contract.\n     * @param accessToken Contract address whose tokens allow filling limit orders with a fee for resolvers that are outside the whitelist.\n     * @param weth The WETH address.\n     * @param owner The owner of the contract.\n     */\n    constructor(address limitOrderProtocol, IERC20 accessToken, address weth, address owner) Ownable(owner) {\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\n        _WETH = weth;\n        _ACCESS_TOKEN = accessToken;\n    }\n\n    /**\n     * @notice Fallback function to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice See {IPostInteraction-postInteraction}.\n     */\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external onlyLimitOrderProtocol {\n        _postInteraction(order, extension, orderHash, taker, makingAmount, takingAmount, remainingMakingAmount, extraData);\n    }\n\n    /**\n     * @notice Retrieves funds accidentally sent directly to the contract address\n     * @param token ERC20 token to retrieve\n     * @param amount amount to retrieve\n     */\n    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {\n        token.uniTransfer(payable(msg.sender), amount);\n    }\n\n    /**\n     * @notice See {IPostInteraction-postInteraction}.\n     * @dev Takes the fee in taking tokens and transfers the rest to the maker.\n     * `extraData` consists of:\n     * 1 byte - flags\n     * 20 bytes — integrator fee recipient\n     * 20 bytes - protocol fee recipient\n     * 20 bytes — receiver of taking tokens (optional, if not set, maker is used)\n     * bytes - fees structure determined by `_getFeeAmounts` implementation\n     * bytes — custom data to call extra postInteraction (optional)\n     */\n    function _postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal virtual {\n        unchecked {\n            bool customReceiver = extraData[0] & _CUSTOM_RECEIVER_FLAG == _CUSTOM_RECEIVER_FLAG;\n            address integratorFeeRecipient = address(bytes20(extraData[1:21]));\n            address protocolFeeRecipient = address(bytes20(extraData[21:41]));\n            extraData = extraData[41:];\n\n            address receiver = order.maker.get();\n            if (customReceiver) {\n                receiver = address(bytes20(extraData));\n                extraData = extraData[20:];\n            }\n\n            (uint256 integratorFeeAmount, uint256 protocolFeeAmount, bytes calldata tail) = _getFeeAmounts(order, taker, takingAmount, makingAmount, extraData);\n\n            if (order.receiver.get() == address(this)) {\n                if (order.takerAsset.get() == address(_WETH) && order.makerTraits.unwrapWeth()) {\n                    if (integratorFeeAmount > 0) {\n                        _sendEth(integratorFeeRecipient, integratorFeeAmount);\n                    }\n                    if (protocolFeeAmount > 0) {\n                        _sendEth(protocolFeeRecipient, protocolFeeAmount);\n                    }\n                    _sendEth(receiver, takingAmount - integratorFeeAmount - protocolFeeAmount);\n                } else {\n                    if (integratorFeeAmount > 0) {\n                        IERC20(order.takerAsset.get()).safeTransfer(integratorFeeRecipient, integratorFeeAmount);\n                    }\n                    if (protocolFeeAmount > 0) {\n                        IERC20(order.takerAsset.get()).safeTransfer(protocolFeeRecipient, protocolFeeAmount);\n                    }\n                    IERC20(order.takerAsset.get()).safeTransfer(receiver, takingAmount - integratorFeeAmount - protocolFeeAmount);\n                }\n            } else if (integratorFeeAmount + protocolFeeAmount > 0) {\n                revert InconsistentFee();\n            }\n\n            if (tail.length > 19) {\n                IPostInteraction(address(bytes20(tail))).postInteraction(order, extension, orderHash, taker, makingAmount, takingAmount, remainingMakingAmount, tail[20:]);\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates fee amounts depending on whether the taker is in the whitelist and whether they have an _ACCESS_TOKEN.\n     * `extraData` consists of:\n     * 2 bytes — integrator fee percentage (in 1e5)\n     * 1 bytes - integrator rev share percentage (in 1e2)\n     * 2 bytes — resolver fee percentage (in 1e5)\n     * bytes — whitelist structure determined by `_isWhitelistedPostInteractionImpl` implementation\n     * Override this function if the calculation of integratorFee and protocolFee differs from the existing logic and requires a different parsing of extraData.\n     */\n    function _getFeeAmounts(IOrderMixin.Order calldata /* order */, address taker, uint256 takingAmount, uint256 /* makingAmount */, bytes calldata extraData) internal virtual returns (uint256 integratorFeeAmount, uint256 protocolFeeAmount, bytes calldata tail) {\n        (bool isWhitelisted, uint256 integratorFee, uint256 integratorShare, uint256 resolverFee, bytes calldata parsedTail) = _parseFeeData(extraData, taker, _isWhitelistedPostInteractionImpl);\n        tail = parsedTail;\n        if (!isWhitelisted && _ACCESS_TOKEN.balanceOf(taker) == 0) revert OnlyWhitelistOrAccessToken();\n\n        uint256 denominator = _BASE_1E5 + integratorFee + resolverFee;\n        uint256 integratorFeeTotal = takingAmount.mulDiv(integratorFee, denominator);\n        integratorFeeAmount = integratorFeeTotal.mulDiv(integratorShare, _BASE_1E2);\n        protocolFeeAmount = takingAmount.mulDiv(resolverFee, denominator) + integratorFeeTotal - integratorFeeAmount;\n    }\n\n    /**\n     * @dev Parses fee data from `extraData`.\n     * Override this function if whitelist structure in postInteraction is different from getters.\n     */\n    function _isWhitelistedPostInteractionImpl(bytes calldata whitelistData, address taker) internal view virtual returns (bool isWhitelisted, bytes calldata tail) {\n        return _isWhitelistedGetterImpl(whitelistData, taker);\n    }\n\n    function _sendEth(address target, uint256 amount) private {\n        (bool success, ) = target.call{value: amount}(\"\");\n        if (!success) {\n            revert EthTransferFailed();\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/ImmutableOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title A helper contract with helper modifiers to allow access to original contract creator only\ncontract ImmutableOwner {\n    error IOAccessDenied();\n\n    address public immutable IMMUTABLE_OWNER;\n\n    modifier onlyImmutableOwner {\n        if (msg.sender != IMMUTABLE_OWNER) revert IOAccessDenied();\n        _;\n    }\n\n    constructor(address _immutableOwner) {\n        IMMUTABLE_OWNER = _immutableOwner;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/OrderIdInvalidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"../interfaces/IPreInteraction.sol\";\n\n/**\n * @notice OrderIdInvalidator stores pairs (orderId, orderHash)\n * that allows to execute only one order with the same orderId\n */\ncontract OrderIdInvalidator is IPreInteraction {\n    using AddressLib for Address;\n\n    error AccessDenied();\n    error InvalidOrderHash();\n\n    /// @notice Limit order protocol address.\n    address private immutable _LIMIT_ORDER_PROTOCOL;\n    /// @notice Stores corresponding maker orders ids and hashes.\n    mapping(address maker => mapping(uint32 orderId => bytes32 orderHash)) private _ordersIdsHashes;\n\n    /// @notice Only limit order protocol can call this contract.\n    modifier onlyLimitOrderProtocol() {\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) {\n            revert AccessDenied();\n        }\n        _;\n    }\n\n    constructor(address limitOrderProtocol_) {\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol_;\n    }\n\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 orderHash,\n        address /* taker */,\n        uint256 /* makingAmount */,\n        uint256 /* takingAmount */,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external onlyLimitOrderProtocol {\n        uint32 orderId = uint32(bytes4(extraData));\n        bytes32 storedOrderHash = _ordersIdsHashes[order.maker.get()][orderId];\n        if (storedOrderHash == 0x0) {\n            _ordersIdsHashes[order.maker.get()][orderId] = orderHash;\n        } else if (storedOrderHash != orderHash) {\n            revert InvalidOrderHash();\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/Permit2WitnessProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IPermit2WitnessTransferFrom.sol\";\nimport \"./ImmutableOwner.sol\";\n\n/* solhint-disable func-name-mixedcase */\n\ncontract Permit2WitnessProxy is ImmutableOwner {\n    error Permit2WitnessProxyBadSelector();\n\n    struct Witness {\n        bytes32 salt;\n    }\n\n    string private constant _WITNESS_TYPE_STRING =\n\t\t\"Witness witness)TokenPermissions(address token,uint256 amount)Witness(bytes32 salt)\";\n\n    IPermit2WitnessTransferFrom private constant _PERMIT2 = IPermit2WitnessTransferFrom(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    constructor(address _immutableOwner) ImmutableOwner(_immutableOwner) {\n        if (Permit2WitnessProxy.func_801zDya.selector != IERC20.transferFrom.selector) revert Permit2WitnessProxyBadSelector();\n    }\n\n    /// @notice Proxy transfer method for `Permit2.permitWitnessTransferFrom`. Selector must match `IERC20.transferFrom`\n    // keccak256(\"func_801zDya(address,address,uint256,address,uint256,uint256,uint256,bytes32,bytes)\") == 0x23b872dd (IERC20.transferFrom)\n    function func_801zDya(\n        address from,\n        address to,\n        uint256 amount,\n        IPermit2WitnessTransferFrom.PermitTransferFrom calldata permit,\n        bytes32 witness,\n        bytes calldata sig\n    ) external onlyImmutableOwner {\n        _PERMIT2.permitWitnessTransferFrom(\n            permit,\n            IPermit2WitnessTransferFrom.SignatureTransferDetails({\n                to: to,\n                requestedAmount: amount\n            }),\n            from,\n            witness,\n            _WITNESS_TYPE_STRING,\n            sig\n        );\n    }\n}\n\n/* solhint-enable func-name-mixedcase */\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/PrioirityFeeLimiter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title A helper contract for executing boolean functions on arbitrary target call results\ncontract PriorityFeeLimiter {\n    /// @notice Validates priority fee according to the spec\n    /// https://snapshot.org/#/1inch.eth/proposal/0xa040c60050147a0f67042ae024673e92e813b5d2c0f748abf70ddfa1ed107cbe\n    /// For blocks with baseFee <10.6 gwei – the priorityFee is capped at 70% of the baseFee.\n    /// For blocks with baseFee between 10.6 gwei and 104.1 gwei – the priorityFee is capped at 50% of the baseFee.\n    /// For blocks with baseFee >104.1 gwei – priorityFee is capped at 65% of the block’s baseFee.\n    function isPriorityFeeValid() public view returns(bool) {\n        unchecked {\n            uint256 baseFee = block.basefee;\n            uint256 priorityFee = tx.gasprice - baseFee;\n\n            if (baseFee < 10.6 gwei) {\n                return priorityFee * 100 <= baseFee * 70;\n            } else if (baseFee < 104.1 gwei) {\n                return priorityFee * 2 <= baseFee;\n            } else {\n                return priorityFee * 100 <= baseFee * 65;\n            }\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/extensions/RangeAmountCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IOrderMixin.sol\";\nimport \"../interfaces/IAmountGetter.sol\";\n\n/**\n * A range limit order is a strategy used to sell an asset within a specified price range.\n * For instance, suppose you anticipate the value of ETH to increase in the next week from its\n * current worth of 3000 DAI to a minimum of 4000 DAI.\n * In that case, you can create an ETH -> DAI limit order within the price range of 3000 -> 4000.\n * For example, you could create an order to sell 10 ETH within that price range.\n *\n * When someone places a bid for the entire limit order, they may purchase it all at once at\n * an average price of 3500 DAI. Alternatively, the limit order may be executed in portions.\n * For instance, the buyer might purchase 1 ETH for 3050 DAI, then another 1 ETH for 3150 DAI, and so on.\n *\n * Function of the changing price of makerAsset tokens in takerAsset tokens by the filling amount of makerAsset tokens in order:\n *      priceEnd - priceStart\n * y = ----------------------- * x + priceStart\n *           totalAmount\n */\ncontract RangeAmountCalculator is IAmountGetter {\n    error IncorrectRange();\n\n    modifier correctPrices(uint256 priceStart, uint256 priceEnd) {\n        if (priceEnd <= priceStart) revert IncorrectRange();\n        _;\n    }\n\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external pure returns (uint256) {\n        (\n            uint256 priceStart,\n            uint256 priceEnd\n        ) = abi.decode(extraData, (uint256, uint256));\n        return getRangeTakerAmount(priceStart, priceEnd, order.makingAmount, makingAmount, remainingMakingAmount);\n    }\n\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external pure returns (uint256) {\n        (\n            uint256 priceStart,\n            uint256 priceEnd\n        ) = abi.decode(extraData, (uint256, uint256));\n        return getRangeMakerAmount(priceStart, priceEnd, order.makingAmount, takingAmount, remainingMakingAmount);\n    }\n\n    function getRangeTakerAmount(\n        uint256 priceStart,\n        uint256 priceEnd,\n        uint256 orderMakingAmount,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount\n    ) public correctPrices(priceStart, priceEnd) pure returns(uint256) {\n        uint256 alreadyFilledMakingAmount = orderMakingAmount - remainingMakingAmount;\n        /**\n         * rangeTakerAmount = (\n         *       f(makerAmountFilled) + f(makerAmountFilled + fillAmount)\n         *   ) * fillAmount / 2 / 1e18\n         *\n         *  scaling to 1e18 happens to have better price accuracy\n         */\n        return (\n            (priceEnd - priceStart) * (2 * alreadyFilledMakingAmount + makingAmount) / orderMakingAmount +\n            2 * priceStart\n        ) * makingAmount / 2e18;\n    }\n\n    function getRangeMakerAmount(\n        uint256 priceStart,\n        uint256 priceEnd,\n        uint256 orderMakingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount\n    ) public correctPrices(priceStart, priceEnd) pure returns(uint256) {\n        uint256 alreadyFilledMakingAmount = orderMakingAmount - remainingMakingAmount;\n        uint256 b = priceStart;\n        uint256 k = (priceEnd - priceStart) * 1e18 / orderMakingAmount;\n        uint256 bDivK = priceStart * orderMakingAmount / (priceEnd - priceStart);\n        return (Math.sqrt(\n            (\n                b * bDivK +\n                alreadyFilledMakingAmount * (2 * b + k * alreadyFilledMakingAmount / 1e18) +\n                2 * takingAmount * 1e18\n            ) / k * 1e18\n        ) - bDivK) - alreadyFilledMakingAmount;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/helpers/OrderRegistrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Address, AddressLib } from \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport { ECDSA } from \"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\";\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\nimport { IOrderRegistrator } from \"../interfaces/IOrderRegistrator.sol\";\nimport { OrderLib } from \"../OrderLib.sol\";\n\n/**\n * @title OrderRegistrator\n */\ncontract OrderRegistrator is IOrderRegistrator {\n    using AddressLib for Address;\n    using OrderLib for IOrderMixin.Order;\n\n    IOrderMixin private immutable _LIMIT_ORDER_PROTOCOL;\n\n    constructor(IOrderMixin limitOrderProtocol) {\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\n    }\n\n    /**\n     * @notice See {IOrderRegistrator-registerOrder}.\n     */\n    function registerOrder(IOrderMixin.Order calldata order, bytes calldata extension, bytes calldata signature) external {\n        // Validate order\n        {\n            (bool valid, bytes4 validationResult) = order.isValidExtension(extension);\n            if (!valid) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly (\"memory-safe\") {\n                    mstore(0, validationResult)\n                    revert(0, 4)\n                }\n            }\n        }\n\n        // Validate signature\n        if(!ECDSA.recoverOrIsValidSignature(order.maker.get(), _LIMIT_ORDER_PROTOCOL.hashOrder(order), signature)) revert IOrderMixin.BadSignature();\n\n        emit OrderRegistered(order, extension, signature);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/helpers/PredicateHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title A helper contract for executing boolean functions on arbitrary target call results\ncontract PredicateHelper {\n    error ArbitraryStaticCallFailed();\n\n    /// @notice Calls every target with corresponding data\n    /// @return Result True if call to any target returned True. Otherwise, false\n    function or(uint256 offsets, bytes calldata data) public view returns(bool) {\n        uint256 previous;\n        for (uint256 current; (current = uint32(offsets)) != 0; offsets >>= 32) {\n            (bool success, uint256 res) = _staticcallForUint(address(this), data[previous:current]);\n            if (success && res == 1) {\n                return true;\n            }\n            previous = current;\n        }\n        return false;\n    }\n\n    /// @notice Calls every target with corresponding data\n    /// @return Result True if calls to all targets returned True. Otherwise, false\n    function and(uint256 offsets, bytes calldata data) public view returns(bool) {\n        uint256 previous;\n        for (uint256 current; (current = uint32(offsets)) != 0; offsets >>= 32) {\n            (bool success, uint256 res) = _staticcallForUint(address(this), data[previous:current]);\n            if (!success || res != 1) {\n                return false;\n            }\n            previous = current;\n        }\n        return true;\n    }\n\n    /// @notice Calls target with specified data and tests if it's equal to 0\n    /// @return Result True if call to target returns 0. Otherwise, false\n    function not(bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res == 0;\n    }\n\n    /// @notice Calls target with specified data and tests if it's equal to the value\n    /// @param value Value to test\n    /// @return Result True if call to target returns the same value as `value`. Otherwise, false\n    function eq(uint256 value, bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res == value;\n    }\n\n    /// @notice Calls target with specified data and tests if it's lower than value\n    /// @param value Value to test\n    /// @return Result True if call to target returns value which is lower than `value`. Otherwise, false\n    function lt(uint256 value, bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res < value;\n    }\n\n    /// @notice Calls target with specified data and tests if it's bigger than value\n    /// @param value Value to test\n    /// @return Result True if call to target returns value which is bigger than `value`. Otherwise, false\n    function gt(uint256 value, bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res > value;\n    }\n\n    /// @notice Performs an arbitrary call to target with data\n    /// @return Result Bytes transmuted to uint256\n    function arbitraryStaticCall(address target, bytes calldata data) public view returns(uint256) {\n        (bool success, uint256 res) = _staticcallForUint(target, data);\n        if (!success) revert ArbitraryStaticCallFailed();\n        return res;\n    }\n\n    function _staticcallForUint(address target, bytes calldata data) internal view returns(bool success, uint256 res) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, data.offset, data.length)\n            success := staticcall(gas(), target, ptr, data.length, 0x0, 0x20)\n            success := and(success, eq(returndatasize(), 32))\n            if success {\n                res := mload(0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/helpers/SafeOrderBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { GnosisSafeStorage } from \"@gnosis.pm/safe-contracts/contracts/examples/libraries/GnosisSafeStorage.sol\";\nimport { GnosisSafe } from \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\nimport { IOrderRegistrator } from \"../interfaces/IOrderRegistrator.sol\";\n\n/**\n * @title SafeOrderBuilder\n * @dev The contract is responsible for building and signing limit orders for the GnosisSafe.\n * The contract uses oracles to adjust the order taking amount based on the volatility of the maker and taker assets.\n */\ncontract SafeOrderBuilder is GnosisSafeStorage {\n    using Math for uint256;\n\n    error StaleOraclePrice();\n\n    bytes32 private constant _SAFE_MSG_TYPEHASH = keccak256(\"SafeMessage(bytes message)\");\n\n    IOrderMixin private immutable _LIMIT_ORDER_PROTOCOL;\n    IOrderRegistrator private immutable _ORDER_REGISTRATOR;\n\n    constructor(IOrderMixin limitOrderProtocol, IOrderRegistrator orderRegistrator) {\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\n        _ORDER_REGISTRATOR = orderRegistrator;\n    }\n\n    struct OracleQueryParams {\n        AggregatorV3Interface oracle;\n        uint256 originalAnswer;\n        uint256 ttl;\n    }\n\n    /**\n     * @notice Builds and signs a limit order for the GnosisSafe.\n     * The order is signed by the GnosisSafe and registered in the order registrator.\n     * The order taking amount is adjusted based on the volatility of the maker and taker assets.\n     * @param order The order to be built and signed.\n     * @param extension The extension data associated with the order.\n     * @param makerAssetOracleParams The oracle query parameters for the maker asset.\n     * @param takerAssetOracleParams The oracle query parameters for the taker asset.\n     */\n    function buildAndSignOrder(\n        IOrderMixin.Order memory order,\n        bytes calldata extension,\n        OracleQueryParams calldata makerAssetOracleParams,\n        OracleQueryParams calldata takerAssetOracleParams\n    ) external {\n        {\n            // account for makerAsset volatility\n            (, int256 latestAnswer,, uint256 updatedAt,) = makerAssetOracleParams.oracle.latestRoundData();\n            // solhint-disable-next-line not-rely-on-time\n            if (updatedAt + makerAssetOracleParams.ttl < block.timestamp) revert StaleOraclePrice();\n            order.takingAmount = order.takingAmount.mulDiv(uint256(latestAnswer), makerAssetOracleParams.originalAnswer);\n        }\n\n        {\n            // account for takerAsset volatility\n            (, int256 latestAnswer,, uint256 updatedAt,) = takerAssetOracleParams.oracle.latestRoundData();\n            // solhint-disable-next-line not-rely-on-time\n            if (updatedAt + takerAssetOracleParams.ttl < block.timestamp) revert StaleOraclePrice();\n            order.takingAmount = order.takingAmount.mulDiv(takerAssetOracleParams.originalAnswer, uint256(latestAnswer));\n        }\n\n        bytes32 msgHash = _getMessageHash(abi.encode(_LIMIT_ORDER_PROTOCOL.hashOrder(order)));\n        signedMessages[msgHash] = 1;\n\n        _ORDER_REGISTRATOR.registerOrder(order, extension, \"\");\n    }\n\n\n    /**\n     * @dev Returns hash of a message that can be signed by owners.\n     * @param message Message that should be hashed.\n     * @return bytes32 hash of the message.\n     */\n    function _getMessageHash(bytes memory message) private view returns (bytes32) {\n        bytes32 safeMessageHash = keccak256(abi.encode(_SAFE_MSG_TYPEHASH, keccak256(message)));\n        return keccak256(abi.encodePacked(bytes1(0x19), bytes1(0x01), GnosisSafe(payable(address(this))).domainSeparator(), safeMessageHash));\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/helpers/SeriesEpochManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title A helper contract to manage nonce with the series\ncontract SeriesEpochManager {\n    error AdvanceEpochFailed();\n    event EpochIncreased(address indexed maker, uint256 series, uint256 newEpoch);\n\n    // {\n    //    1: {\n    //        '0x762f73Ad...842Ffa8': 0,\n    //        '0xd20c41ee...32aaDe2': 1\n    //    },\n    //    2: {\n    //        '0x762f73Ad...842Ffa8': 3,\n    //        '0xd20c41ee...32aaDe2': 15\n    //    },\n    //    ...\n    // }\n    mapping(uint256 seriesId => uint256 epoch) private _epochs;\n\n    /// @notice Returns nonce for `maker` and `series`\n    function epoch(address maker, uint96 series) public view returns(uint256) {\n        return _epochs[uint160(maker) | (uint256(series) << 160)];\n    }\n\n    /// @notice Advances nonce by one\n    function increaseEpoch(uint96 series) external {\n        advanceEpoch(series, 1);\n    }\n\n    /// @notice Advances nonce by specified amount\n    function advanceEpoch(uint96 series, uint256 amount) public {\n        if (amount == 0 || amount > 255) revert AdvanceEpochFailed();\n        unchecked {\n            uint256 key = uint160(msg.sender) | (uint256(series) << 160);\n            uint256 newEpoch = _epochs[key] + amount;\n            _epochs[key] = newEpoch;\n            emit EpochIncreased(msg.sender, series, newEpoch);\n        }\n    }\n\n    /// @notice Checks if `maker` has specified `makerEpoch` for `series`\n    /// @return Result True if `maker` has specified epoch. Otherwise, false\n    function epochEquals(address maker, uint256 series, uint256 makerEpoch) public view returns(bool) {\n        return _epochs[uint160(maker) | (uint256(series) << 160)] == makerEpoch;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/helpers/SeriesNonceManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title A helper contract to manage nonce with the series\ncontract SeriesNonceManager {\n    error AdvanceNonceFailed();\n    event NonceIncreased(address indexed maker, uint256 series, uint256 newNonce);\n\n    // {\n    //    1: {\n    //        '0x762f73Ad...842Ffa8': 0,\n    //        '0xd20c41ee...32aaDe2': 1\n    //    },\n    //    2: {\n    //        '0x762f73Ad...842Ffa8': 3,\n    //        '0xd20c41ee...32aaDe2': 15\n    //    },\n    //    ...\n    // }\n    mapping(uint256 series => mapping(address maker => uint256 nonce)) public nonce;\n\n    /// @notice Advances nonce by one\n    function increaseNonce(uint8 series) external {\n        advanceNonce(series, 1);\n    }\n\n    /// @notice Advances nonce by specified amount\n    function advanceNonce(uint256 series, uint256 amount) public {\n        if (amount == 0 || amount > 255) revert AdvanceNonceFailed();\n        unchecked {\n            uint256 newNonce = nonce[series][msg.sender] + amount;\n            nonce[series][msg.sender] = newNonce;\n            emit NonceIncreased(msg.sender, series, newNonce);\n        }\n    }\n\n    /// @notice Checks if `makerAddress` has specified `makerNonce` for `series`\n    /// @return Result True if `makerAddress` has specified nonce. Otherwise, false\n    function nonceEquals(uint256 series, address makerAddress, uint256 makerNonce) public view returns(bool) {\n        return nonce[series][makerAddress] == makerNonce;\n    }\n\n    /// @notice Checks passed time against block timestamp\n    /// @return Result True if current block timestamp is lower than `time`. Otherwise, false\n    function timestampBelow(uint256 time) public view returns(bool) {\n        return block.timestamp < time;  // solhint-disable-line not-rely-on-time\n    }\n\n    function timestampBelowAndNonceEquals(uint256 timeNonceSeriesAccount) public view returns(bool) {\n        uint256 _time = uint40(timeNonceSeriesAccount >> 216);\n        uint256 _nonce = uint40(timeNonceSeriesAccount >> 176);\n        uint256 _series = uint16(timeNonceSeriesAccount >> 160);\n        address _account = address(uint160(timeNonceSeriesAccount));\n        return timestampBelow(_time) && nonceEquals(_series, _account, _nonce);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/IAmountGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\n/**\n * @title IAmountGetter\n * @notice Interface for external logic to determine actual making and taking amounts for orders.\n */\ninterface IAmountGetter {\n    /**\n     * @notice View method that gets called to determine the actual making amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     * @return makingAmount Actual making amount that should be used for the order\n     */\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n\n    /**\n     * @notice View method that gets called to determine the actual taking amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     * @return takingAmount Actual taking amount that should be used for the order\n     */\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/ICreate3Deployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\ninterface ICreate3Deployer {\n    function deploy(bytes32 salt, bytes calldata code) external returns (address);\n    function addressOf(bytes32 salt) external view returns (address);\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/IOrderMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\nimport \"../libraries/MakerTraitsLib.sol\";\nimport \"../libraries/TakerTraitsLib.sol\";\n\n/**\n * @title IOrderMixin\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\n */\ninterface IOrderMixin {\n    struct Order {\n        uint256 salt;\n        Address maker;\n        Address receiver;\n        Address makerAsset;\n        Address takerAsset;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        MakerTraits makerTraits;\n    }\n\n    error InvalidatedOrder();\n    error TakingAmountExceeded();\n    error PrivateOrder();\n    error BadSignature();\n    error OrderExpired();\n    error WrongSeriesNonce();\n    error SwapWithZeroAmount();\n    error PartialFillNotAllowed();\n    error OrderIsNotSuitableForMassInvalidation();\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\n    error ReentrancyDetected();\n    error PredicateIsNotTrue();\n    error TakingAmountTooHigh();\n    error MakingAmountTooLow();\n    error TransferFromMakerToTakerFailed();\n    error TransferFromTakerToMakerFailed();\n    error MismatchArraysLengths();\n    error InvalidPermit2Transfer();\n    error SimulationResults(bool success, bytes res);\n\n    /**\n     * @notice Emitted when order gets filled\n     * @param orderHash Hash of the order\n     * @param remainingAmount Amount of the maker asset that remains to be filled\n     */\n    event OrderFilled(\n        bytes32 orderHash,\n        uint256 remainingAmount\n    );\n\n    /**\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\n     * @param orderHash Hash of the order\n     */\n    event OrderCancelled(\n        bytes32 orderHash\n    );\n\n    /**\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\n     * @param maker Maker address\n     * @param slotIndex Slot index that was updated\n     * @param slotValue New slot value\n     */\n    event BitInvalidatorUpdated(\n        address indexed maker,\n        uint256 slotIndex,\n        uint256 slotValue\n    );\n\n    /**\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\n     * @dev The function always reverts and returns the simulation results in revert data.\n     * @param target Addresses that will be delegated\n     * @param data Data that will be passed to delegatee\n     */\n    function simulate(address target, bytes calldata data) external;\n\n    /**\n     * @notice Cancels order's quote\n     * @param makerTraits Order makerTraits\n     * @param orderHash Hash of the order to cancel\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\n\n    /**\n     * @notice Cancels orders' quotes\n     * @param makerTraits Orders makerTraits\n     * @param orderHashes Hashes of the orders to cancel\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\n\n    /**\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\n     * @param makerTraits Order makerTraits\n     * @param additionalMask Additional bitmask to invalidate orders\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\n\n    /**\n     * @notice Fills order's quote, fully or partially (whichever is possible).\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrder(\n        Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but uses contract-based signatures.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrder(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param maker Maker address\n     * @param slot Slot number to return bitmask for\n     * @return result Each bit represents whether corresponding was already invalidated\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remaining Remaining amount of the order\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\n\n    /**\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\n     * @param order Order\n     * @return orderHash Hash of the order\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/IOrderRegistrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IOrderMixin } from \"./IOrderMixin.sol\";\n\n/**\n * @title IOrderRegistrator\n * @dev The interface defines the structure of the order registrator contract.\n * The registrator is responsible for registering orders and emitting an event when an order is registered.\n */\ninterface IOrderRegistrator {\n    /**\n     * @notice Emitted when an order is registered.\n     * @param order The order that was registered.\n     * @param extension The extension data associated with the order.\n     * @param signature The signature of the order.\n     */\n    event OrderRegistered(IOrderMixin.Order order, bytes extension, bytes signature);\n\n    /**\n     * @notice Registers an order.\n     * @param order The order to be registered.\n     * @param extension The extension data associated with the order.\n     * @param signature The signature of the order.\n     */\n    function registerOrder(IOrderMixin.Order calldata order, bytes calldata extension, bytes calldata signature) external;\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/IPermit2WitnessTransferFrom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPermit2WitnessTransferFrom {\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    function permitWitnessTransferFrom(\n        PermitTransferFrom calldata permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/IPostInteraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\ninterface IPostInteraction {\n    /**\n     * @notice Callback method that gets called after all fund transfers\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/IPreInteraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\ninterface IPreInteraction {\n    /**\n     * @notice Callback method that gets called before any funds transfers\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "contracts/1inch/limit-order-protocol/interfaces/ITakerInteraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOrderMixin.sol\";\n\n/**\n * @title Interface for interactor which acts after `maker -> taker` transfer but before `taker -> maker` transfer.\n * @notice The order filling steps are `preInteraction` =>` Transfer \"maker -> taker\"` => **`Interaction`** => `Transfer \"taker -> maker\"` => `postInteraction`\n */\ninterface ITakerInteraction {\n    /**\n     * @dev This callback allows to interactively handle maker aseets to produce takers assets, doesn't supports ETH as taker assets\n     * @notice Callback method that gets called after maker fund transfer but before taker fund transfer\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function takerInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/AmountCalculatorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title The helper library to calculate linearly taker amount from maker amount and vice versa.\nlibrary AmountCalculatorLib {\n    /// @notice Calculates maker amount\n    /// @return Result Floored maker amount\n    function getMakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapTakerAmount) internal pure returns(uint256) {\n        if ((swapTakerAmount | orderMakerAmount) >> 128 == 0) {\n            unchecked {\n                return (swapTakerAmount * orderMakerAmount) / orderTakerAmount;\n            }\n        }\n        return swapTakerAmount * orderMakerAmount / orderTakerAmount;\n    }\n\n    /// @notice Calculates taker amount\n    /// @return Result Ceiled taker amount\n    function getTakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapMakerAmount) internal pure returns(uint256) {\n        if ((swapMakerAmount | orderTakerAmount) >> 128 == 0) {\n            unchecked {\n                return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n            }\n        }\n        return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/BitInvalidatorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title BitInvalidatorLib\n * @dev The library provides a mechanism to invalidate objects based on a bit invalidator.\n * The bit invalidator holds a mapping where each key represents a slot number and each value contains an integer.\n * Each bit of the integer represents whether the object with corresponding index is valid or has been invalidated (0 - valid, 1 - invalidated).\n * The nonce given to access or invalidate an entity's state follows this structure:\n * - bits [0..7] represent the object state index in the slot.\n * - bits [8..255] represent the slot number (mapping key).\n */\nlibrary BitInvalidatorLib {\n    /// @dev The error is thrown when an attempt is made to invalidate an already invalidated entity.\n    error BitInvalidatedOrder();\n\n    struct Data {\n        mapping(uint256 slotIndex => uint256 slotData) _raw;\n    }\n\n    /**\n     * @notice Retrieves the validity status of entities in a specific slot.\n     * @dev Each bit in the returned value corresponds to the validity of an entity. 0 for valid, 1 for invalidated.\n     * @param self The data structure.\n     * @param nonce The nonce identifying the slot.\n     * @return result The validity status of entities in the slot as a uint256.\n     */\n    function checkSlot(Data storage self, uint256 nonce) internal view returns(uint256) {\n        uint256 invalidatorSlot = nonce >> 8;\n        return self._raw[invalidatorSlot];\n    }\n\n    /**\n     * @notice Checks the validity of a specific entity and invalidates it if valid.\n     * @dev Throws an error if the entity has already been invalidated.\n     * @param self The data structure.\n     * @param nonce The nonce identifying the slot and the entity.\n     */\n    function checkAndInvalidate(Data storage self, uint256 nonce) internal {\n        uint256 invalidatorSlot = nonce >> 8;\n        uint256 invalidatorBit = 1 << (nonce & 0xff);\n        uint256 invalidator = self._raw[invalidatorSlot];\n        if (invalidator & invalidatorBit == invalidatorBit) revert BitInvalidatedOrder();\n        self._raw[invalidatorSlot] = invalidator | invalidatorBit;\n    }\n\n    /**\n     * @notice Invalidates multiple entities in a single slot.\n     * @dev The entities to be invalidated are identified by setting their corresponding bits to 1 in a mask.\n     * @param self The data structure.\n     * @param nonce The nonce identifying the slot.\n     * @param additionalMask A mask of bits to be invalidated.\n     * @return result Resulting validity status of entities in the slot as a uint256.\n     */\n    function massInvalidate(Data storage self, uint256 nonce, uint256 additionalMask) internal returns(uint256 result) {\n        uint256 invalidatorSlot = nonce >> 8;\n        uint256 invalidatorBits = (1 << (nonce & 0xff)) | additionalMask;\n        result = self._raw[invalidatorSlot] | invalidatorBits;\n        self._raw[invalidatorSlot] = result;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Errors {\n    error InvalidMsgValue();\n    error ETHTransferFailed();\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/ExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IOrderMixin.sol\";\nimport \"./OffsetsLib.sol\";\n\n/**\n * @title ExtensionLib\n * @notice Library for retrieving extensions information for the IOrderMixin Interface.\n */\nlibrary ExtensionLib {\n    using AddressLib for Address;\n    using OffsetsLib for Offsets;\n\n    enum DynamicField {\n        MakerAssetSuffix,\n        TakerAssetSuffix,\n        MakingAmountData,\n        TakingAmountData,\n        Predicate,\n        MakerPermit,\n        PreInteractionData,\n        PostInteractionData,\n        CustomData\n    }\n\n    /**\n     * @notice Returns the MakerAssetSuffix from the provided extension calldata.\n     * @param extension The calldata from which the MakerAssetSuffix is to be retrieved.\n     * @return calldata Bytes representing the MakerAssetSuffix.\n     */\n    function makerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.MakerAssetSuffix);\n    }\n\n    /**\n     * @notice Returns the TakerAssetSuffix from the provided extension calldata.\n     * @param extension The calldata from which the TakerAssetSuffix is to be retrieved.\n     * @return calldata Bytes representing the TakerAssetSuffix.\n     */\n    function takerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.TakerAssetSuffix);\n    }\n\n    /**\n     * @notice Returns the MakingAmountData from the provided extension calldata.\n     * @param extension The calldata from which the MakingAmountData is to be retrieved.\n     * @return calldata Bytes representing the MakingAmountData.\n     */\n    function makingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.MakingAmountData);\n    }\n\n    /**\n     * @notice Returns the TakingAmountData from the provided extension calldata.\n     * @param extension The calldata from which the TakingAmountData is to be retrieved.\n     * @return calldata Bytes representing the TakingAmountData.\n     */\n    function takingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.TakingAmountData);\n    }\n\n    /**\n     * @notice Returns the order's predicate from the provided extension calldata.\n     * @param extension The calldata from which the predicate is to be retrieved.\n     * @return calldata Bytes representing the predicate.\n     */\n    function predicate(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.Predicate);\n    }\n\n    /**\n     * @notice Returns the maker's permit from the provided extension calldata.\n     * @param extension The calldata from which the maker's permit is to be retrieved.\n     * @return calldata Bytes representing the maker's permit.\n     */\n    function makerPermit(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.MakerPermit);\n    }\n\n\n    /**\n     * @notice Returns the pre-interaction from the provided extension calldata.\n     * @param extension The calldata from which the pre-interaction is to be retrieved.\n     * @return calldata Bytes representing the pre-interaction.\n     */\n    function preInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.PreInteractionData);\n    }\n\n    /**\n     * @notice Returns the post-interaction from the provided extension calldata.\n     * @param extension The calldata from which the post-interaction is to be retrieved.\n     * @return calldata Bytes representing the post-interaction.\n     */\n    function postInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.PostInteractionData);\n    }\n\n    /**\n     * @notice Returns extra suffix data from the provided extension calldata.\n     * @param extension The calldata from which the extra suffix data is to be retrieved.\n     * @return calldata Bytes representing the extra suffix data.\n     */\n    function customData(bytes calldata extension) internal pure returns(bytes calldata) {\n        if (extension.length < 0x20) return msg.data[:0];\n        uint256 offsets = uint256(bytes32(extension));\n        unchecked {\n            return extension[0x20 + (offsets >> 224):];\n        }\n    }\n\n    /**\n     * @notice Retrieves a specific field from the provided extension calldata.\n     * @dev The first 32 bytes of an extension calldata contain offsets to the end of each field within the calldata.\n     * @param extension The calldata from which the field is to be retrieved.\n     * @param field The specific dynamic field to retrieve from the extension.\n     * @return calldata Bytes representing the requested field.\n     */\n    function _get(bytes calldata extension, DynamicField field) private pure returns(bytes calldata) {\n        if (extension.length < 0x20) return msg.data[:0];\n\n        Offsets offsets;\n        bytes calldata concat;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            offsets := calldataload(extension.offset)\n            concat.offset := add(extension.offset, 0x20)\n            concat.length := sub(extension.length, 0x20)\n        }\n\n        return offsets.get(concat, uint256(field));\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/MakerTraitsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype MakerTraits is uint256;\n\n/**\n * @title MakerTraitsLib\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\n * @dev\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\n * High bits are used for flags\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\n * 253 bit                                  - unused\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\n\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n * uint80 last 10 bytes of allowed sender address (0 if any)\n * uint40 expiration timestamp (0 if none)\n * uint40 nonce or epoch\n * uint40 series\n */\nlibrary MakerTraitsLib {\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\n    uint256 private constant _EXPIRATION_OFFSET = 80;\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\n    uint256 private constant _SERIES_OFFSET = 160;\n    uint256 private constant _SERIES_MASK = type(uint40).max;\n\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\n\n    /**\n     * @notice Checks if the order has the extension flag set.\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the flag is set.\n     */\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker allows a specific taker to fill the order.\n     * @param makerTraits The traits of the maker.\n     * @param sender The address of the taker to be checked.\n     * @return result A boolean indicating whether the taker is allowed.\n     */\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\n    }\n\n    /**\n     * @notice Returns the expiration time of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The expiration timestamp of the order.\n     */\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\n    }\n\n    /**\n     * @notice Checks if the order has expired.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the order has expired.\n     */\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\n        uint256 expiration = getExpirationTime(makerTraits);\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the nonce or epoch of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The nonce or epoch of the order.\n     */\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\n    }\n\n    /**\n     * @notice Returns the series of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The series of the order.\n     */\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\n    }\n\n    /**\n      * @notice Determines if the order allows partial fills.\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows partial fills.\n      */\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs pre-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\n     */\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs post-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\n     */\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if the order allows multiple fills.\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows multiple fills.\n      */\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the bit invalidator should be used.\n      * True if the order requires the use of the bit invalidator.\n      */\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\n    }\n\n    /**\n     * @notice Checks if the maker needs to check the epoch.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\n     */\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker uses permit2.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker uses permit2.\n     */\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs to unwraps WETH.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\n     */\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/OffsetsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype Offsets is uint256;\n\n/// @title OffsetsLib\n/// @dev A library for retrieving values by offsets from a concatenated calldata.\nlibrary OffsetsLib {\n\n    /// @dev Error to be thrown when the offset is out of bounds.\n    error OffsetOutOfBounds();\n\n    /**\n     * @notice Retrieves the field value calldata corresponding to the provided field index from the concatenated calldata.\n     * @dev \n     * The function performs the following steps:\n     * 1. Retrieve the start and end of the segment corresponding to the provided index from the offsets array.\n     * 2. Get the value from segment using offset and length calculated based on the start and end of the segment.\n     * 3. Throw `OffsetOutOfBounds` error if the length of the segment is greater than the length of the concatenated data.\n     * @param offsets The offsets encoding the start and end of each segment within the concatenated calldata.\n     * @param concat The concatenated calldata.\n     * @param index The index of the segment to retrieve. The field index 0 corresponds to the lowest bytes of the offsets array.\n     * @return result The calldata from a segment of the concatenated calldata corresponding to the provided index.\n     */\n    function get(Offsets offsets, bytes calldata concat, uint256 index) internal pure returns(bytes calldata result) {\n        bytes4 exception = OffsetOutOfBounds.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            let bitShift := shl(5, index)                                   // bitShift = index * 32\n            let begin := and(0xffffffff, shr(bitShift, shl(32, offsets)))   // begin = offsets[ bitShift : bitShift + 32 ]\n            let end := and(0xffffffff, shr(bitShift, offsets))              // end   = offsets[ bitShift + 32 : bitShift + 64 ]\n            result.offset := add(concat.offset, begin)\n            result.length := sub(end, begin)\n            if gt(end, concat.length) {\n                mstore(0, exception)\n                revert(0, 4)\n            }\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/RemainingInvalidatorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype RemainingInvalidator is uint256;\n\n/**\n * @title RemainingInvalidatorLib\n * @notice The library provides a mechanism to invalidate order based on the remaining amount of the order.\n * @dev The remaining amount is used as a nonce to invalidate the order.\n * When order is created, the remaining invalidator is 0.\n * When order is filled, the remaining invalidator is the inverse of the remaining amount.\n */\nlibrary RemainingInvalidatorLib {\n\n    /// @dev The error is thrown when an attempt is made to invalidate an already invalidated entity.\n    error RemainingInvalidatedOrder();\n\n    /**\n     * @notice Checks if an order is new based on the invalidator value.\n     * @param invalidator The remaining invalidator of the order.\n     * @return result Whether the order is new or not.\n     */\n    function isNewOrder(RemainingInvalidator invalidator) internal pure returns(bool) {\n        return RemainingInvalidator.unwrap(invalidator) == 0;\n    }\n\n    /**\n     * @notice Retrieves the remaining amount for an order.\n     * @dev If the order is unknown, a RemainingInvalidatedOrder error is thrown.\n     * @param invalidator The remaining invalidator for the order.\n     * @return result The remaining amount for the order.\n     */\n    function remaining(RemainingInvalidator invalidator) internal pure returns(uint256) {\n        uint256 value = RemainingInvalidator.unwrap(invalidator);\n        if (value == 0) {\n            revert RemainingInvalidatedOrder();\n        }\n        unchecked {\n            return ~value;\n        }\n    }\n\n    /**\n     * @notice Calculates the remaining amount for an order.\n     * @dev If the order is unknown, the order maker amount is returned.\n     * @param invalidator The remaining invalidator for the order.\n     * @param orderMakerAmount The amount to return if the order is new.\n     * @return result The remaining amount for the order.\n     */\n    function remaining(RemainingInvalidator invalidator, uint256 orderMakerAmount) internal pure returns(uint256) {\n        uint256 value = RemainingInvalidator.unwrap(invalidator);\n        if (value == 0) {\n            return orderMakerAmount;\n        }\n        unchecked {\n            return ~value;\n        }\n    }\n\n    /**\n     * @notice Calculates the remaining invalidator of the order.\n     * @param remainingMakingAmount The remaining making amount of the order.\n     * @param makingAmount The making amount of the order.\n     * @return result The remaining invalidator for the order.\n     */\n    function remains(uint256 remainingMakingAmount, uint256 makingAmount) internal pure returns(RemainingInvalidator) {\n        unchecked {\n            return RemainingInvalidator.wrap(~(remainingMakingAmount - makingAmount));\n        }\n    }\n\n    /**\n     * @notice Provides the remaining invalidator for a fully filled order.\n     * @return result The remaining invalidator for a fully filled order.\n     */\n    function fullyFilled() internal pure returns(RemainingInvalidator) {\n        return RemainingInvalidator.wrap(type(uint256).max);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/libraries/TakerTraitsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype TakerTraits is uint256;\n\n/**\n * @title TakerTraitsLib\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\n * @dev The TakerTraits are structured as follows:\n * High bits are used for flags\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker’s funds transfer.\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\n */\nlibrary TakerTraitsLib {\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\n\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\n\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @notice Checks if the args should contain target address.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the args should contain target address.\n     */\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\n    }\n\n    /**\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\n     * @param takerTraits The traits of the taker.\n     * @return result The length of the extension calldata encoded in the takerTraits.\n     */\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\n     * @param takerTraits The traits of the taker.\n     * @return result The length of the interaction calldata encoded in the takerTraits.\n     */\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Checks if the taking amount should be calculated based on making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\n     */\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order should unwrap WETH.\n     */\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should skip maker's permit execution.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order don't apply permit.\n     */\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order uses the permit2 instead of permit.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order uses the permit2.\n     */\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\n    }\n\n    /**\n     * @notice Retrieves the threshold amount from the takerTraits.\n     * The maximum amount a taker agrees to give in exchange for a making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result The threshold amount encoded in the takerTraits.\n     */\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/LimitOrderProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"./OrderMixin.sol\";\n\n/**\n * @title ##1inch Limit Order Protocol v4\n * @notice Limit order protocol provides two different order types\n * - Regular Limit Order\n * - RFQ Order\n *\n * Both types provide similar order-fulfilling functionality. The difference is that regular order offers more customization options and features, while RFQ order is extremely gas efficient but without ability to customize.\n *\n * Regular limit order additionally supports\n * - Execution predicates. Conditions for order execution are set with predicates. For example, expiration timestamp or block number, price for stop loss or take profit strategies.\n * - Callbacks to notify maker on order execution\n *\n * See [OrderMixin](OrderMixin.md) for more details.\n *\n * RFQ orders supports\n * - Expiration time\n * - Cancelation by order id\n * - Partial Fill (only once)\n *\n * See [OrderMixin](OrderMixin.md) for more details.\n */\ncontract LimitOrderProtocol is\n    EIP712(\"1inch Limit Order Protocol\", \"4\"),\n    Ownable,\n    Pausable,\n    OrderMixin\n{\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IWETH _weth) OrderMixin(_weth) Ownable(msg.sender) {}\n\n    /// @dev Returns the domain separator for the current chain (EIP-712)\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns(bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Pauses all the trading functionality in the contract.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses all the trading functionality in the contract.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/AggregatorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\n/// @title Mock oracle that always returns specified token price\ncontract AggregatorMock is AggregatorV2V3Interface {\n    error NoDataPresent();\n\n    int256 private immutable _ANSWER;\n\n    constructor(int256 answer) {\n        _ANSWER = answer;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    function description() external pure returns (string memory) {\n        return \"AggregatorMock\";\n    }\n\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        if (_roundId != 0) revert NoDataPresent();\n        return latestRoundData();\n    }\n\n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        // solhint-disable-next-line not-rely-on-time\n        return (0, _ANSWER, block.timestamp - 100, block.timestamp - 100, 0);\n    }\n\n    function latestAnswer() public view returns (int256) {\n        return _ANSWER;\n    }\n\n    function latestTimestamp() public view returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp - 100;\n    }\n\n    function latestRound() external pure returns (uint256) {\n        return 0;\n    }\n\n    function getAnswer(uint256 roundId) external view returns (int256) {\n        if (roundId != 0) revert NoDataPresent();\n        return latestAnswer();\n    }\n\n    function getTimestamp(uint256 roundId) external view returns (uint256) {\n        if (roundId != 0) revert NoDataPresent();\n        return latestTimestamp();\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/ArbitraryPredicateMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\ncontract ArbitraryPredicateMock {\n    function copyArg(uint256 arg) external pure returns (uint256) {\n        return arg;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/CallsSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title Tool to be used inside `LOP.simulate()` call\ncontract CallsSimulator {\n    error ArraySizeMismatch();\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        if (targets.length != data.length) revert ArraySizeMismatch();\n        bytes memory reason = new bytes(targets.length);\n        for (uint256 i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length == 32 && abi.decode(result, (bool))) {\n                reason[i] = \"1\";\n            } else {\n                reason[i] = \"0\";\n            }\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/EIP712Alien.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Alien {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    address private immutable _ALIEN_ADDRESS;\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(address alien, string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n        _ALIEN_ADDRESS = alien;\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion, alien);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _ALIEN_ADDRESS);\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version, address alien) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                block.chainid,\n                alien\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/ExtensionMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"../libraries/ExtensionLib.sol\";\n\ncontract ExtensionMock {\n    using ExtensionLib for bytes;\n\n    function getCustomData(bytes calldata extension) external pure returns (bytes calldata) {\n        return extension.customData();\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/HashChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IPreInteraction.sol\";\nimport \"../OrderLib.sol\";\n\n\ncontract HashChecker is IPreInteraction, Ownable {\n    using OrderLib for IOrderMixin.Order;\n\n    error IncorrectOrderHash();\n\n    bytes32 public immutable LIMIT_ORDER_PROTOCOL_DOMAIN_SEPARATOR;\n    mapping(bytes32 => bool) public hashes;\n\n    constructor (address limitOrderProtocol, address owner_) Ownable(owner_) {\n        // solhint-disable-next-line avoid-low-level-calls\n        (, bytes memory data) = limitOrderProtocol.call(abi.encodeWithSignature(\"DOMAIN_SEPARATOR()\"));\n        LIMIT_ORDER_PROTOCOL_DOMAIN_SEPARATOR = abi.decode(data, (bytes32));\n    }\n\n    function setHashOrderStatus(IOrderMixin.Order calldata order, bool status) external onlyOwner {\n        bytes32 orderHash = order.hash(LIMIT_ORDER_PROTOCOL_DOMAIN_SEPARATOR);\n        hashes[orderHash] = status;\n    }\n\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external override {\n        if (hashes[orderHash] == false) revert IncorrectOrderHash();\n\n        if (extraData.length != 0) {\n            IPreInteraction(address(bytes20(extraData))).preInteraction(\n                order,\n                extension,\n                orderHash,\n                taker,\n                makingAmount,\n                takingAmount,\n                remainingMakingAmount,\n                extraData[20:]\n            );\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/InteractionMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"../interfaces/IPreInteraction.sol\";\nimport \"../interfaces/IPostInteraction.sol\";\n\ncontract InteractionMock is IPreInteraction, IPostInteraction {\n    error InvalidExtraDataLength();\n    error TakingAmountTooHigh();\n    error IncorrectTakingAmount();\n\n    function copyArg(uint256 arg) external pure returns (uint256) {\n        return arg;\n    }\n\n    function preInteraction(\n        IOrderMixin.Order calldata /* order */,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 /* makingAmount */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external pure {\n        if (extraData.length < 32) revert InvalidExtraDataLength();\n\n        uint256 targetAmount;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            targetAmount := calldataload(extraData.offset)\n        }\n\n        if (takingAmount != targetAmount) revert IncorrectTakingAmount();\n    }\n\n    function postInteraction(\n        IOrderMixin.Order calldata /* order */,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 /* makingAmount */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external pure {\n        if (extraData.length < 32) revert InvalidExtraDataLength();\n\n        uint256 threshold;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            threshold := calldataload(extraData.offset)\n        }\n\n        if (takingAmount > threshold) revert TakingAmountTooHigh();\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/MakerContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../LimitOrderProtocol.sol\";\nimport \"../OrderLib.sol\";\nimport { EIP712Alien } from \"./EIP712Alien.sol\";\n\ncontract MakerContract is IERC1271, EIP712Alien, ERC20 {\n    using SafeERC20 for IERC20;\n    using OrderLib for IOrderMixin.Order;\n    using AddressLib for Address;\n    using MakerTraitsLib for MakerTraits;\n\n    error NotAllowedToken();\n    error BadPrice();\n    error MalformedSignature();\n\n    address immutable public PROTOCOL;\n    IERC20 immutable public TOKEN0;\n    IERC20 immutable public TOKEN1;\n    uint256 immutable public FEE;\n    uint256 immutable public FEE2;\n\n    constructor(\n        address _protocol,\n        IERC20 _token0,\n        IERC20 _token1,\n        uint256 _fee,\n        string memory name,\n        string memory symbol\n    )\n        EIP712Alien(_protocol, \"1inch Limit Order Protocol\", \"4\")\n        ERC20(name, symbol)\n    {\n        PROTOCOL = _protocol;\n        TOKEN0 = _token0;\n        TOKEN1 = _token1;\n        FEE = _fee;\n        FEE2 = 2e18 * _fee / (1e18 + _fee);\n        _token0.approve(_protocol, type(uint256).max);\n        _token1.approve(_protocol, type(uint256).max);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function deposit(IERC20 token, uint256 amount) public {\n        depositFor(token, amount, msg.sender);\n    }\n\n    function depositFor(IERC20 token, uint256 amount, address to) public {\n        if (token != TOKEN0 && token != TOKEN1) revert NotAllowedToken();\n\n        _mint(to, amount * FEE2 / 1e18);\n        token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(IERC20 token, uint256 amount) public {\n        withdrawFor(token, amount, msg.sender);\n    }\n\n    function withdrawFor(IERC20 token, uint256 amount, address to) public {\n        if (token != TOKEN0 && token != TOKEN1) revert NotAllowedToken();\n\n        _burn(msg.sender, amount);\n        token.safeTransfer(to, amount * FEE2 / 1e18);\n    }\n\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view override returns(bytes4) {\n        if (signature.length != 8 * 0x20) revert MalformedSignature();\n\n        IOrderMixin.Order calldata order;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            order := signature.offset\n        }\n\n        if (\n            (\n                (order.makerAsset.get() != address(TOKEN0) || order.takerAsset.get() != address(TOKEN1)) &&\n                (order.makerAsset.get() != address(TOKEN1) || order.takerAsset.get() != address(TOKEN0))\n            ) ||\n            order.makerTraits.hasExtension() ||\n            order.makingAmount * FEE > order.takingAmount * 1e18 ||\n            order.hash(_domainSeparatorV4()) != hash\n        ) revert BadPrice();\n\n        return this.isValidSignature.selector;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/RecursiveMatcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ITakerInteraction.sol\";\nimport \"../interfaces/IOrderMixin.sol\";\nimport \"../interfaces/IOrderMixin.sol\";\nimport \"../libraries/TakerTraitsLib.sol\";\n\ncontract RecursiveMatcher is ITakerInteraction {\n    bytes1 private constant _FINALIZE_INTERACTION = 0x01;\n\n    error IncorrectCalldataParams();\n    error FailedExternalCall(bytes reason);\n\n    function matchOrders(\n        IOrderMixin orderMixin,\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external {\n        orderMixin.fillOrderArgs(\n            order,\n            r,\n            vs,\n            amount,\n            takerTraits,\n            args\n        );\n    }\n\n    function takerInteraction(\n        IOrderMixin.Order calldata /* order */,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 /* makingAmount */,\n        uint256 /* takingAmount */,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external {\n        if(extraData[0] & _FINALIZE_INTERACTION != 0x0) {\n            (\n                address[] memory targets,\n                bytes[] memory calldatas\n            ) = abi.decode(extraData[1:], (address[], bytes[]));\n\n            if (targets.length != calldatas.length) revert IncorrectCalldataParams();\n            for (uint256 i = 0; i < targets.length; i++) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, bytes memory reason) = targets[i].call(calldatas[i]);\n                if(!success) revert FailedExternalCall(reason);\n            }\n        } else {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory reason) = msg.sender.call(\n                abi.encodePacked(IOrderMixin.fillOrderArgs.selector, extraData[1:])\n            );\n            if (!success) revert FailedExternalCall(reason);\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/TakerContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IOrderMixin } from \"../interfaces/IOrderMixin.sol\";\nimport { TakerTraits } from \"../libraries/TakerTraitsLib.sol\";\n\ncontract TakerContract {\n    IOrderMixin private immutable _SWAP;\n\n    constructor(IOrderMixin swap) {\n        _SWAP = swap;\n    }\n\n    function fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable {\n        _SWAP.fillOrder {value: msg.value} (order, r, vs, amount, takerTraits);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/mocks/WrappedTokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\";\n\n/// @title Generic token for testing purposes with deposit/withdraw capabilities\ncontract WrappedTokenMock is ERC20Permit, Ownable, IWETH {\n    error NotEnoughBalance();\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) Ownable(msg.sender) {}\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {\n        deposit();\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        // balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        if (balanceOf(msg.sender) < wad) revert NotEnoughBalance();\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/OrderLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\";\n\nimport \"./interfaces/IOrderMixin.sol\";\nimport \"./libraries/MakerTraitsLib.sol\";\nimport \"./libraries/ExtensionLib.sol\";\nimport \"./libraries/AmountCalculatorLib.sol\";\nimport \"./interfaces/IAmountGetter.sol\";\n\n/**\n * @title OrderLib\n * @dev The library provides common functionality for processing and manipulating limit orders.\n * It provides functionality to calculate and verify order hashes, calculate trade amounts, and validate\n * extension data associated with orders. The library also contains helper methods to get the receiver of\n * an order and call getter functions.\n */\n library OrderLib {\n    using AddressLib for Address;\n    using MakerTraitsLib for MakerTraits;\n    using ExtensionLib for bytes;\n\n    /// @dev Error to be thrown when the extension data of an order is missing.\n    error MissingOrderExtension();\n    /// @dev Error to be thrown when the order has an unexpected extension.\n    error UnexpectedOrderExtension();\n    /// @dev Error to be thrown when the order extension hash is invalid.\n    error InvalidExtensionHash();\n\n    /// @dev The typehash of the order struct.\n    bytes32 constant internal _LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(\"\n            \"uint256 salt,\"\n            \"address maker,\"\n            \"address receiver,\"\n            \"address makerAsset,\"\n            \"address takerAsset,\"\n            \"uint256 makingAmount,\"\n            \"uint256 takingAmount,\"\n            \"uint256 makerTraits\"\n        \")\"\n    );\n    uint256 constant internal _ORDER_STRUCT_SIZE = 0x100;\n    uint256 constant internal _DATA_HASH_SIZE = 0x120;\n\n    /**\n      * @notice Calculates the hash of an order.\n      * @param order The order to be hashed.\n      * @param domainSeparator The domain separator to be used for the EIP-712 hashing.\n      * @return result The keccak256 hash of the order data.\n      */\n    function hash(IOrderMixin.Order calldata order, bytes32 domainSeparator) internal pure returns(bytes32 result) {\n        bytes32 typehash = _LIMIT_ORDER_TYPEHASH;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // keccak256(abi.encode(_LIMIT_ORDER_TYPEHASH, order));\n            mstore(ptr, typehash)\n            calldatacopy(add(ptr, 0x20), order, _ORDER_STRUCT_SIZE)\n            result := keccak256(ptr, _DATA_HASH_SIZE)\n        }\n        result = ECDSA.toTypedDataHash(domainSeparator, result);\n    }\n\n    /**\n      * @notice Returns the receiver address for an order.\n      * @param order The order.\n      * @return receiver The address of the receiver, either explicitly defined in the order or the maker's address if not specified.\n      */\n    function getReceiver(IOrderMixin.Order calldata order) internal pure returns(address /*receiver*/) {\n        address receiver = order.receiver.get();\n        return receiver != address(0) ? receiver : order.maker.get();\n    }\n\n    /**\n      * @notice Calculates the making amount based on the requested taking amount.\n      * @dev If getter is specified in the extension data, the getter is called to calculate the making amount,\n      * otherwise the making amount is calculated linearly.\n      * @param order The order.\n      * @param extension The extension data associated with the order.\n      * @param requestedTakingAmount The amount the taker wants to take.\n      * @param remainingMakingAmount The remaining amount of the asset left to fill.\n      * @param orderHash The hash of the order.\n      * @return makingAmount The amount of the asset the maker receives.\n      */\n    function calculateMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        uint256 requestedTakingAmount,\n        uint256 remainingMakingAmount,\n        bytes32 orderHash\n    ) internal view returns(uint256) {\n        bytes calldata data = extension.makingAmountData();\n        if (data.length == 0) {\n            // Linear proportion\n            return AmountCalculatorLib.getMakingAmount(order.makingAmount, order.takingAmount, requestedTakingAmount);\n        }\n        return IAmountGetter(address(bytes20(data))).getMakingAmount(\n            order,\n            extension,\n            orderHash,\n            msg.sender,\n            requestedTakingAmount,\n            remainingMakingAmount,\n            data[20:]\n        );\n    }\n\n    /**\n      * @notice Calculates the taking amount based on the requested making amount.\n      * @dev If getter is specified in the extension data, the getter is called to calculate the taking amount,\n      * otherwise the taking amount is calculated linearly.\n      * @param order The order.\n      * @param extension The extension data associated with the order.\n      * @param requestedMakingAmount The amount the maker wants to receive.\n      * @param remainingMakingAmount The remaining amount of the asset left to be filled.\n      * @param orderHash The hash of the order.\n      * @return takingAmount The amount of the asset the taker takes.\n      */\n    function calculateTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        uint256 requestedMakingAmount,\n        uint256 remainingMakingAmount,\n        bytes32 orderHash\n    ) internal view returns(uint256) {\n        bytes calldata data = extension.takingAmountData();\n        if (data.length == 0) {\n            // Linear proportion\n            return AmountCalculatorLib.getTakingAmount(order.makingAmount, order.takingAmount, requestedMakingAmount);\n        }\n        return IAmountGetter(address(bytes20(data))).getTakingAmount(\n            order,\n            extension,\n            orderHash,\n            msg.sender,\n            requestedMakingAmount,\n            remainingMakingAmount,\n            data[20:]\n        );\n    }\n\n    /**\n      * @dev Validates the extension associated with an order.\n      * @param order The order to validate against.\n      * @param extension The extension associated with the order.\n      * @return valid True if the extension is valid, false otherwise.\n      * @return errorSelector The error selector if the extension is invalid, 0x00000000 otherwise.\n      */\n    function isValidExtension(IOrderMixin.Order calldata order, bytes calldata extension) internal pure returns(bool, bytes4) {\n        if (order.makerTraits.hasExtension()) {\n            if (extension.length == 0) return (false, MissingOrderExtension.selector);\n            // Lowest 160 bits of the order salt must be equal to the lowest 160 bits of the extension hash\n            if (uint256(keccak256(extension)) & type(uint160).max != order.salt & type(uint160).max) return (false, InvalidExtensionHash.selector);\n        } else {\n            if (extension.length > 0) return (false, UnexpectedOrderExtension.selector);\n        }\n        return (true, 0x00000000);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-protocol/OrderMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport \"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/mixins/OnlyWethReceiver.sol\";\nimport \"@1inch/solidity-utils/contracts/mixins/PermitAndCall.sol\";\n\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./helpers/SeriesEpochManager.sol\";\nimport \"./interfaces/ITakerInteraction.sol\";\nimport \"./interfaces/IPreInteraction.sol\";\nimport \"./interfaces/IPostInteraction.sol\";\nimport \"./interfaces/IOrderMixin.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/TakerTraitsLib.sol\";\nimport \"./libraries/BitInvalidatorLib.sol\";\nimport \"./libraries/RemainingInvalidatorLib.sol\";\nimport \"./OrderLib.sol\";\n\n/// @title Limit Order mixin\nabstract contract OrderMixin is IOrderMixin, EIP712, PredicateHelper, SeriesEpochManager, Pausable, OnlyWethReceiver, PermitAndCall {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n    using OrderLib for IOrderMixin.Order;\n    using ExtensionLib for bytes;\n    using AddressLib for Address;\n    using MakerTraitsLib for MakerTraits;\n    using TakerTraitsLib for TakerTraits;\n    using BitInvalidatorLib for BitInvalidatorLib.Data;\n    using RemainingInvalidatorLib for RemainingInvalidator;\n\n    IWETH private immutable _WETH;\n    mapping(address maker => BitInvalidatorLib.Data data) private _bitInvalidator;\n    mapping(address maker => mapping(bytes32 orderHash => RemainingInvalidator remaining)) private _remainingInvalidator;\n\n    constructor(IWETH weth) OnlyWethReceiver(address(weth)) {\n        _WETH = weth;\n    }\n\n    /**\n     * @notice See {IOrderMixin-bitInvalidatorForOrder}.\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 /* result */) {\n        return _bitInvalidator[maker].checkSlot(slot);\n    }\n\n    /**\n     * @notice See {IOrderMixin-remainingInvalidatorForOrder}.\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 /* remaining */) {\n        return _remainingInvalidator[maker][orderHash].remaining();\n    }\n\n    /**\n     * @notice See {IOrderMixin-rawRemainingInvalidatorForOrder}.\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 /* remainingRaw */) {\n        return RemainingInvalidator.unwrap(_remainingInvalidator[maker][orderHash]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-simulate}.\n     */\n    function simulate(address target, bytes calldata data) external {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = target.delegatecall(data);\n        revert SimulationResults(success, result);\n    }\n\n    /**\n     * @notice See {IOrderMixin-cancelOrder}.\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) public {\n        if (makerTraits.useBitInvalidator()) {\n            uint256 invalidator = _bitInvalidator[msg.sender].massInvalidate(makerTraits.nonceOrEpoch(), 0);\n            emit BitInvalidatorUpdated(msg.sender, makerTraits.nonceOrEpoch() >> 8, invalidator);\n        } else {\n            _remainingInvalidator[msg.sender][orderHash] = RemainingInvalidatorLib.fullyFilled();\n            emit OrderCancelled(orderHash);\n        }\n    }\n\n    /**\n     * @notice See {IOrderMixin-cancelOrders}.\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external {\n        if (makerTraits.length != orderHashes.length) revert MismatchArraysLengths();\n        unchecked {\n            for (uint256 i = 0; i < makerTraits.length; i++) {\n                cancelOrder(makerTraits[i], orderHashes[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice See {IOrderMixin-bitsInvalidateForOrder}.\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external {\n        if (!makerTraits.useBitInvalidator()) revert OrderIsNotSuitableForMassInvalidation();\n        uint256 invalidator = _bitInvalidator[msg.sender].massInvalidate(makerTraits.nonceOrEpoch(), additionalMask);\n        emit BitInvalidatorUpdated(msg.sender, makerTraits.nonceOrEpoch() >> 8, invalidator);\n    }\n\n     /**\n     * @notice See {IOrderMixin-hashOrder}.\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32) {\n        return order.hash(_domainSeparatorV4());\n    }\n\n    /**\n     * @notice See {IOrderMixin-checkPredicate}.\n     */\n    function checkPredicate(bytes calldata predicate) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), predicate);\n        return success && res == 1;\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillOrder}.\n     */\n    function fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        return _fillOrder(order, r, vs, amount, takerTraits, msg.sender, msg.data[:0], msg.data[:0]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillOrderArgs}.\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        (\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        ) = _parseArgs(takerTraits, args);\n\n        return _fillOrder(order, r, vs, amount, takerTraits, target, extension, interaction);\n    }\n\n    function _fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        // Check signature and apply order/maker permit only on the first fill\n        orderHash = order.hash(_domainSeparatorV4());\n        uint256 remainingMakingAmount = _checkRemainingMakingAmount(order, orderHash);\n        if (remainingMakingAmount == order.makingAmount) {\n            address maker = order.maker.get();\n            if (maker == address(0) || maker != ECDSA.recover(orderHash, r, vs)) revert BadSignature();\n            if (!takerTraits.skipMakerPermit()) {\n                bytes calldata makerPermit = extension.makerPermit();\n                if (makerPermit.length >= 20) {\n                    // proceed only if taker is willing to execute permit and its length is enough to store address\n                    IERC20(address(bytes20(makerPermit))).tryPermit(maker, address(this), makerPermit[20:]);\n                    if (!order.makerTraits.useBitInvalidator()) {\n                        // Bit orders are not subjects for reentrancy, but we still need to check remaining-based orders for reentrancy\n                        if (!_remainingInvalidator[order.maker.get()][orderHash].isNewOrder()) revert ReentrancyDetected();\n                    }\n                }\n            }\n        }\n\n        (makingAmount, takingAmount) = _fill(order, orderHash, remainingMakingAmount, amount, takerTraits, target, extension, interaction);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillContractOrder}.\n     */\n    function fillContractOrder(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        return _fillContractOrder(order, signature, amount, takerTraits, msg.sender, msg.data[:0], msg.data[:0]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillContractOrderArgs}.\n     */\n    function fillContractOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        (\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        ) = _parseArgs(takerTraits, args);\n\n        return _fillContractOrder(order, signature, amount, takerTraits, target, extension, interaction);\n    }\n\n    function _fillContractOrder(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        // Check signature only on the first fill\n        orderHash = order.hash(_domainSeparatorV4());\n        uint256 remainingMakingAmount = _checkRemainingMakingAmount(order, orderHash);\n        if (remainingMakingAmount == order.makingAmount) {\n            if (!ECDSA.isValidSignature(order.maker.get(), orderHash, signature)) revert BadSignature();\n        }\n\n        (makingAmount, takingAmount) = _fill(order, orderHash, remainingMakingAmount, amount, takerTraits, target, extension, interaction);\n    }\n\n    /**\n      * @notice Fills an order and transfers making amount to a specified target.\n      * @dev If the target is zero assigns it the caller's address.\n      * The function flow is as follows:\n      * 1. Validate order\n      * 2. Call maker pre-interaction\n      * 3. Transfer maker asset to taker\n      * 4. Call taker interaction\n      * 5. Transfer taker asset to maker\n      * 5. Call maker post-interaction\n      * 6. Emit OrderFilled event\n      * @param order The order details.\n      * @param orderHash The hash of the order.\n      * @param extension The extension calldata of the order.\n      * @param remainingMakingAmount The remaining amount to be filled.\n      * @param amount The order amount.\n      * @param takerTraits The taker preferences for the order.\n      * @param target The address to which the order is filled.\n      * @param interaction The interaction calldata.\n      * @return makingAmount The computed amount that the maker will send.\n      * @return takingAmount The computed amount that the taker will send.\n      */\n    function _fill(\n        IOrderMixin.Order calldata order,\n        bytes32 orderHash,\n        uint256 remainingMakingAmount,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private whenNotPaused() returns(uint256 makingAmount, uint256 takingAmount) {\n        // Validate order\n        {\n            (bool valid, bytes4 validationResult) = order.isValidExtension(extension);\n            if (!valid) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly (\"memory-safe\") {\n                    mstore(0, validationResult)\n                    revert(0, 4)\n                }\n            }\n        }\n        if (!order.makerTraits.isAllowedSender(msg.sender)) revert PrivateOrder();\n        if (order.makerTraits.isExpired()) revert OrderExpired();\n        if (order.makerTraits.needCheckEpochManager()) {\n            if (order.makerTraits.useBitInvalidator()) revert EpochManagerAndBitInvalidatorsAreIncompatible();\n            if (!epochEquals(order.maker.get(), order.makerTraits.series(), order.makerTraits.nonceOrEpoch())) revert WrongSeriesNonce();\n        }\n\n        // Check if orders predicate allows filling\n        if (extension.length > 0) {\n            bytes calldata predicate = extension.predicate();\n            if (predicate.length > 0) {\n                if (!checkPredicate(predicate)) revert PredicateIsNotTrue();\n            }\n        }\n\n        // Compute maker and taker assets amount\n        if (takerTraits.isMakingAmount()) {\n            makingAmount = Math.min(amount, remainingMakingAmount);\n            takingAmount = order.calculateTakingAmount(extension, makingAmount, remainingMakingAmount, orderHash);\n\n            uint256 threshold = takerTraits.threshold();\n            if (threshold > 0) {\n                // Check rate: takingAmount / makingAmount <= threshold / amount\n                if (amount == makingAmount) {  // Gas optimization, no SafeMath.mul()\n                    if (takingAmount > threshold) revert TakingAmountTooHigh();\n                } else {\n                    if (takingAmount * amount > threshold * makingAmount) revert TakingAmountTooHigh();\n                }\n            }\n        }\n        else {\n            takingAmount = amount;\n            makingAmount = order.calculateMakingAmount(extension, takingAmount, remainingMakingAmount, orderHash);\n            if (makingAmount > remainingMakingAmount) {\n                // Try to decrease taking amount because computed making amount exceeds remaining amount\n                makingAmount = remainingMakingAmount;\n                takingAmount = order.calculateTakingAmount(extension, makingAmount, remainingMakingAmount, orderHash);\n                if (takingAmount > amount) revert TakingAmountExceeded();\n            }\n\n            uint256 threshold = takerTraits.threshold();\n            if (threshold > 0) {\n                // Check rate: makingAmount / takingAmount >= threshold / amount\n                if (amount == takingAmount) { // Gas optimization, no SafeMath.mul()\n                    if (makingAmount < threshold) revert MakingAmountTooLow();\n                } else {\n                    if (makingAmount * amount < threshold * takingAmount) revert MakingAmountTooLow();\n                }\n            }\n        }\n        if (!order.makerTraits.allowPartialFills() && makingAmount != order.makingAmount) revert PartialFillNotAllowed();\n        unchecked { if (makingAmount * takingAmount == 0) revert SwapWithZeroAmount(); }\n\n        // Invalidate order depending on makerTraits\n        if (order.makerTraits.useBitInvalidator()) {\n            _bitInvalidator[order.maker.get()].checkAndInvalidate(order.makerTraits.nonceOrEpoch());\n        } else {\n            _remainingInvalidator[order.maker.get()][orderHash] = RemainingInvalidatorLib.remains(remainingMakingAmount, makingAmount);\n        }\n\n        // Pre interaction, where maker can prepare funds interactively\n        if (order.makerTraits.needPreInteractionCall()) {\n            bytes calldata data = extension.preInteractionTargetAndData();\n            address listener = order.maker.get();\n            if (data.length > 19) {\n                listener = address(bytes20(data));\n                data = data[20:];\n            }\n            IPreInteraction(listener).preInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, data\n            );\n        }\n\n        // Maker => Taker\n        {\n            bool needUnwrap = order.makerAsset.get() == address(_WETH) && takerTraits.unwrapWeth();\n            address receiver = needUnwrap ? address(this) : target;\n            if (order.makerTraits.usePermit2()) {\n                if (extension.makerAssetSuffix().length > 0) revert InvalidPermit2Transfer();\n                IERC20(order.makerAsset.get()).safeTransferFromPermit2(order.maker.get(), receiver, makingAmount);\n            } else {\n                if (!_callTransferFromWithSuffix(\n                    order.makerAsset.get(),\n                    order.maker.get(),\n                    receiver,\n                    makingAmount,\n                    extension.makerAssetSuffix()\n                )) revert TransferFromMakerToTakerFailed();\n            }\n            if (needUnwrap) {\n                _WETH.safeWithdrawTo(makingAmount, target);\n            }\n        }\n\n        if (interaction.length > 19) {\n            // proceed only if interaction length is enough to store address\n            ITakerInteraction(address(bytes20(interaction))).takerInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, interaction[20:]\n            );\n        }\n\n        // Taker => Maker\n        if (order.takerAsset.get() == address(_WETH) && msg.value > 0) {\n            if (msg.value < takingAmount) revert Errors.InvalidMsgValue();\n            if (msg.value > takingAmount) {\n                unchecked {\n                    // solhint-disable-next-line avoid-low-level-calls\n                    (bool success, ) = msg.sender.call{value: msg.value - takingAmount}(\"\");\n                    if (!success) revert Errors.ETHTransferFailed();\n                }\n            }\n\n            if (order.makerTraits.unwrapWeth()) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = order.getReceiver().call{value: takingAmount}(\"\");\n                if (!success) revert Errors.ETHTransferFailed();\n            } else {\n                _WETH.safeDeposit(takingAmount);\n                _WETH.safeTransfer(order.getReceiver(), takingAmount);\n            }\n        } else {\n            if (msg.value != 0) revert Errors.InvalidMsgValue();\n\n            bool needUnwrap = order.takerAsset.get() == address(_WETH) && order.makerTraits.unwrapWeth();\n            address receiver = needUnwrap ? address(this) : order.getReceiver();\n            if (takerTraits.usePermit2()) {\n                if (extension.takerAssetSuffix().length > 0) revert InvalidPermit2Transfer();\n                IERC20(order.takerAsset.get()).safeTransferFromPermit2(msg.sender, receiver, takingAmount);\n            } else {\n                if (!_callTransferFromWithSuffix(\n                    order.takerAsset.get(),\n                    msg.sender,\n                    receiver,\n                    takingAmount,\n                    extension.takerAssetSuffix()\n                )) revert TransferFromTakerToMakerFailed();\n            }\n\n            if (needUnwrap) {\n                _WETH.safeWithdrawTo(takingAmount, order.getReceiver());\n            }\n        }\n\n        // Post interaction, where maker can handle funds interactively\n        if (order.makerTraits.needPostInteractionCall()) {\n            bytes calldata data = extension.postInteractionTargetAndData();\n            address listener = order.maker.get();\n            if (data.length > 19) {\n                listener = address(bytes20(data));\n                data = data[20:];\n            }\n            IPostInteraction(listener).postInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, data\n            );\n        }\n\n        emit OrderFilled(orderHash, remainingMakingAmount - makingAmount);\n    }\n\n    /**\n      * @notice Processes the taker interaction arguments.\n      * @param takerTraits The taker preferences for the order.\n      * @param args The taker interaction arguments.\n      * @return target The address to which the order is filled.\n      * @return extension The extension calldata of the order.\n      * @return interaction The interaction calldata.\n      */\n    function _parseArgs(TakerTraits takerTraits, bytes calldata args)\n        private\n        view\n        returns(\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        )\n    {\n        if (takerTraits.argsHasTarget()) {\n            target = address(bytes20(args));\n            args = args[20:];\n        } else {\n            target = msg.sender;\n        }\n\n        uint256 extensionLength = takerTraits.argsExtensionLength();\n        if (extensionLength > 0) {\n            extension = args[:extensionLength];\n            args = args[extensionLength:];\n        } else {\n            extension = msg.data[:0];\n        }\n\n        uint256 interactionLength = takerTraits.argsInteractionLength();\n        if (interactionLength > 0) {\n            interaction = args[:interactionLength];\n        } else {\n            interaction = msg.data[:0];\n        }\n    }\n\n    /**\n      * @notice Checks the remaining making amount for the order.\n      * @dev If the order has been invalidated, the function will revert.\n      * @param order The order to check.\n      * @param orderHash The hash of the order.\n      * @return remainingMakingAmount The remaining amount of the order.\n      */\n    function _checkRemainingMakingAmount(IOrderMixin.Order calldata order, bytes32 orderHash) private view returns(uint256 remainingMakingAmount) {\n        if (order.makerTraits.useBitInvalidator()) {\n            remainingMakingAmount = order.makingAmount;\n        } else {\n            remainingMakingAmount = _remainingInvalidator[order.maker.get()][orderHash].remaining(order.makingAmount);\n        }\n        if (remainingMakingAmount == 0) revert InvalidatedOrder();\n    }\n\n    /**\n      * @notice Calls the transferFrom function with an arbitrary suffix.\n      * @dev The suffix is appended to the end of the standard ERC20 transferFrom function parameters.\n      * @param asset The token to be transferred.\n      * @param from The address to transfer the token from.\n      * @param to The address to transfer the token to.\n      * @param amount The amount of the token to transfer.\n      * @param suffix The suffix (additional data) to append to the end of the transferFrom call.\n      * @return success A boolean indicating whether the transfer was successful.\n      */\n    function _callTransferFromWithSuffix(address asset, address from, address to, uint256 amount, bytes calldata suffix) private returns(bool success) {\n        bytes4 selector = IERC20.transferFrom.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            if suffix.length {\n                calldatacopy(add(data, 0x64), suffix.offset, suffix.length)\n            }\n            let status := call(gas(), asset, 0, data, add(0x64, suffix.length), 0x0, 0x20)\n            success := and(status, or(iszero(returndatasize()), and(gt(returndatasize(), 31), eq(mload(0), 1))))\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-settlement/extensions/BaseExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IOrderMixin } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\";\nimport { IPostInteraction } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol\";\nimport { IPreInteraction } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IPreInteraction.sol\";\nimport { IAmountGetter } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol\";\n\n/**\n * @title Base Extension contract\n * @notice Contract to define the basic functionality for the limit orders settlement.\n */\ncontract BaseExtension is IPreInteraction, IPostInteraction, IAmountGetter {\n    error OnlyLimitOrderProtocol();\n\n    uint256 private constant _BASE_POINTS = 10_000_000; // 100%\n    uint256 private constant _GAS_PRICE_BASE = 1_000_000; // 1000 means 1 Gwei\n\n    address private immutable _LIMIT_ORDER_PROTOCOL;\n\n    /// @dev Modifier to check if the caller is the limit order protocol contract.\n    modifier onlyLimitOrderProtocol() {\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) revert OnlyLimitOrderProtocol();\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @param limitOrderProtocol The limit order protocol contract.\n     */\n    constructor(address limitOrderProtocol) {\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\n    }\n\n    /**\n     * See {IAmountGetter-getMakingAmount}\n     */\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        uint256 rateBump = _getRateBump(extraData);\n        return\n            Math.mulDiv(\n                order.makingAmount,\n                takingAmount * _BASE_POINTS,\n                order.takingAmount * (_BASE_POINTS + rateBump)\n            );\n    }\n\n    /**\n     * See {IAmountGetter-getTakingAmount}\n     */\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        uint256 rateBump = _getRateBump(extraData);\n        return\n            Math.mulDiv(\n                order.takingAmount,\n                makingAmount * (_BASE_POINTS + rateBump),\n                order.makingAmount * _BASE_POINTS,\n                Math.Rounding.Ceil\n            );\n    }\n\n    /**\n     * See {IPreInteraction-preInteraction}\n     */\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external onlyLimitOrderProtocol {\n        _preInteraction(\n            order,\n            extension,\n            orderHash,\n            taker,\n            makingAmount,\n            takingAmount,\n            remainingMakingAmount,\n            extraData\n        );\n    }\n\n    /**\n     * See {IPostInteraction-postInteraction}\n     */\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external onlyLimitOrderProtocol {\n        _postInteraction(\n            order,\n            extension,\n            orderHash,\n            taker,\n            makingAmount,\n            takingAmount,\n            remainingMakingAmount,\n            extraData\n        );\n    }\n\n    function _preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal virtual {}\n\n    function _postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal virtual {\n        // Allows to add custom postInteractions\n        if (extraData.length > 20) {\n            IPostInteraction(address(bytes20(extraData))).postInteraction(\n                order,\n                extension,\n                orderHash,\n                taker,\n                makingAmount,\n                takingAmount,\n                remainingMakingAmount,\n                extraData[20:extraData.length - 1]\n            );\n        }\n    }\n\n    /**\n     * @dev Parses auction rate bump data from the `auctionDetails` field.\n     * `gasBumpEstimate` and `gasPriceEstimate` are used to estimate the transaction costs\n     * which are then offset from the auction rate bump.\n     * @param auctionDetails AuctionDetails is a tightly packed struct of the following format:\n     * ```\n     * struct AuctionDetails {\n     *     bytes3 gasBumpEstimate;\n     *     bytes4 gasPriceEstimate;\n     *     bytes4 auctionStartTime;\n     *     bytes3 auctionDuration;\n     *     bytes3 initialRateBump;\n     *     (bytes3,bytes2)[N] pointsAndTimeDeltas;\n     * }\n     * ```\n     * @return rateBump The rate bump.\n     */\n    function _getRateBump(bytes calldata auctionDetails) private view returns (uint256) {\n        unchecked {\n            uint256 gasBumpEstimate = uint24(bytes3(auctionDetails[0:3]));\n            uint256 gasPriceEstimate = uint32(bytes4(auctionDetails[3:7]));\n            uint256 gasBump = gasBumpEstimate == 0 || gasPriceEstimate == 0\n                ? 0\n                : (gasBumpEstimate * block.basefee) / gasPriceEstimate / _GAS_PRICE_BASE;\n            uint256 auctionStartTime = uint32(bytes4(auctionDetails[7:11]));\n            uint256 auctionFinishTime = auctionStartTime + uint24(bytes3(auctionDetails[11:14]));\n            uint256 initialRateBump = uint24(bytes3(auctionDetails[14:17]));\n            uint256 auctionBump = _getAuctionBump(\n                auctionStartTime,\n                auctionFinishTime,\n                initialRateBump,\n                auctionDetails[17:]\n            );\n            return auctionBump > gasBump ? auctionBump - gasBump : 0;\n        }\n    }\n\n    /**\n     * @dev Calculates auction price bump. Auction is represented as a piecewise linear function with `N` points.\n     * Each point is represented as a pair of `(rateBump, timeDelta)`, where `rateBump` is the\n     * rate bump in basis points and `timeDelta` is the time delta in seconds.\n     * The rate bump is interpolated linearly between the points.\n     * The last point is assumed to be `(0, auctionDuration)`.\n     * @param auctionStartTime The time when the auction starts.\n     * @param auctionFinishTime The time when the auction finishes.\n     * @param initialRateBump The initial rate bump.\n     * @param pointsAndTimeDeltas The points and time deltas structure.\n     * @return The rate bump at the current time.\n     */\n    function _getAuctionBump(\n        uint256 auctionStartTime,\n        uint256 auctionFinishTime,\n        uint256 initialRateBump,\n        bytes calldata pointsAndTimeDeltas\n    ) private view returns (uint256) {\n        unchecked {\n            if (block.timestamp <= auctionStartTime) {\n                return initialRateBump;\n            } else if (block.timestamp >= auctionFinishTime) {\n                return 0;\n            }\n\n            uint256 currentPointTime = auctionStartTime;\n            uint256 currentRateBump = initialRateBump;\n\n            while (pointsAndTimeDeltas.length > 0) {\n                uint256 nextRateBump = uint24(bytes3(pointsAndTimeDeltas[:3]));\n                uint256 nextPointTime = currentPointTime + uint16(bytes2(pointsAndTimeDeltas[3:5]));\n                if (block.timestamp <= nextPointTime) {\n                    return\n                        ((block.timestamp - currentPointTime) *\n                            nextRateBump +\n                            (nextPointTime - block.timestamp) *\n                            currentRateBump) / (nextPointTime - currentPointTime);\n                }\n                currentRateBump = nextRateBump;\n                currentPointTime = nextPointTime;\n                pointsAndTimeDeltas = pointsAndTimeDeltas[5:];\n            }\n            return ((auctionFinishTime - block.timestamp) * currentRateBump) / (auctionFinishTime - currentPointTime);\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-settlement/extensions/ExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Extension Library\n * @notice Library to retrieve data from the bitmap.\n */\nlibrary ExtensionLib {\n    bytes1 private constant _RESOLVER_FEE_FLAG = 0x01;\n    bytes1 private constant _INTEGRATOR_FEE_FLAG = 0x02;\n    bytes1 private constant _CUSTOM_RECEIVER_FLAG = 0x04;\n    uint256 private constant _WHITELIST_SHIFT = 3;\n\n    /**\n     * @notice Checks if the resolver fee is enabled\n     * @param extraData Data to be processed in the extension\n     * @return True if the resolver fee is enabled\n     */\n    function resolverFeeEnabled(bytes calldata extraData) internal pure returns (bool) {\n        return extraData[extraData.length - 1] & _RESOLVER_FEE_FLAG == _RESOLVER_FEE_FLAG;\n    }\n\n    /**\n     * @notice Checks if the integrator fee is enabled\n     * @param extraData Data to be processed in the extension\n     * @return True if the integrator fee is enabled\n     */\n    function integratorFeeEnabled(bytes calldata extraData) internal pure returns (bool) {\n        return extraData[extraData.length - 1] & _INTEGRATOR_FEE_FLAG == _INTEGRATOR_FEE_FLAG;\n    }\n\n    /**\n     * @notice Checks if the custom receiver is enabled\n     * @param extraData Data to be processed in the extension\n     * @return True if the custom receiver is specified\n     */\n    function hasCustomReceiver(bytes calldata extraData) internal pure returns (bool) {\n        return extraData[extraData.length - 1] & _CUSTOM_RECEIVER_FLAG == _CUSTOM_RECEIVER_FLAG;\n    }\n\n    /**\n     * @notice Gets the number of resolvers in the whitelist\n     * @param extraData Data to be processed in the extension\n     * @return The number of resolvers in the whitelist\n     */\n    function resolversCount(bytes calldata extraData) internal pure returns (uint256) {\n        return uint8(extraData[extraData.length - 1]) >> _WHITELIST_SHIFT;\n    }\n}\n"
    },
    "contracts/1inch/limit-order-settlement/extensions/ResolverValidationExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IOrderMixin } from \"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\";\nimport { FeeBankCharger } from \"../FeeBankCharger.sol\";\nimport { BaseExtension } from \"./BaseExtension.sol\";\nimport { ExtensionLib } from \"./ExtensionLib.sol\";\n\n/**\n * @title Resolver Validation Extension\n * @notice This abstract contract combines functionalities to enhance security and compliance in the order execution process.\n * Ensures that only transactions from whitelisted resolvers or resolvers who own specific accessToken are processed within the post-interaction phase of order execution.\n * Additionally, it allows charging a fee to resolvers in the `postInteraction` method, providing a mechanism for resolver fee management.\n */\nabstract contract ResolverValidationExtension is BaseExtension, FeeBankCharger {\n    using ExtensionLib for bytes;\n\n    error ResolverCanNotFillOrder();\n\n    uint256 private constant _ORDER_FEE_BASE_POINTS = 1e15;\n    /// @notice Contract address whose tokens allow filling limit orders with a fee for resolvers that are outside the whitelist\n    IERC20 private immutable _ACCESS_TOKEN;\n\n    constructor(IERC20 feeToken, IERC20 accessToken, address owner) FeeBankCharger(feeToken, owner) {\n        _ACCESS_TOKEN = accessToken;\n    }\n\n    /**\n     * @dev Validates whether the resolver is whitelisted.\n     * @param allowedTime The time after which interaction with the order is allowed.\n     * @param whitelist Whitelist is tightly packed struct of the following format:\n     * ```\n     * (bytes10,bytes2)[N] resolversAddressesAndTimeDeltas;\n     * ```\n     * Resolvers in the list are sorted in ascending order by the time when they are allowed to interact with the order.\n     * Time deltas represent the time in seconds between the adjacent resolvers.\n     * Only 10 lowest bytes of the resolver address are used for comparison.\n     * @param whitelistSize The amount of resolvers in the whitelist.\n     * @param resolver The resolver to check.\n     * @return Whether the resolver is whitelisted.\n     */\n    function _isWhitelisted(\n        uint256 allowedTime,\n        bytes calldata whitelist,\n        uint256 whitelistSize,\n        address resolver\n    ) internal view virtual returns (bool) {\n        unchecked {\n            uint80 maskedResolverAddress = uint80(uint160(resolver));\n            for (uint256 i = 0; i < whitelistSize; i++) {\n                uint80 whitelistedAddress = uint80(bytes10(whitelist[:10]));\n                allowedTime += uint16(bytes2(whitelist[10:12])); // add next time delta\n                if (maskedResolverAddress == whitelistedAddress) {\n                    return allowedTime <= block.timestamp;\n                } else if (allowedTime > block.timestamp) {\n                    return false;\n                }\n                whitelist = whitelist[12:];\n            }\n            return false;\n        }\n    }\n\n    /**\n     * @dev Calculates the resolver fee.\n     * @param fee Scaled resolver fee.\n     * @param orderMakingAmount Making amount from the order.\n     * @param actualMakingAmount Making amount that was actually filled.\n     * @return resolverFee Calculated resolver fee.\n     */\n    function _getResolverFee(\n        uint256 fee,\n        uint256 orderMakingAmount,\n        uint256 actualMakingAmount\n    ) internal pure virtual returns (uint256) {\n        return (fee * _ORDER_FEE_BASE_POINTS * actualMakingAmount) / orderMakingAmount;\n    }\n\n    /**\n     * @param extraData Structured data of length n bytes, segmented as follows:\n     * [0:4] - Resolver fee information.\n     * [4:8] - The time after which interaction with the order is allowed.\n     * [8:k] - Data as defined by the `whitelist` parameter for the `_isWhitelisted` method,\n     *         where k depends on the amount of resolvers in the whitelist, as indicated by the bitmap in the last byte.\n     * [k:n] - ExtraData for other extensions, not utilized by this validation extension.\n     * [n] - Bitmap indicating various usage flags and values.\n     *       The bitmask xxxx xxx1 signifies resolver fee usage.\n     *       The bitmask VVVV Vxxx represents the number of resolvers in the whitelist, where the V bits denote the count of resolvers.\n     *       The remaining bits in this bitmap are not used by this extension.\n     */\n    function _postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) internal virtual override {\n        bool feeEnabled = extraData.resolverFeeEnabled();\n        uint256 resolversCount = extraData.resolversCount();\n        unchecked {\n            uint256 resolverFee;\n            if (feeEnabled) {\n                resolverFee = _getResolverFee(uint256(uint32(bytes4(extraData[:4]))), order.makingAmount, makingAmount);\n                extraData = extraData[4:];\n            }\n\n            uint256 allowedTime = uint32(bytes4(extraData[0:4]));\n            extraData = extraData[4:];\n            uint256 whitelistSize = resolversCount * 12;\n            if (!_isWhitelisted(allowedTime, extraData[:whitelistSize], resolversCount, taker)) {\n                // resolversCount always > 0 on prod\n                if (allowedTime > block.timestamp || _ACCESS_TOKEN.balanceOf(taker) == 0)\n                    revert ResolverCanNotFillOrder();\n                if (feeEnabled) {\n                    _chargeFee(taker, resolverFee);\n                }\n            }\n            super._postInteraction(\n                order,\n                extension,\n                orderHash,\n                taker,\n                makingAmount,\n                takingAmount,\n                remainingMakingAmount,\n                extraData[whitelistSize:]\n            );\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-settlement/FeeBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport { UniERC20 } from \"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IFeeBankCharger } from \"./interfaces/IFeeBankCharger.sol\";\nimport { IFeeBank } from \"./interfaces/IFeeBank.sol\";\n\n/**\n * @title FeeBank\n * @notice FeeBank contract introduces a credit system for paying fees.\n * A user can deposit tokens to the FeeBank contract, obtain credits and then use them to pay fees.\n * @dev FeeBank is coupled with FeeBankCharger to actually charge fees.\n */\ncontract FeeBank is IFeeBank, Ownable {\n    using SafeERC20 for IERC20;\n    using UniERC20 for IERC20;\n\n    error ZeroAddress();\n\n    IERC20 private immutable _FEE_TOKEN;\n    IFeeBankCharger private immutable _CHARGER;\n\n    mapping(address account => uint256 availableCredit) private _accountDeposits;\n\n    constructor(IFeeBankCharger charger, IERC20 feeToken, address owner) Ownable(owner) {\n        if (address(feeToken) == address(0)) revert ZeroAddress();\n        _CHARGER = charger;\n        _FEE_TOKEN = feeToken;\n    }\n\n    /**\n     * @notice See {IFeeBank-availableCredit}.\n     */\n    function availableCredit(address account) external view returns (uint256) {\n        return _CHARGER.availableCredit(account);\n    }\n\n    /**\n     * @notice See {IFeeBank-deposit}.\n     */\n    function deposit(uint256 amount) external returns (uint256) {\n        return _depositFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice See {IFeeBank-depositFor}.\n     */\n    function depositFor(address account, uint256 amount) external returns (uint256) {\n        return _depositFor(account, amount);\n    }\n\n    /**\n     * @notice See {IFeeBank-depositWithPermit}.\n     */\n    function depositWithPermit(uint256 amount, bytes calldata permit) external returns (uint256) {\n        return depositForWithPermit(msg.sender, amount, permit);\n    }\n\n    /**\n     * @notice See {IFeeBank-depositForWithPermit}.\n     */\n    function depositForWithPermit(address account, uint256 amount, bytes calldata permit) public returns (uint256) {\n        _FEE_TOKEN.safePermit(permit);\n        return _depositFor(account, amount);\n    }\n\n    /**\n     * @notice See {IFeeBank-withdraw}.\n     */\n    function withdraw(uint256 amount) external returns (uint256) {\n        return _withdrawTo(msg.sender, amount);\n    }\n\n    /**\n     * @notice See {IFeeBank-withdrawTo}.\n     */\n    function withdrawTo(address account, uint256 amount) external returns (uint256) {\n        return _withdrawTo(account, amount);\n    }\n\n    /**\n     * @notice Admin method returns commissions spent by users.\n     * @param accounts Accounts whose commissions are being withdrawn.\n     * @return totalAccountFees The total amount of accounts commissions.\n     */\n    function gatherFees(address[] calldata accounts) external onlyOwner returns (uint256 totalAccountFees) {\n        uint256 accountsLength = accounts.length;\n        unchecked {\n            for (uint256 i = 0; i < accountsLength; ++i) {\n                address account = accounts[i];\n                uint256 accountDeposit = _accountDeposits[account];\n                uint256 availableCredit_ = _CHARGER.availableCredit(account);\n                _accountDeposits[account] = availableCredit_;\n                totalAccountFees += accountDeposit - availableCredit_; // overflow is impossible due to checks in FeeBankCharger\n            }\n        }\n        _FEE_TOKEN.safeTransfer(msg.sender, totalAccountFees);\n    }\n\n    function _depositFor(address account, uint256 amount) internal returns (uint256 totalAvailableCredit) {\n        if (account == address(0)) revert ZeroAddress();\n        _FEE_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\n        unchecked {\n            _accountDeposits[account] += amount; // overflow is impossible due to limited _FEE_TOKEN supply\n        }\n        totalAvailableCredit = _CHARGER.increaseAvailableCredit(account, amount);\n    }\n\n    function _withdrawTo(address account, uint256 amount) internal returns (uint256 totalAvailableCredit) {\n        totalAvailableCredit = _CHARGER.decreaseAvailableCredit(msg.sender, amount);\n        unchecked {\n            _accountDeposits[msg.sender] -= amount; // underflow is impossible due to checks in FeeBankCharger\n        }\n        _FEE_TOKEN.safeTransfer(account, amount);\n    }\n\n    /**\n     * @notice Retrieves funds accidently sent directly to the contract address\n     * @param token ERC20 token to retrieve\n     * @param amount amount to retrieve\n     */\n    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {\n        token.uniTransfer(payable(msg.sender), amount);\n    }\n}\n"
    },
    "contracts/1inch/limit-order-settlement/FeeBankCharger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IFeeBank } from \"./interfaces/IFeeBank.sol\";\nimport { IFeeBankCharger } from \"./interfaces/IFeeBankCharger.sol\";\nimport { FeeBank } from \"./FeeBank.sol\";\n\n/**\n * @title FeeBankCharger\n * @notice FeeBankCharger contract implements logic to increase or decrease users' credits in FeeBank.\n */\ncontract FeeBankCharger is IFeeBankCharger {\n    error OnlyFeeBankAccess();\n    error NotEnoughCredit();\n\n    /**\n     * @notice See {IFeeBankCharger-feeBank}.\n     */\n    IFeeBank public immutable FEE_BANK;\n    mapping(address => uint256) private _creditAllowance;\n\n    /**\n     * @dev Modifier to check if the sender is a FEE_BANK contract.\n     */\n    modifier onlyFeeBank() {\n        if (msg.sender != address(FEE_BANK)) revert OnlyFeeBankAccess();\n        _;\n    }\n\n    constructor(IERC20 feeToken, address owner) {\n        FEE_BANK = new FeeBank(this, feeToken, owner);\n    }\n\n    /**\n     * @notice See {IFeeBankCharger-availableCredit}.\n     */\n    function availableCredit(address account) external view returns (uint256) {\n        return _creditAllowance[account];\n    }\n\n    /**\n     * @notice See {IFeeBankCharger-increaseAvailableCredit}.\n     */\n    function increaseAvailableCredit(address account, uint256 amount) external onlyFeeBank returns (uint256 allowance) {\n        allowance = _creditAllowance[account];\n        unchecked {\n            allowance += amount; // overflow is impossible due to limited _token supply\n        }\n        _creditAllowance[account] = allowance;\n    }\n\n    /**\n     * @notice See {IFeeBankCharger-decreaseAvailableCredit}.\n     */\n    function decreaseAvailableCredit(address account, uint256 amount) external onlyFeeBank returns (uint256 allowance) {\n        return _creditAllowance[account] -= amount; // checked math is needed to prevent underflow\n    }\n\n    /**\n     * @notice Internal function that charges a specified fee from a given account's credit allowance.\n     * @dev Reverts with 'NotEnoughCredit' if the account's credit allowance is insufficient to cover the fee.\n     * @param account The address of the account from which the fee is being charged.\n     * @param fee The amount of fee to be charged from the account.\n     */\n    function _chargeFee(address account, uint256 fee) internal virtual {\n        if (fee > 0) {\n            uint256 currentAllowance = _creditAllowance[account];\n            if (currentAllowance < fee) revert NotEnoughCredit();\n            unchecked {\n                _creditAllowance[account] = currentAllowance - fee;\n            }\n        }\n    }\n}\n"
    },
    "contracts/1inch/limit-order-settlement/interfaces/IFeeBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IFeeBank {\n    /**\n     * @notice Returns the available credit for a given account in the FeeBank contract.\n     * @param account The address of the account for which the available credit is being queried.\n     * @return availableCredit The available credit of the queried account.\n     */\n    function availableCredit(address account) external view returns (uint256 availableCredit);\n\n    /**\n     * @notice Increases the caller's available credit by the specified amount.\n     * @param amount The amount of credit to be added to the caller's account.\n     * @return totalAvailableCredit The updated available credit of the caller's account.\n     */\n    function deposit(uint256 amount) external returns (uint256 totalAvailableCredit);\n\n    /**\n     * @notice Increases the specified account's available credit by the specified amount.\n     * @param account The address of the account for which the available credit is being increased.\n     * @param amount The amount of credit to be added to the account.\n     * @return totalAvailableCredit The updated available credit of the specified account.\n     */\n    function depositFor(address account, uint256 amount) external returns (uint256 totalAvailableCredit);\n\n    /**\n     * @notice Increases the caller's available credit by a specified amount with permit.\n     * @param amount The amount of credit to be added to the caller's account.\n     * @param permit The permit data authorizing the transaction.\n     * @return totalAvailableCredit The updated available credit of the caller's account.\n     */\n    function depositWithPermit(uint256 amount, bytes calldata permit) external returns (uint256 totalAvailableCredit);\n\n    /**\n     * @notice Increases the specified account's available credit by a specified amount with permit.\n     * @param account The address of the account for which the available credit is being increased.\n     * @param amount The amount of credit to be added to the account.\n     * @param permit The permit data authorizing the transaction.\n     * @return totalAvailableCredit The updated available credit of the specified account.\n     */\n    function depositForWithPermit(\n        address account,\n        uint256 amount,\n        bytes calldata permit\n    ) external returns (uint256 totalAvailableCredit);\n\n    /**\n     * @notice Withdraws a specified amount of credit from the caller's account.\n     * @param amount The amount of credit to be withdrawn from the caller's account.\n     * @return totalAvailableCredit The updated available credit of the caller's account.\n     */\n    function withdraw(uint256 amount) external returns (uint256 totalAvailableCredit);\n\n    /**\n     * @notice Withdraws a specified amount of credit to the specified account.\n     * @param account The address of the account to which the credit is being withdrawn.\n     * @param amount The amount of credit to be withdrawn.\n     * @return totalAvailableCredit The updated available credit of the caller's account.\n     */\n    function withdrawTo(address account, uint256 amount) external returns (uint256 totalAvailableCredit);\n}\n"
    },
    "contracts/1inch/limit-order-settlement/interfaces/IFeeBankCharger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IFeeBank } from \"./IFeeBank.sol\";\n\ninterface IFeeBankCharger {\n    /**\n     * @notice Returns the instance of the FeeBank contract.\n     * @return The instance of the FeeBank contract.\n     */\n    function FEE_BANK() external view returns (IFeeBank); // solhint-disable-line func-name-mixedcase\n\n    /**\n     * @notice Returns the available credit for a given account.\n     * @param account The address of the account for which the available credit is being queried.\n     * @return The available credit of the queried account.\n     */\n    function availableCredit(address account) external view returns (uint256);\n\n    /**\n     * @notice Increases the available credit of a given account by a specified amount.\n     * @param account The address of the account for which the available credit is being increased.\n     * @param amount The amount by which the available credit will be increased.\n     * @return allowance The updated available credit of the specified account.\n     */\n    function increaseAvailableCredit(address account, uint256 amount) external returns (uint256 allowance);\n\n    /**\n     * @notice Decreases the available credit of a given account by a specified amount.\n     * @param account The address of the account for which the available credit is being decreased.\n     * @param amount The amount by which the available credit will be decreased.\n     * @return allowance The updated available credit of the specified account.\n     */\n    function decreaseAvailableCredit(address account, uint256 amount) external returns (uint256 allowance);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}