{
  "address": "0x9ad8aD2458dD3D1B440F0216C78c354e84F8C75c",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "limitOrderProtocol",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "feeToken",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "accessToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "rescueDelaySrc",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "rescueDelayDst",
          "type": "uint32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AccessDenied",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC1167FailedCreateClone",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientEscrowBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCreationTime",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPartialFill",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidProof",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSecretsAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MathOverflowedMulDiv",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotEnoughCredit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyFeeBankAccess",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyLimitOrderProtocol",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ResolverCanNotFillOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeTransferFromFailed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "escrow",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "hashlock",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "Address",
          "name": "taker",
          "type": "uint256"
        }
      ],
      "name": "DstEscrowCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "hashlock",
              "type": "bytes32"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "taker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "token",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "safetyDeposit",
              "type": "uint256"
            },
            {
              "internalType": "Timelocks",
              "name": "timelocks",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct IBaseEscrow.Immutables",
          "name": "srcImmutables",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "token",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "safetyDeposit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct IEscrowFactory.DstImmutablesComplement",
          "name": "dstImmutablesComplement",
          "type": "tuple"
        }
      ],
      "name": "SrcEscrowCreated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ESCROW_DST_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ESCROW_SRC_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FEE_BANK",
      "outputs": [
        {
          "internalType": "contract IFeeBank",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "hashlock",
              "type": "bytes32"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "taker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "token",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "safetyDeposit",
              "type": "uint256"
            },
            {
              "internalType": "Timelocks",
              "name": "timelocks",
              "type": "uint256"
            }
          ],
          "internalType": "struct IBaseEscrow.Immutables",
          "name": "immutables",
          "type": "tuple"
        }
      ],
      "name": "addressOfEscrowDst",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "hashlock",
              "type": "bytes32"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "taker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "token",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "safetyDeposit",
              "type": "uint256"
            },
            {
              "internalType": "Timelocks",
              "name": "timelocks",
              "type": "uint256"
            }
          ],
          "internalType": "struct IBaseEscrow.Immutables",
          "name": "immutables",
          "type": "tuple"
        }
      ],
      "name": "addressOfEscrowSrc",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "availableCredit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "hashlock",
              "type": "bytes32"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "taker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "token",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "safetyDeposit",
              "type": "uint256"
            },
            {
              "internalType": "Timelocks",
              "name": "timelocks",
              "type": "uint256"
            }
          ],
          "internalType": "struct IBaseEscrow.Immutables",
          "name": "dstImmutables",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "srcCancellationTimestamp",
          "type": "uint256"
        }
      ],
      "name": "createDstEscrow",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "decreaseAvailableCredit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "allowance",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "takingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "getMakingAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "makingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "getTakingAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "increaseAvailableCredit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "allowance",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "lastValidated",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "leaf",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "extension",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "taker",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "makingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "takingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingMakingAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "postInteraction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "extension",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "taker",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "makingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "takingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingMakingAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "preInteraction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "extension",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "takerInteraction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe953e4c843782f9bdd43d57e7eab9fb2aea6be3a30c8fbbc9fde6c8ed81a56dc",
  "receipt": {
    "to": null,
    "from": "0x622DfAaf7443aA6fE0b6b106D3a68CAD0754b749",
    "contractAddress": "0x9ad8aD2458dD3D1B440F0216C78c354e84F8C75c",
    "transactionIndex": 81,
    "gasUsed": "3125005",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000400000000000000000000000000000000020000000000000000000800400000000000000008000000000000400000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000004000000000000000000000000000000000000000000000",
    "blockHash": "0x6a899a6b129545ae92d4414c4986cd27e26d109a96c10a8ef1a6c80003c02f64",
    "transactionHash": "0xe953e4c843782f9bdd43d57e7eab9fb2aea6be3a30c8fbbc9fde6c8ed81a56dc",
    "logs": [
      {
        "transactionIndex": 81,
        "blockNumber": 8855030,
        "transactionHash": "0xe953e4c843782f9bdd43d57e7eab9fb2aea6be3a30c8fbbc9fde6c8ed81a56dc",
        "address": "0x09fB0De0DAe705E7637B1aC0a2Faf0C11771B674",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000622dfaaf7443aa6fe0b6b106d3a68cad0754b749"
        ],
        "data": "0x",
        "logIndex": 174,
        "blockHash": "0x6a899a6b129545ae92d4414c4986cd27e26d109a96c10a8ef1a6c80003c02f64"
      }
    ],
    "blockNumber": 8855030,
    "cumulativeGasUsed": "12353336",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x0b9aD27E24A17e9cFE5eDD2455238612189F0A48",
    "0x9d42A3E42eb5CC7D47DeE5f74E15f48f31A9a691",
    "0x9d42A3E42eb5CC7D47DeE5f74E15f48f31A9a691",
    "0x622DfAaf7443aA6fE0b6b106D3a68CAD0754b749",
    691200,
    691200
  ],
  "numDeployments": 1,
  "solcInputHash": "151ca025e0eb3f6507b85580d4a552ec",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"limitOrderProtocol\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"accessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"rescueDelaySrc\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"rescueDelayDst\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEscrowBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCreationTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPartialFill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecretsAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughCredit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyFeeBankAccess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyLimitOrderProtocol\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ResolverCanNotFillOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"escrow\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"}],\"name\":\"DstEscrowCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"srcImmutables\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IEscrowFactory.DstImmutablesComplement\",\"name\":\"dstImmutablesComplement\",\"type\":\"tuple\"}],\"name\":\"SrcEscrowCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ESCROW_DST_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ESCROW_SRC_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_BANK\",\"outputs\":[{\"internalType\":\"contract IFeeBank\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"addressOfEscrowDst\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"addressOfEscrowSrc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"dstImmutables\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"srcCancellationTimestamp\",\"type\":\"uint256\"}],\"name\":\"createDstEscrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAvailableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"getMakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"getTakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAvailableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"lastValidated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"extension\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingMakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"postInteraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"extension\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingMakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"preInteraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"extension\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"takerInteraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"errors\":{\"ERC1167FailedCreateClone()\":[{\"details\":\"A clone instance deployment failed.\"}],\"MathOverflowedMulDiv()\":[{\"details\":\"Muldiv operation overflow.\"}]},\"events\":{\"DstEscrowCreated(address,bytes32,uint256)\":{\"params\":{\"escrow\":\"The address of the created escrow.\",\"hashlock\":\"The hash of the secret.\",\"taker\":\"The address of the taker.\"}},\"SrcEscrowCreated((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256))\":{\"params\":{\"dstImmutablesComplement\":\"Additional immutables related to the escrow contract on the destination chain.\",\"srcImmutables\":\"The immutables of the escrow contract that are used in deployment on the source chain.\"}}},\"kind\":\"dev\",\"methods\":{\"takerInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)\":{\"details\":\"Verifies the proof and stores the last validated index and hashed secret. Only Limit Order Protocol can call this function.\"}},\"title\":\"Escrow Factory contract\",\"version\":1},\"userdoc\":{\"events\":{\"DstEscrowCreated(address,bytes32,uint256)\":{\"notice\":\"Emitted on EscrowDst deployment.\"},\"SrcEscrowCreated((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Emitted on EscrowSrc deployment to recreate EscrowSrc and EscrowDst immutables off-chain.\"}},\"kind\":\"user\",\"methods\":{\"ESCROW_DST_IMPLEMENTATION()\":{\"notice\":\"See {IEscrowFactory-ESCROW_DST_IMPLEMENTATION}.\"},\"ESCROW_SRC_IMPLEMENTATION()\":{\"notice\":\"See {IEscrowFactory-ESCROW_SRC_IMPLEMENTATION}.\"},\"FEE_BANK()\":{\"notice\":\"See {IFeeBankCharger-feeBank}.\"},\"addressOfEscrowDst((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IEscrowFactory-addressOfEscrowDst}.\"},\"addressOfEscrowSrc((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IEscrowFactory-addressOfEscrowSrc}.\"},\"availableCredit(address)\":{\"notice\":\"See {IFeeBankCharger-availableCredit}.\"},\"createDstEscrow((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256),uint256)\":{\"notice\":\"See {IEscrowFactory-createDstEscrow}.\"},\"decreaseAvailableCredit(address,uint256)\":{\"notice\":\"See {IFeeBankCharger-decreaseAvailableCredit}.\"},\"getMakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)\":{\"notice\":\"See {IAmountGetter-getMakingAmount}\"},\"getTakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)\":{\"notice\":\"See {IAmountGetter-getTakingAmount}\"},\"increaseAvailableCredit(address,uint256)\":{\"notice\":\"See {IFeeBankCharger-increaseAvailableCredit}.\"},\"lastValidated(bytes32)\":{\"notice\":\"See {IMerkleStorageInvalidator-lastValidated}.\"},\"postInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)\":{\"notice\":\"See {IPostInteraction-postInteraction}\"},\"preInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)\":{\"notice\":\"See {IPreInteraction-preInteraction}\"},\"takerInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)\":{\"notice\":\"See {ITakerInteraction-takerInteraction}.\"}},\"notice\":\"Contract to create escrow contracts for cross-chain atomic swap.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/1inch/cross-chain-swap/EscrowFactory.sol\":\"EscrowFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\n/**\\n * @title IAmountGetter\\n * @notice Interface for external logic to determine actual making and taking amounts for orders.\\n */\\ninterface IAmountGetter {\\n    /**\\n     * @notice View method that gets called to determine the actual making amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return makingAmount Actual making amount that should be used for the order\\n     */\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice View method that gets called to determine the actual taking amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return takingAmount Actual taking amount that should be used for the order\\n     */\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd2f5f477d812411a2eee26d645cd096b256221862fcf4a004128f7bdd43a6e08\",\"license\":\"MIT\"},\"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport \\\"../libraries/MakerTraitsLib.sol\\\";\\nimport \\\"../libraries/TakerTraitsLib.sol\\\";\\n\\n/**\\n * @title IOrderMixin\\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\\n */\\ninterface IOrderMixin {\\n    struct Order {\\n        uint256 salt;\\n        Address maker;\\n        Address receiver;\\n        Address makerAsset;\\n        Address takerAsset;\\n        uint256 makingAmount;\\n        uint256 takingAmount;\\n        MakerTraits makerTraits;\\n    }\\n\\n    error InvalidatedOrder();\\n    error TakingAmountExceeded();\\n    error PrivateOrder();\\n    error BadSignature();\\n    error OrderExpired();\\n    error WrongSeriesNonce();\\n    error SwapWithZeroAmount();\\n    error PartialFillNotAllowed();\\n    error OrderIsNotSuitableForMassInvalidation();\\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\\n    error ReentrancyDetected();\\n    error PredicateIsNotTrue();\\n    error TakingAmountTooHigh();\\n    error MakingAmountTooLow();\\n    error TransferFromMakerToTakerFailed();\\n    error TransferFromTakerToMakerFailed();\\n    error MismatchArraysLengths();\\n    error InvalidPermit2Transfer();\\n    error SimulationResults(bool success, bytes res);\\n\\n    /**\\n     * @notice Emitted when order gets filled\\n     * @param orderHash Hash of the order\\n     * @param remainingAmount Amount of the maker asset that remains to be filled\\n     */\\n    event OrderFilled(\\n        bytes32 orderHash,\\n        uint256 remainingAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\\n     * @param orderHash Hash of the order\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash\\n    );\\n\\n    /**\\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\\n     * @param maker Maker address\\n     * @param slotIndex Slot index that was updated\\n     * @param slotValue New slot value\\n     */\\n    event BitInvalidatorUpdated(\\n        address indexed maker,\\n        uint256 slotIndex,\\n        uint256 slotValue\\n    );\\n\\n    /**\\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\\n     * @dev The function always reverts and returns the simulation results in revert data.\\n     * @param target Addresses that will be delegated\\n     * @param data Data that will be passed to delegatee\\n     */\\n    function simulate(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Cancels order's quote\\n     * @param makerTraits Order makerTraits\\n     * @param orderHash Hash of the order to cancel\\n     */\\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\\n\\n    /**\\n     * @notice Cancels orders' quotes\\n     * @param makerTraits Orders makerTraits\\n     * @param orderHashes Hashes of the orders to cancel\\n     */\\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\\n\\n    /**\\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\\n     * @param makerTraits Order makerTraits\\n     * @param additionalMask Additional bitmask to invalidate orders\\n     */\\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\\n\\n    /**\\n     * @notice Fills order's quote, fully or partially (whichever is possible).\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrder(\\n        Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrderArgs(\\n        IOrderMixin.Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but uses contract-based signatures.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrder(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrderArgs(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param maker Maker address\\n     * @param slot Slot number to return bitmask for\\n     * @return result Each bit represents whether corresponding was already invalidated\\n     */\\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remaining Remaining amount of the order\\n     */\\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\\n     */\\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\\n\\n    /**\\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\\n     * @param order Order\\n     * @return orderHash Hash of the order\\n     */\\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\\n}\\n\",\"keccak256\":\"0x39cfb84ae74a276eae63d7b3be898104045f98163405190227ddae3e85f6dd11\",\"license\":\"MIT\"},\"@1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\ninterface IPostInteraction {\\n    /**\\n     * @notice Callback method that gets called after all fund transfers\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual making amount\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     */\\n    function postInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x16a7386f4277240ad30942611a576865ce4ef13b38f6cb8d34f1bbb4c1211434\",\"license\":\"MIT\"},\"@1inch/limit-order-protocol-contract/contracts/interfaces/IPreInteraction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\ninterface IPreInteraction {\\n    /**\\n     * @notice Callback method that gets called before any funds transfers\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual making amount\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     */\\n    function preInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x5d6e5cfb9e02464727cc5268682fb4cdb870c3ef73a775852cc17b42c9932e23\",\"license\":\"MIT\"},\"@1inch/limit-order-protocol-contract/contracts/libraries/MakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype MakerTraits is uint256;\\n\\n/**\\n * @title MakerTraitsLib\\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\\n * @dev\\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\\n * High bits are used for flags\\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\\n * 253 bit                                  - unused\\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\\n\\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n * uint80 last 10 bytes of allowed sender address (0 if any)\\n * uint40 expiration timestamp (0 if none)\\n * uint40 nonce or epoch\\n * uint40 series\\n */\\nlibrary MakerTraitsLib {\\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\\n    uint256 private constant _EXPIRATION_OFFSET = 80;\\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\\n    uint256 private constant _SERIES_OFFSET = 160;\\n    uint256 private constant _SERIES_MASK = type(uint40).max;\\n\\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\\n\\n    /**\\n     * @notice Checks if the order has the extension flag set.\\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the flag is set.\\n     */\\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker allows a specific taker to fill the order.\\n     * @param makerTraits The traits of the maker.\\n     * @param sender The address of the taker to be checked.\\n     * @return result A boolean indicating whether the taker is allowed.\\n     */\\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the expiration time of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The expiration timestamp of the order.\\n     */\\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the order has expired.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the order has expired.\\n     */\\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\\n        uint256 expiration = getExpirationTime(makerTraits);\\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Returns the nonce or epoch of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The nonce or epoch of the order.\\n     */\\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the series of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The series of the order.\\n     */\\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows partial fills.\\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows partial fills.\\n      */\\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs pre-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\\n     */\\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs post-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\\n     */\\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows multiple fills.\\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows multiple fills.\\n      */\\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the bit invalidator should be used.\\n      * True if the order requires the use of the bit invalidator.\\n      */\\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to check the epoch.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\\n     */\\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker uses permit2.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker uses permit2.\\n     */\\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to unwraps WETH.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\\n     */\\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9506febc99293a286356a03cb150ad82ccb88be1b4c908183e1273b41fcb902c\",\"license\":\"MIT\"},\"@1inch/limit-order-protocol-contract/contracts/libraries/TakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype TakerTraits is uint256;\\n\\n/**\\n * @title TakerTraitsLib\\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\\n * @dev The TakerTraits are structured as follows:\\n * High bits are used for flags\\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker\\u2019s funds transfer.\\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\\n */\\nlibrary TakerTraitsLib {\\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\\n\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\\n\\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Checks if the args should contain target address.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the args should contain target address.\\n     */\\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the extension calldata encoded in the takerTraits.\\n     */\\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the interaction calldata encoded in the takerTraits.\\n     */\\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the taking amount should be calculated based on making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\\n     */\\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order should unwrap WETH.\\n     */\\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should skip maker's permit execution.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order don't apply permit.\\n     */\\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order uses the permit2 instead of permit.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order uses the permit2.\\n     */\\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the threshold amount from the takerTraits.\\n     * The maximum amount a taker agrees to give in exchange for a making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The threshold amount encoded in the takerTraits.\\n     */\\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x144f154a46e8daa0fec5b8215f1d8d3b694cb939236aa7bf89976b27965c2837\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDaiLikePermit\\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\\n */\\ninterface IDaiLikePermit {\\n    /**\\n     * @notice Approves spending of tokens via off-chain signatures.\\n     * @param holder Token holder's address.\\n     * @param spender Spender's address.\\n     * @param nonce Current nonce of the holder.\\n     * @param expiry Time when the permit expires.\\n     * @param allowed True to allow, false to disallow spending.\\n     * @param v, r, s Signature components.\\n     */\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xf8636c1c4631641c7b40ac65cd69e6ae04a99cf3358426c642dec02c6c774c82\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IERC20MetadataUppercase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC20MetadataUppercase\\n * @dev Interface for ERC20 token metadata with uppercase naming convention.\\n */\\ninterface IERC20MetadataUppercase {\\n    /**\\n     * @notice Gets the token name.\\n     * @return Token name.\\n     */\\n    function NAME() external view returns (string memory); // solhint-disable-line func-name-mixedcase\\n\\n    /**\\n     * @notice Gets the token symbol.\\n     * @return Token symbol.\\n     */\\n    function SYMBOL() external view returns (string memory); // solhint-disable-line func-name-mixedcase\\n}\\n\",\"keccak256\":\"0x7d97ae2903bd1ee8f24ab7bbf099d075f2bbd451b0f755366479d249780d0c68\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC7597Permit\\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\\n */\\ninterface IERC7597Permit {\\n    /**\\n     * @notice Update allowance with a signed permit.\\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\\n     * @param owner Token owner's address (Authorizer).\\n     * @param spender Spender's address.\\n     * @param value Amount of allowance.\\n     * @param deadline The time at which the signature expires (unixtime).\\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) external;\\n}\\n\",\"keccak256\":\"0xaf148ecd4db0f44989a7417f6945bcfd18273c5096bc2b364e314e42c85c78cd\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPermit2\\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\\n */\\ninterface IPermit2 {\\n    /**\\n     * @dev Struct for holding permit details.\\n     * @param token ERC20 token address for which the permit is issued.\\n     * @param amount The maximum amount allowed to spend.\\n     * @param expiration Timestamp until which the permit is valid.\\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\\n     */\\n    struct PermitDetails {\\n        address token;\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @dev Struct for a single token allowance permit.\\n     * @param details Permit details including token, amount, expiration, and nonce.\\n     * @param spender Address authorized to spend the tokens.\\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\\n     */\\n    struct PermitSingle {\\n        PermitDetails details;\\n        address spender;\\n        uint256 sigDeadline;\\n    }\\n\\n    /**\\n     * @dev Struct for packed allowance data to optimize storage.\\n     * @param amount Amount allowed.\\n     * @param expiration Permission expiry timestamp.\\n     * @param nonce Unique incrementing value for tracking allowances.\\n     */\\n    struct PackedAllowance {\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @notice Executes a token transfer from one address to another.\\n     * @param user The token owner's address.\\n     * @param spender The address authorized to spend the tokens.\\n     * @param amount The amount of tokens to transfer.\\n     * @param token The address of the token being transferred.\\n     */\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    /**\\n     * @notice Issues a permit for spending tokens via a signed authorization.\\n     * @param owner The token owner's address.\\n     * @param permitSingle Struct containing the permit details.\\n     * @param signature The signature proving the owner authorized the permit.\\n     */\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /**\\n     * @notice Retrieves the allowance details between a token owner and spender.\\n     * @param user The token owner's address.\\n     * @param token The token address.\\n     * @param spender The spender's address.\\n     * @return The packed allowance details.\\n     */\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n\\n    /**\\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\\n     * @param token The token to approve\\n     * @param spender The spender address to approve\\n     * @param amount The approved amount of the token\\n     * @param expiration The timestamp at which the approval is no longer valid\\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\\n     */\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\\n}\\n\",\"keccak256\":\"0x2ac37c62bb4a4941c1d353df6ac08750542c540234aa24409ac67373651a478a\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IWETH\\n * @dev Interface for wrapper as WETH-like token.\\n */\\ninterface IWETH is IERC20 {\\n    /**\\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\\n     */\\n    event Deposit(address indexed dst, uint256 wad);\\n\\n    /**\\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\\n     */\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    /**\\n     * @notice Deposit Ether to get wrapper tokens.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Withdraw wrapped tokens as Ether.\\n     * @param amount Amount of wrapped tokens to withdraw.\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x32989b79850e8a1ac6aab74878de2883f9537656ca06910dc0ae76833cc446e2\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype Address is uint256;\\n\\n/**\\n* @notice AddressLib\\n* @notice Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\\n*/\\nlibrary AddressLib {\\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\\n\\n    /**\\n    * @notice Returns the address representation of a uint256.\\n    * @param a The uint256 value to convert to an address.\\n    * @return The address representation of the provided uint256 value.\\n    */\\n    function get(Address a) internal pure returns (address) {\\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\\n    }\\n\\n    /**\\n    * @notice Checks if a given flag is set for the provided address.\\n    * @param a The address to check for the flag.\\n    * @param flag The flag to check for in the provided address.\\n    * @return True if the provided flag is set in the address, false otherwise.\\n    */\\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\\n        return (Address.unwrap(a) & flag) != 0;\\n    }\\n\\n    /**\\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint32 value.\\n    * @param offset The bit offset at which the uint32 value is stored.\\n    * @return The uint32 value stored in the address at the specified bit offset.\\n    */\\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\\n        return uint32(Address.unwrap(a) >> offset);\\n    }\\n\\n    /**\\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint64 value.\\n    * @param offset The bit offset at which the uint64 value is stored.\\n    * @return The uint64 value stored in the address at the specified bit offset.\\n    */\\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\\n        return uint64(Address.unwrap(a) >> offset);\\n    }\\n}\\n\",\"keccak256\":\"0xe860b410ed5371b9732daab80982eef0a42ae48474716a89725ca744e27b7d75\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RevertReasonForwarder\\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\\n */\\nlibrary RevertReasonForwarder {\\n    /**\\n     * @dev Forwards the revert reason from the latest external call.\\n     * This method allows propagating the revert reason of a failed external call to the caller.\\n     */\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the revert reason from the latest external call.\\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\\n     * @return reason The latest external call revert reason.\\n     */\\n    function reReason() internal pure returns (bytes memory reason) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            reason := mload(0x40)\\n            let length := returndatasize()\\n            mstore(reason, length)\\n            returndatacopy(add(reason, 0x20), 0, length)\\n            mstore(0x40, add(reason, add(0x20, length)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x97d8c950981f4da44ae1b01d9e597c4f99377797ec7ff7b1ef9648e4ecc1baa4\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IERC7597Permit.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/**\\n * @title Implements efficient safe methods for ERC20 interface.\\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\\n * 1. more gas-efficient, providing significant savings in transaction costs.\\n * 2. support for different permit implementations\\n * 3. forceApprove functionality\\n * 4. support for WETH deposit and withdraw\\n */\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    // Uniswap Permit2 address\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    address private constant _PERMIT2_ZKSYNC = 0x0000000000225e31D15943971F47aD3022F714Fa;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n\\n    /**\\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\\n     * Consumes less gas then regular `ERC20.balanceOf`.\\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\\n     * @param token The IERC20 token contract for which the balance will be fetched.\\n     * @param account The address of the account whose token balance will be fetched.\\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\\n     */\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another.\\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\\n     */\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 0x64, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        address permit2 = _getPermit2Address();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), permit2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(permit2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens to another address.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, amount)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely increases the allowance of a spender.\\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to increase the allowance by.\\n     */\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /**\\n     * @notice Safely decreases the allowance of a spender.\\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to decrease the allowance by.\\n     */\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param owner The owner of the tokens for which the permit is made.\\n     * @param spender The spender allowed to spend the tokens by the permit.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\\n     */\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    /**\\n     * @notice The function attempts to call the permit function on a given ERC20 token.\\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\\n     * It accommodates both Compact and Full formats of these permit types.\\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\\n     * before invocation for optimized performance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The address of the ERC20 token on which to call the permit function.\\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\\n     * @param spender The address which will be approved for transfer of tokens.\\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\\n     * @return success A boolean indicating whether the permit call was successful.\\n     */\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        address permit2 = _getPermit2Address();\\n        // load function selectors for different permit standards\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // Switch case for different permit lengths, indicating different permit standards\\n            switch permit.length\\n            // Compact IERC20Permit\\n            case 100 {\\n                mstore(ptr, permitSelector)     // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // Compact IDaiLikePermit\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)  // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // IERC20Permit\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // IDaiLikePermit\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // Compact IPermit2\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)  // store selector\\n                mstore(add(ptr, 0x04), owner) // store owner\\n                mstore(add(ptr, 0x24), token) // store token\\n\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\\n                mstore(add(ptr, 0xa4), spender)                               // store spender\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // IPermit2\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // Dynamic length\\n            default {\\n                mstore(ptr, erc7597PermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param selector The function signature that is to be called on the token contract.\\n     * @param to The address to which the token amount will be transferred.\\n     * @param amount The token amount to be transferred.\\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\\n     * In case of success but no returned data, validates that the contract code exists.\\n     * In case of returned data, ensures that it's a boolean `true`.\\n     */\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of Ether to deposit into the IWETH contract.\\n     */\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.deposit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\\n     * @dev Uses inline assembly to interact with the IWETH contract.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     */\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\\n     * Consumes less gas then regular `IWETH.withdraw`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     * @param to The recipient of the withdrawn Ether.\\n     */\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getPermit2Address() private view returns (address permit2) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            switch chainid()\\n            case 324 { // zksync mainnet\\n                permit2 := _PERMIT2_ZKSYNC\\n            }\\n            case 300 { // zksync testnet\\n                permit2 := _PERMIT2_ZKSYNC\\n            }\\n            case 260 { // zksync fork network\\n                permit2 := _PERMIT2_ZKSYNC\\n            }\\n            default {\\n                permit2 := _PERMIT2\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc756a120ac3a0271cdfd89db133335deaf31523a06a91ff00eb2be8656e9f85a\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/StringUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title StringUtil\\n * @dev Library with gas-efficient string operations.\\n */\\nlibrary StringUtil {\\n    /**\\n     * @notice Converts a uint256 value to its hexadecimal string representation.\\n     * @param value The uint256 value to convert.\\n     * @return The hexadecimal string representation of the input value.\\n     */\\n    function toHex(uint256 value) internal pure returns (string memory) {\\n        return toHex(abi.encodePacked(value));\\n    }\\n\\n    /**\\n     * @notice Converts an address to its hexadecimal string representation.\\n     * @param value The address to convert.\\n     * @return The hexadecimal string representation of the input address.\\n     */\\n    function toHex(address value) internal pure returns (string memory) {\\n        return toHex(abi.encodePacked(value));\\n    }\\n\\n    /**\\n     * @dev Converts arbitrary bytes to their hexadecimal string representation.\\n     * This is an assembly adaptation of highly optimized toHex16 code by Mikhail Vladimirov.\\n     * Reference: https://stackoverflow.com/a/69266989\\n     * @param data The bytes to be converted to hexadecimal string.\\n     * @return result The hexadecimal string representation of the input bytes.\\n     */\\n    function toHex(bytes memory data) internal pure returns (string memory result) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            function _toHex16(input) -> output {\\n                output := or(\\n                    and(input, 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000),\\n                    shr(64, and(input, 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000))\\n                )\\n                output := or(\\n                    and(output, 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000),\\n                    shr(32, and(output, 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000))\\n                )\\n                output := or(\\n                    and(output, 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000),\\n                    shr(16, and(output, 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000))\\n                )\\n                output := or(\\n                    and(output, 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000),\\n                    shr(8, and(output, 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000))\\n                )\\n                output := or(\\n                    shr(4, and(output, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\\n                    shr(8, and(output, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\\n                )\\n                output := add(\\n                    add(0x3030303030303030303030303030303030303030303030303030303030303030, output),\\n                    mul(\\n                        and(\\n                            shr(4, add(output, 0x0606060606060606060606060606060606060606060606060606060606060606)),\\n                            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\\n                        ),\\n                        7 // Change 7 to 39 for lower case output\\n                    )\\n                )\\n            }\\n\\n            result := mload(0x40)\\n            let length := mload(data)\\n            let resultLength := shl(1, length)\\n            let toPtr := add(result, 0x22) // 32 bytes for length + 2 bytes for '0x'\\n            mstore(0x40, add(toPtr, resultLength)) // move free memory pointer\\n            mstore(add(result, 2), 0x3078) // 0x3078 is right aligned so we write to `result + 2`\\n            // to store the last 2 bytes in the beginning of the string\\n            mstore(result, add(resultLength, 2)) // extra 2 bytes for '0x'\\n\\n            for {\\n                let fromPtr := add(data, 0x20)\\n                let endPtr := add(fromPtr, length)\\n            } lt(fromPtr, endPtr) {\\n                fromPtr := add(fromPtr, 0x20)\\n            } {\\n                let rawData := mload(fromPtr)\\n                let hexData := _toHex16(rawData)\\n                mstore(toPtr, hexData)\\n                toPtr := add(toPtr, 0x20)\\n                hexData := _toHex16(shl(128, rawData))\\n                mstore(toPtr, hexData)\\n                toPtr := add(toPtr, 0x20)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb05bff1a3a5461b1f16248220067a2bd52e5c7e41c14be0aebb6520985b67ccb\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"../interfaces/IERC20MetadataUppercase.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./StringUtil.sol\\\";\\n\\n/**\\n * @title UniERC20\\n * @dev Library to abstract the handling of ETH and ERC20 tokens, enabling unified interaction with both. It allows usage of ETH as ERC20.\\n * Utilizes SafeERC20 for ERC20 interactions and provides additional utility functions.\\n */\\nlibrary UniERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    error InsufficientBalance();\\n    error ApproveCalledOnETH();\\n    error NotEnoughValue();\\n    error FromIsNotSender();\\n    error ToIsNotThis();\\n    error ETHTransferFailed();\\n\\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\\n\\n    /**\\n     * @dev Determines if the specified token is ETH.\\n     * @param token The token to check.\\n     * @return bool True if the token is ETH, false otherwise.\\n     */\\n    function isETH(IERC20 token) internal pure returns (bool) {\\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of the specified token for an account.\\n     * @param token The token to query the balance of.\\n     * @param account The address of the account.\\n     * @return uint256 The balance of the token for the specified account.\\n     */\\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\\n        if (isETH(token)) {\\n            return account.balance;\\n        } else {\\n            return token.balanceOf(account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a specified amount of the token to a given address.\\n     * Note: Does nothing if the amount is zero.\\n     * @param token The token to transfer.\\n     * @param to The address to transfer the token to.\\n     * @param amount The amount of the token to transfer.\\n     */\\n    function uniTransfer(\\n        IERC20 token,\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            if (isETH(token)) {\\n                if (address(this).balance < amount) revert InsufficientBalance();\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (bool success, ) = to.call{value: amount}(\\\"\\\");\\n                if (!success) revert ETHTransferFailed();\\n            } else {\\n                token.safeTransfer(to, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a specified amount of the token from one address to another.\\n     * Note: Does nothing if the amount is zero.\\n     * @param token The token to transfer.\\n     * @param from The address to transfer the token from.\\n     * @param to The address to transfer the token to.\\n     * @param amount The amount of the token to transfer.\\n     */\\n    function uniTransferFrom(\\n        IERC20 token,\\n        address payable from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            if (isETH(token)) {\\n                if (msg.value < amount) revert NotEnoughValue();\\n                if (from != msg.sender) revert FromIsNotSender();\\n                if (to != address(this)) revert ToIsNotThis();\\n                if (msg.value > amount) {\\n                    // Return remainder if exist\\n                    unchecked {\\n                        // solhint-disable-next-line avoid-low-level-calls\\n                        (bool success, ) = from.call{value: msg.value - amount}(\\\"\\\");\\n                        if (!success) revert ETHTransferFailed();\\n                    }\\n                }\\n            } else {\\n                token.safeTransferFrom(from, to, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the symbol from ERC20 metadata of the specified token.\\n     * @param token The token to retrieve the symbol of.\\n     * @return string The symbol of the token.\\n     */\\n    function uniSymbol(IERC20 token) internal view returns (string memory) {\\n        return _uniDecode(token, IERC20Metadata.symbol.selector, IERC20MetadataUppercase.SYMBOL.selector);\\n    }\\n\\n    /**\\n     * @dev Retrieves the name from ERC20 metadata of the specified token.\\n     * @param token The token to retrieve the name of.\\n     * @return string The name of the token.\\n     */\\n    function uniName(IERC20 token) internal view returns (string memory) {\\n        return _uniDecode(token, IERC20Metadata.name.selector, IERC20MetadataUppercase.NAME.selector);\\n    }\\n\\n    /**\\n     * @dev forceApprove the specified amount of the token to a given address.\\n     * Reverts if the token is ETH.\\n     * @param token The token to approve.\\n     * @param to The address to approve the token to.\\n     * @param amount The amount of the token to approve.\\n     */\\n    function uniApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (isETH(token)) revert ApproveCalledOnETH();\\n\\n        token.forceApprove(to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to decode token metadata (name or symbol).\\n     * 20K gas is provided to account for possible implementations of name/symbol\\n     * (token implementation might be behind proxy or store the value in storage)\\n     * @param token The token to decode metadata for.\\n     * @param lowerCaseSelector The selector for the lowercase metadata function.\\n     * @param upperCaseSelector The selector for the uppercase metadata function.\\n     * @return result The decoded metadata value.\\n     */\\n    function _uniDecode(\\n        IERC20 token,\\n        bytes4 lowerCaseSelector,\\n        bytes4 upperCaseSelector\\n    ) private view returns (string memory result) {\\n        if (isETH(token)) {\\n            return \\\"ETH\\\";\\n        }\\n\\n        (bool success, bytes memory data) = address(token).staticcall{gas: 20000}(\\n            abi.encodeWithSelector(lowerCaseSelector)\\n        );\\n        if (!success) {\\n            (success, data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(upperCaseSelector));\\n        }\\n\\n        if (success && data.length >= 0x40) {\\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\\n            /*\\n                return data is padded up to 32 bytes with ABI encoder also sometimes\\n                there is extra 32 bytes of zeros padded in the end:\\n                https://github.com/ethereum/solidity/issues/10170\\n                because of that we can't check for equality and instead check\\n                that overall data length is greater or equal than string length + extra 64 bytes\\n            */\\n            if (offset == 0x20 && data.length >= 0x40 + len) {\\n                assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                    result := add(data, 0x40)\\n                }\\n                return result;\\n            }\\n        }\\n        if (success && data.length == 32) {\\n            uint256 len = 0;\\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\\n                unchecked {\\n                    len++;\\n                }\\n            }\\n\\n            if (len > 0) {\\n                assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                    mstore(data, len)\\n                }\\n                return string(data);\\n            }\\n        }\\n\\n        return StringUtil.toHex(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xd00f16976ce388b6c8c5e0d98445c4d9808f5d828e2a32aecb07d909c6bedb12\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xd18408af8a91bedb3d56343eeb9b30eb852e6dea93a5e2d5c6db9ca4cb905155\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaa761817f6cd7892fcf158b3c776b34551cde36f48ff9703d53898bc45a94ea2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x6008dabfe393240d73d7dd7688033f72740d570aa422254d29a7dce8568f3aff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Not enough balance for performing a CREATE2 deploy.\\n     */\\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error Create2FailedDeployment();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Create2InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        if (addr == address(0)) {\\n            revert Create2FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2b9807d194b92f1068d868e9587d27037264a9a067c778486f86ae21c61cbd5e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Sorts the pair (a, b) and hashes the result.\\n     */\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6400c4bee15052e043e5d10315135972529bd1c8012f43da494dc6b4f4661058\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/BaseEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { AddressLib, Address } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport { SafeERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\n\\nimport { ImmutablesLib } from \\\"./libraries/ImmutablesLib.sol\\\";\\nimport { Timelocks, TimelocksLib } from \\\"./libraries/TimelocksLib.sol\\\";\\n\\nimport { IBaseEscrow } from \\\"./interfaces/IBaseEscrow.sol\\\";\\n\\n/**\\n * @title Base abstract Escrow contract for cross-chain atomic swap.\\n * @dev {IBaseEscrow-withdraw}, {IBaseEscrow-cancel} and _validateImmutables functions must be implemented in the derived contracts.\\n * @custom:security-contact security@1inch.io\\n */\\nabstract contract BaseEscrow is IBaseEscrow {\\n    using AddressLib for Address;\\n    using SafeERC20 for IERC20;\\n    using TimelocksLib for Timelocks;\\n    using ImmutablesLib for Immutables;\\n\\n    // Token that is used to access public withdraw or cancel functions.\\n    IERC20 private immutable _ACCESS_TOKEN;\\n\\n    /// @notice See {IBaseEscrow-RESCUE_DELAY}.\\n    uint256 public immutable RESCUE_DELAY;\\n    /// @notice See {IBaseEscrow-FACTORY}.\\n    address public immutable FACTORY = msg.sender;\\n\\n    constructor(uint32 rescueDelay, IERC20 accessToken) {\\n        RESCUE_DELAY = rescueDelay;\\n        _ACCESS_TOKEN = accessToken;\\n    }\\n\\n    modifier onlyTaker(Immutables calldata immutables) {\\n        if (msg.sender != immutables.taker.get()) revert InvalidCaller();\\n        _;\\n    }\\n\\n    modifier onlyValidImmutables(Immutables calldata immutables) virtual {\\n        _validateImmutables(immutables);\\n        _;\\n    }\\n\\n    modifier onlyValidSecret(bytes32 secret, Immutables calldata immutables) {\\n        if (_keccakBytes32(secret) != immutables.hashlock) revert InvalidSecret();\\n        _;\\n    }\\n\\n    modifier onlyAfter(uint256 start) {\\n        if (block.timestamp < start) revert InvalidTime();\\n        _;\\n    }\\n\\n    modifier onlyBefore(uint256 stop) {\\n        if (block.timestamp >= stop) revert InvalidTime();\\n        _;\\n    }\\n\\n    modifier onlyAccessTokenHolder() {\\n        if (_ACCESS_TOKEN.balanceOf(msg.sender) == 0) revert InvalidCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @notice See {IBaseEscrow-rescueFunds}.\\n     */\\n    function rescueFunds(\\n        address token,\\n        uint256 amount,\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyTaker(immutables)\\n        onlyValidImmutables(immutables)\\n        onlyAfter(immutables.timelocks.rescueStart(RESCUE_DELAY))\\n    {\\n        _uniTransfer(token, msg.sender, amount);\\n        emit FundsRescued(token, amount);\\n    }\\n\\n    /**\\n     * @dev Transfers ERC20 or native tokens to the recipient.\\n     */\\n    function _uniTransfer(address token, address to, uint256 amount) internal {\\n        if (token == address(0)) {\\n            _ethTransfer(to, amount);\\n        } else {\\n            IERC20(token).safeTransfer(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers native tokens to the recipient.\\n     */\\n    function _ethTransfer(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{ value: amount }(\\\"\\\");\\n        if (!success) revert NativeTokenSendingFailure();\\n    }\\n\\n    /**\\n     * @dev Should verify that the computed escrow address matches the address of this contract.\\n     */\\n    function _validateImmutables(Immutables calldata immutables) internal view virtual;\\n\\n    /**\\n     * @dev Computes the Keccak-256 hash of the secret.\\n     * @param secret The secret that unlocks the escrow.\\n     * @return ret The computed hash.\\n     */\\n    function _keccakBytes32(bytes32 secret) private pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, secret)\\n            ret := keccak256(0, 0x20)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4d691cf5e49e08178c52bccadc4a3c118065bdc5e4b1cb5ad6588fedfabd61d5\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/BaseEscrowFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { Clones } from \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { Address, AddressLib } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport { SafeERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\n\\nimport { IOrderMixin } from \\\"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\\\";\\nimport { MakerTraitsLib } from \\\"@1inch/limit-order-protocol-contract/contracts/libraries/MakerTraitsLib.sol\\\";\\nimport { ResolverValidationExtension } from \\\"../limit-order-settlement/extensions/ResolverValidationExtension.sol\\\";\\n\\nimport { ImmutablesLib } from \\\"./libraries/ImmutablesLib.sol\\\";\\nimport { Timelocks, TimelocksLib } from \\\"./libraries/TimelocksLib.sol\\\";\\n\\nimport { IEscrowFactory } from \\\"./interfaces/IEscrowFactory.sol\\\";\\nimport { IBaseEscrow } from \\\"./interfaces/IBaseEscrow.sol\\\";\\nimport { SRC_IMMUTABLES_LENGTH } from \\\"./EscrowFactoryContext.sol\\\";\\nimport { MerkleStorageInvalidator } from \\\"./MerkleStorageInvalidator.sol\\\";\\n\\n/**\\n * @title Abstract contract for escrow factory\\n * @notice Contract to create escrow contracts for cross-chain atomic swap.\\n * @dev Immutable variables must be set in the constructor of the derived contracts.\\n * @custom:security-contact security@1inch.io\\n */\\nabstract contract BaseEscrowFactory is IEscrowFactory, ResolverValidationExtension, MerkleStorageInvalidator {\\n    using AddressLib for Address;\\n    using Clones for address;\\n    using ImmutablesLib for IBaseEscrow.Immutables;\\n    using SafeERC20 for IERC20;\\n    using TimelocksLib for Timelocks;\\n\\n    /// @notice See {IEscrowFactory-ESCROW_SRC_IMPLEMENTATION}.\\n    address public immutable ESCROW_SRC_IMPLEMENTATION;\\n    /// @notice See {IEscrowFactory-ESCROW_DST_IMPLEMENTATION}.\\n    address public immutable ESCROW_DST_IMPLEMENTATION;\\n    bytes32 internal immutable _PROXY_SRC_BYTECODE_HASH;\\n    bytes32 internal immutable _PROXY_DST_BYTECODE_HASH;\\n\\n    /**\\n     * @notice Creates a new escrow contract for maker on the source chain.\\n     * @dev The caller must be whitelisted and pre-send the safety deposit in a native token\\n     * to a pre-computed deterministic address of the created escrow.\\n     * The external postInteraction function call will be made from the Limit Order Protocol\\n     * after all funds have been transferred. See {IPostInteraction-postInteraction}.\\n     * `extraData` consists of:\\n     *   - ExtraDataArgs struct\\n     *   - whitelist\\n     *   - 0 / 4 bytes for the fee\\n     *   - 1 byte for the bitmap\\n     */\\n    function _postInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) internal override(ResolverValidationExtension) {\\n        uint256 superArgsLength = extraData.length - SRC_IMMUTABLES_LENGTH;\\n        super._postInteraction(\\n            order,\\n            extension,\\n            orderHash,\\n            taker,\\n            makingAmount,\\n            takingAmount,\\n            remainingMakingAmount,\\n            extraData[:superArgsLength]\\n        );\\n\\n        ExtraDataArgs calldata extraDataArgs;\\n        assembly (\\\"memory-safe\\\") {\\n            extraDataArgs := add(extraData.offset, superArgsLength)\\n        }\\n\\n        bytes32 hashlock;\\n\\n        if (MakerTraitsLib.allowMultipleFills(order.makerTraits)) {\\n            uint256 partsAmount = uint256(extraDataArgs.hashlockInfo) >> 240;\\n            if (partsAmount < 2) revert InvalidSecretsAmount();\\n            bytes32 key = keccak256(abi.encodePacked(orderHash, uint240(uint256(extraDataArgs.hashlockInfo))));\\n            ValidationData memory validated = lastValidated[key];\\n            hashlock = validated.leaf;\\n            if (\\n                !_isValidPartialFill(\\n                    makingAmount,\\n                    remainingMakingAmount,\\n                    order.makingAmount,\\n                    partsAmount,\\n                    validated.index\\n                )\\n            ) {\\n                revert InvalidPartialFill();\\n            }\\n        } else {\\n            hashlock = extraDataArgs.hashlockInfo;\\n        }\\n\\n        IBaseEscrow.Immutables memory immutables = IBaseEscrow.Immutables({\\n            orderHash: orderHash,\\n            hashlock: hashlock,\\n            maker: order.maker,\\n            taker: Address.wrap(uint160(taker)),\\n            token: order.makerAsset,\\n            amount: makingAmount,\\n            safetyDeposit: extraDataArgs.deposits >> 128,\\n            timelocks: extraDataArgs.timelocks.setDeployedAt(block.timestamp)\\n        });\\n\\n        DstImmutablesComplement memory immutablesComplement = DstImmutablesComplement({\\n            maker: order.receiver.get() == address(0) ? order.maker : order.receiver,\\n            amount: takingAmount,\\n            token: extraDataArgs.dstToken,\\n            safetyDeposit: extraDataArgs.deposits & type(uint128).max,\\n            chainId: extraDataArgs.dstChainId\\n        });\\n\\n        emit SrcEscrowCreated(immutables, immutablesComplement);\\n\\n        bytes32 salt = immutables.hashMem();\\n        address escrow = _deployEscrow(salt, 0, ESCROW_SRC_IMPLEMENTATION);\\n        if (\\n            escrow.balance < immutables.safetyDeposit ||\\n            IERC20(order.makerAsset.get()).safeBalanceOf(escrow) < makingAmount\\n        ) {\\n            revert InsufficientEscrowBalance();\\n        }\\n    }\\n\\n    /**\\n     * @notice See {IEscrowFactory-createDstEscrow}.\\n     */\\n    function createDstEscrow(\\n        IBaseEscrow.Immutables calldata dstImmutables,\\n        uint256 srcCancellationTimestamp\\n    ) external payable {\\n        address token = dstImmutables.token.get();\\n        uint256 nativeAmount = dstImmutables.safetyDeposit;\\n        if (token == address(0)) {\\n            nativeAmount += dstImmutables.amount;\\n        }\\n        if (msg.value != nativeAmount) revert InsufficientEscrowBalance();\\n\\n        IBaseEscrow.Immutables memory immutables = dstImmutables;\\n        immutables.timelocks = immutables.timelocks.setDeployedAt(block.timestamp);\\n        // Check that the escrow cancellation will start not later than the cancellation time on the source chain.\\n        if (immutables.timelocks.get(TimelocksLib.Stage.DstCancellation) > srcCancellationTimestamp)\\n            revert InvalidCreationTime();\\n\\n        bytes32 salt = immutables.hashMem();\\n        address escrow = _deployEscrow(salt, msg.value, ESCROW_DST_IMPLEMENTATION);\\n        if (token != address(0)) {\\n            IERC20(token).safeTransferFrom(msg.sender, escrow, immutables.amount);\\n        }\\n\\n        emit DstEscrowCreated(escrow, dstImmutables.hashlock, dstImmutables.taker);\\n    }\\n\\n    /**\\n     * @notice See {IEscrowFactory-addressOfEscrowSrc}.\\n     */\\n    function addressOfEscrowSrc(IBaseEscrow.Immutables calldata immutables) external view virtual returns (address) {\\n        return Create2.computeAddress(immutables.hash(), _PROXY_SRC_BYTECODE_HASH);\\n    }\\n\\n    /**\\n     * @notice See {IEscrowFactory-addressOfEscrowDst}.\\n     */\\n    function addressOfEscrowDst(IBaseEscrow.Immutables calldata immutables) external view virtual returns (address) {\\n        return Create2.computeAddress(immutables.hash(), _PROXY_DST_BYTECODE_HASH);\\n    }\\n\\n    /**\\n     * @notice Deploys a new escrow contract.\\n     * @param salt The salt for the deterministic address computation.\\n     * @param value The value to be sent to the escrow contract.\\n     * @param implementation Address of the implementation.\\n     * @return escrow The address of the deployed escrow contract.\\n     */\\n    function _deployEscrow(\\n        bytes32 salt,\\n        uint256 value,\\n        address implementation\\n    ) internal virtual returns (address escrow) {\\n        escrow = implementation.cloneDeterministic(salt);\\n    }\\n\\n    function _isValidPartialFill(\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        uint256 orderMakingAmount,\\n        uint256 partsAmount,\\n        uint256 validatedIndex\\n    ) internal pure returns (bool) {\\n        uint256 calculatedIndex = ((orderMakingAmount - remainingMakingAmount + makingAmount - 1) * partsAmount) /\\n            orderMakingAmount;\\n\\n        if (remainingMakingAmount == makingAmount) {\\n            // If the order is filled to completion, a secret with index i + 1 must be used\\n            // where i is the index of the secret for the last part.\\n            return (calculatedIndex + 2 == validatedIndex);\\n        } else if (orderMakingAmount != remainingMakingAmount) {\\n            // Calculate the previous fill index only if this is not the first fill.\\n            uint256 prevCalculatedIndex = ((orderMakingAmount - remainingMakingAmount - 1) * partsAmount) /\\n                orderMakingAmount;\\n            if (calculatedIndex == prevCalculatedIndex) return false;\\n        }\\n\\n        return calculatedIndex + 1 == validatedIndex;\\n    }\\n}\\n\",\"keccak256\":\"0x6c54d79180c2cd7cad4138a2afcd9d49f588660e5b34f00a22c9936f54e1c901\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/Escrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport { ImmutablesLib } from \\\"./libraries/ImmutablesLib.sol\\\";\\nimport { ProxyHashLib } from \\\"./libraries/ProxyHashLib.sol\\\";\\n\\nimport { IEscrow } from \\\"./interfaces/IEscrow.sol\\\";\\nimport { BaseEscrow } from \\\"./BaseEscrow.sol\\\";\\n\\n/**\\n * @title Abstract Escrow contract for cross-chain atomic swap.\\n * @dev {IBaseEscrow-withdraw} and {IBaseEscrow-cancel} functions must be implemented in the derived contracts.\\n * @custom:security-contact security@1inch.io\\n */\\nabstract contract Escrow is BaseEscrow, IEscrow {\\n    using ImmutablesLib for Immutables;\\n\\n    /// @notice See {IEscrow-PROXY_BYTECODE_HASH}.\\n    bytes32 public immutable PROXY_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(address(this));\\n\\n    /**\\n     * @dev Verifies that the computed escrow address matches the address of this contract.\\n     */\\n    function _validateImmutables(Immutables calldata immutables) internal view virtual override {\\n        bytes32 salt = immutables.hash();\\n        if (Create2.computeAddress(salt, PROXY_BYTECODE_HASH, FACTORY) != address(this)) {\\n            revert InvalidImmutables();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3854f840020486ab8210b45fd552d326ee7645114befcb1f62514886560e3b0c\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/EscrowDst.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\nimport { AddressLib, Address } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\n\\nimport { Timelocks, TimelocksLib } from \\\"./libraries/TimelocksLib.sol\\\";\\n\\nimport { IEscrowDst } from \\\"./interfaces/IEscrowDst.sol\\\";\\nimport { BaseEscrow } from \\\"./BaseEscrow.sol\\\";\\nimport { Escrow } from \\\"./Escrow.sol\\\";\\n\\n/**\\n * @title Destination Escrow contract for cross-chain atomic swap.\\n * @notice Contract to initially lock funds and then unlock them with verification of the secret presented.\\n * @dev Funds are locked in at the time of contract deployment. For this taker calls the `EscrowFactory.createDstEscrow` function.\\n * To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.\\n * @custom:security-contact security@1inch.io\\n */\\ncontract EscrowDst is Escrow, IEscrowDst {\\n    using SafeERC20 for IERC20;\\n    using AddressLib for Address;\\n    using TimelocksLib for Timelocks;\\n\\n    constructor(uint32 rescueDelay, IERC20 accessToken) BaseEscrow(rescueDelay, accessToken) {}\\n\\n    /**\\n     * @notice See {IBaseEscrow-withdraw}.\\n     * @dev The function works on the time intervals highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/-- private cancellation ----\\n     */\\n    function withdraw(\\n        bytes32 secret,\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyTaker(immutables)\\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.DstWithdrawal))\\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.DstCancellation))\\n    {\\n        _withdraw(secret, immutables);\\n    }\\n\\n    /**\\n     * @notice See {IBaseEscrow-publicWithdraw}.\\n     * @dev The function works on the time intervals highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/-- private cancellation ----\\n     */\\n    function publicWithdraw(\\n        bytes32 secret,\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyAccessTokenHolder\\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.DstPublicWithdrawal))\\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.DstCancellation))\\n    {\\n        _withdraw(secret, immutables);\\n    }\\n\\n    /**\\n     * @notice See {IBaseEscrow-cancel}.\\n     * @dev The function works on the time interval highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/-- PRIVATE CANCELLATION ----\\n     */\\n    function cancel(\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyTaker(immutables)\\n        onlyValidImmutables(immutables)\\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.DstCancellation))\\n    {\\n        _uniTransfer(immutables.token.get(), immutables.taker.get(), immutables.amount);\\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\\n        emit EscrowCancelled();\\n    }\\n\\n    /**\\n     * @dev Transfers ERC20 (or native) tokens to the maker and native tokens to the caller.\\n     * @param immutables The immutable values used to deploy the clone contract.\\n     */\\n    function _withdraw(\\n        bytes32 secret,\\n        Immutables calldata immutables\\n    ) internal onlyValidImmutables(immutables) onlyValidSecret(secret, immutables) {\\n        _uniTransfer(immutables.token.get(), immutables.maker.get(), immutables.amount);\\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\\n        emit EscrowWithdrawal(secret);\\n    }\\n}\\n\",\"keccak256\":\"0x5629abf1d6f54714708c515873c5bb68e8947e3728b36ebb76e4319254050c99\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/EscrowFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { BaseExtension } from \\\"../limit-order-settlement/extensions/BaseExtension.sol\\\";\\nimport { ResolverValidationExtension } from \\\"../limit-order-settlement/extensions/ResolverValidationExtension.sol\\\";\\n\\nimport { ProxyHashLib } from \\\"./libraries/ProxyHashLib.sol\\\";\\n\\nimport { BaseEscrowFactory } from \\\"./BaseEscrowFactory.sol\\\";\\nimport { EscrowDst } from \\\"./EscrowDst.sol\\\";\\nimport { EscrowSrc } from \\\"./EscrowSrc.sol\\\";\\nimport { MerkleStorageInvalidator } from \\\"./MerkleStorageInvalidator.sol\\\";\\n\\n/**\\n * @title Escrow Factory contract\\n * @notice Contract to create escrow contracts for cross-chain atomic swap.\\n * @custom:security-contact security@1inch.io\\n */\\ncontract EscrowFactory is BaseEscrowFactory {\\n    constructor(\\n        address limitOrderProtocol,\\n        IERC20 feeToken,\\n        IERC20 accessToken,\\n        address owner,\\n        uint32 rescueDelaySrc,\\n        uint32 rescueDelayDst\\n    )\\n        BaseExtension(limitOrderProtocol)\\n        ResolverValidationExtension(feeToken, accessToken, owner)\\n        MerkleStorageInvalidator(limitOrderProtocol)\\n    {\\n        ESCROW_SRC_IMPLEMENTATION = address(new EscrowSrc(rescueDelaySrc, accessToken));\\n        ESCROW_DST_IMPLEMENTATION = address(new EscrowDst(rescueDelayDst, accessToken));\\n        _PROXY_SRC_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_SRC_IMPLEMENTATION);\\n        _PROXY_DST_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_DST_IMPLEMENTATION);\\n    }\\n}\\n\",\"keccak256\":\"0x55972fb5ec0979d94b57747f8634261f71d56009050acf7f71a81c840ff45fb7\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/EscrowFactoryContext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nuint256 constant SRC_IMMUTABLES_LENGTH = 160;\\n\",\"keccak256\":\"0xb7555886ff3c177bb87e17ba925fe3d09aa800a72b5ccb3407190ef71a839258\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/EscrowSrc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\nimport { AddressLib, Address } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\n\\nimport { Timelocks, TimelocksLib } from \\\"./libraries/TimelocksLib.sol\\\";\\nimport { ImmutablesLib } from \\\"./libraries/ImmutablesLib.sol\\\";\\n\\nimport { IEscrowSrc } from \\\"./interfaces/IEscrowSrc.sol\\\";\\nimport { BaseEscrow } from \\\"./BaseEscrow.sol\\\";\\nimport { Escrow } from \\\"./Escrow.sol\\\";\\n\\n/**\\n * @title Source Escrow contract for cross-chain atomic swap.\\n * @notice Contract to initially lock funds and then unlock them with verification of the secret presented.\\n * @dev Funds are locked in at the time of contract deployment. For this Limit Order Protocol\\n * calls the `EscrowFactory.postInteraction` function.\\n * To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.\\n * @custom:security-contact security@1inch.io\\n */\\ncontract EscrowSrc is Escrow, IEscrowSrc {\\n    using AddressLib for Address;\\n    using ImmutablesLib for Immutables;\\n    using SafeERC20 for IERC20;\\n    using TimelocksLib for Timelocks;\\n\\n    constructor(uint32 rescueDelay, IERC20 accessToken) BaseEscrow(rescueDelay, accessToken) {}\\n\\n    /**\\n     * @notice See {IBaseEscrow-withdraw}.\\n     * @dev The function works on the time interval highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/--\\n     * --/-- private cancellation --/-- public cancellation ----\\n     */\\n    function withdraw(\\n        bytes32 secret,\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyTaker(immutables)\\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal))\\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\\n    {\\n        _withdrawTo(secret, msg.sender, immutables);\\n    }\\n\\n    /**\\n     * @notice See {IEscrowSrc-withdrawTo}.\\n     * @dev The function works on the time interval highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/--\\n     * --/-- private cancellation --/-- public cancellation ----\\n     */\\n    function withdrawTo(\\n        bytes32 secret,\\n        address target,\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyTaker(immutables)\\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal))\\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\\n    {\\n        _withdrawTo(secret, target, immutables);\\n    }\\n\\n    /**\\n     * @notice See {IEscrowSrc-publicWithdraw}.\\n     * @dev The function works on the time interval highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/--\\n     * --/-- private cancellation --/-- public cancellation ----\\n     */\\n    function publicWithdraw(\\n        bytes32 secret,\\n        Immutables calldata immutables\\n    )\\n        external\\n        onlyAccessTokenHolder\\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcPublicWithdrawal))\\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\\n    {\\n        _withdrawTo(secret, immutables.taker.get(), immutables);\\n    }\\n\\n    /**\\n     * @notice See {IBaseEscrow-cancel}.\\n     * @dev The function works on the time intervals highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/--\\n     * --/-- PRIVATE CANCELLATION --/-- PUBLIC CANCELLATION ----\\n     */\\n    function cancel(\\n        Immutables calldata immutables\\n    ) external onlyTaker(immutables) onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation)) {\\n        _cancel(immutables);\\n    }\\n\\n    /**\\n     * @notice See {IEscrowSrc-publicCancel}.\\n     * @dev The function works on the time intervals highlighted with capital letters:\\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/--\\n     * --/-- private cancellation --/-- PUBLIC CANCELLATION ----\\n     */\\n    function publicCancel(\\n        Immutables calldata immutables\\n    ) external onlyAccessTokenHolder onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcPublicCancellation)) {\\n        _cancel(immutables);\\n    }\\n\\n    /**\\n     * @dev Transfers ERC20 tokens to the target and native tokens to the caller.\\n     * @param secret The secret that unlocks the escrow.\\n     * @param target The address to transfer ERC20 tokens to.\\n     * @param immutables The immutable values used to deploy the clone contract.\\n     */\\n    function _withdrawTo(\\n        bytes32 secret,\\n        address target,\\n        Immutables calldata immutables\\n    ) internal onlyValidImmutables(immutables) onlyValidSecret(secret, immutables) {\\n        IERC20(immutables.token.get()).safeTransfer(target, immutables.amount);\\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\\n        emit EscrowWithdrawal(secret);\\n    }\\n\\n    /**\\n     * @dev Transfers ERC20 tokens to the maker and native tokens to the caller.\\n     * @param immutables The immutable values used to deploy the clone contract.\\n     */\\n    function _cancel(Immutables calldata immutables) internal onlyValidImmutables(immutables) {\\n        IERC20(immutables.token.get()).safeTransfer(immutables.maker.get(), immutables.amount);\\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\\n        emit EscrowCancelled();\\n    }\\n}\\n\",\"keccak256\":\"0x6572e4c54a3ccdc00050eaef038de8f3084cf9f3c86653fb974f9620da6572d1\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/MerkleStorageInvalidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IOrderMixin } from \\\"../limit-order-protocol/interfaces/IOrderMixin.sol\\\";\\nimport { ExtensionLib } from \\\"../limit-order-protocol/libraries/ExtensionLib.sol\\\";\\nimport { ITakerInteraction } from \\\"../limit-order-protocol/interfaces/ITakerInteraction.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport { IEscrowFactory } from \\\"./interfaces/IEscrowFactory.sol\\\";\\nimport { IMerkleStorageInvalidator } from \\\"./interfaces/IMerkleStorageInvalidator.sol\\\";\\nimport { SRC_IMMUTABLES_LENGTH } from \\\"./EscrowFactoryContext.sol\\\"; // solhint-disable-line no-unused-import\\n\\n/**\\n * @title Merkle Storage Invalidator contract\\n * @notice Contract to invalidate hashed secrets from an order that supports multiple fills.\\n * @custom:security-contact security@1inch.io\\n */\\ncontract MerkleStorageInvalidator is IMerkleStorageInvalidator, ITakerInteraction {\\n    using MerkleProof for bytes32[];\\n    using ExtensionLib for bytes;\\n\\n    address private immutable _LIMIT_ORDER_PROTOCOL;\\n\\n    /// @notice See {IMerkleStorageInvalidator-lastValidated}.\\n    mapping(bytes32 key => ValidationData) public lastValidated;\\n\\n    /// @notice Only limit order protocol can call this contract.\\n    modifier onlyLOP() {\\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) {\\n            revert AccessDenied();\\n        }\\n        _;\\n    }\\n\\n    constructor(address limitOrderProtocol) {\\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\\n    }\\n\\n    /**\\n     * @notice See {ITakerInteraction-takerInteraction}.\\n     * @dev Verifies the proof and stores the last validated index and hashed secret.\\n     * Only Limit Order Protocol can call this function.\\n     */\\n    function takerInteraction(\\n        IOrderMixin.Order calldata /* order */,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address /* taker */,\\n        uint256 /* makingAmount */,\\n        uint256 /* takingAmount */,\\n        uint256 /* remainingMakingAmount */,\\n        bytes calldata extraData\\n    ) external onlyLOP {\\n        bytes calldata postInteraction = extension.postInteractionTargetAndData();\\n        IEscrowFactory.ExtraDataArgs calldata extraDataArgs;\\n        TakerData calldata takerData;\\n        assembly (\\\"memory-safe\\\") {\\n            extraDataArgs := add(postInteraction.offset, sub(postInteraction.length, SRC_IMMUTABLES_LENGTH))\\n            takerData := extraData.offset\\n        }\\n        uint240 rootShortened = uint240(uint256(extraDataArgs.hashlockInfo));\\n        bytes32 key = keccak256(abi.encodePacked(orderHash, rootShortened));\\n        bytes32 rootCalculated = takerData.proof.processProofCalldata(\\n            keccak256(abi.encodePacked(uint64(takerData.idx), takerData.secretHash))\\n        );\\n        if (uint240(uint256(rootCalculated)) != rootShortened) revert InvalidProof();\\n        lastValidated[key] = ValidationData(takerData.idx + 1, takerData.secretHash);\\n    }\\n}\\n\",\"keccak256\":\"0xfc58c91817fc19d5ea6a909576d0e994b5bd57225dd497e055db0b2bee1f10a0\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/interfaces/IBaseEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Address } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\n\\nimport { Timelocks } from \\\"../libraries/TimelocksLib.sol\\\";\\n\\n/**\\n * @title Base Escrow interface for cross-chain atomic swap.\\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\\n * @custom:security-contact security@1inch.io\\n */\\ninterface IBaseEscrow {\\n    struct Immutables {\\n        bytes32 orderHash;\\n        bytes32 hashlock; // Hash of the secret.\\n        Address maker;\\n        Address taker;\\n        Address token;\\n        uint256 amount;\\n        uint256 safetyDeposit;\\n        Timelocks timelocks;\\n    }\\n\\n    /**\\n     * @notice Emitted on escrow cancellation.\\n     */\\n    event EscrowCancelled();\\n\\n    /**\\n     * @notice Emitted when funds are rescued.\\n     * @param token The address of the token rescued. Zero address for native token.\\n     * @param amount The amount of tokens rescued.\\n     */\\n    event FundsRescued(address token, uint256 amount);\\n\\n    /**\\n     * @notice Emitted on successful withdrawal.\\n     * @param secret The secret that unlocks the escrow.\\n     */\\n    event EscrowWithdrawal(bytes32 secret);\\n\\n    error InvalidCaller();\\n    error InvalidImmutables();\\n    error InvalidSecret();\\n    error InvalidTime();\\n    error NativeTokenSendingFailure();\\n\\n    /* solhint-disable func-name-mixedcase */\\n    /// @notice Returns the delay for rescuing funds from the escrow.\\n    function RESCUE_DELAY() external view returns (uint256);\\n\\n    /// @notice Returns the address of the factory that created the escrow.\\n    function FACTORY() external view returns (address);\\n\\n    /* solhint-enable func-name-mixedcase */\\n\\n    /**\\n     * @notice Withdraws funds to a predetermined recipient.\\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\\n     * The safety deposit is sent to the caller.\\n     * @param secret The secret that unlocks the escrow.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function withdraw(bytes32 secret, Immutables calldata immutables) external;\\n\\n    /**\\n     * @notice Cancels the escrow and returns tokens to a predetermined recipient.\\n     * @dev The escrow can only be cancelled during the cancellation period.\\n     * The safety deposit is sent to the caller.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function cancel(Immutables calldata immutables) external;\\n\\n    /**\\n     * @notice Rescues funds from the escrow.\\n     * @dev Funds can only be rescued by the taker after the rescue delay.\\n     * @param token The address of the token to rescue. Zero address for native token.\\n     * @param amount The amount of tokens to rescue.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function rescueFunds(address token, uint256 amount, Immutables calldata immutables) external;\\n}\\n\",\"keccak256\":\"0x09384c821ac1899c494ad96b8b4b787c766ba4fb12d6b5e551ef8ab8224027e1\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/interfaces/IEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IBaseEscrow } from \\\"./IBaseEscrow.sol\\\";\\n\\n/**\\n * @title Escrow interface for cross-chain atomic swap.\\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\\n * @custom:security-contact security@1inch.io\\n */\\ninterface IEscrow is IBaseEscrow {\\n    /// @notice Returns the bytecode hash of the proxy contract.\\n    function PROXY_BYTECODE_HASH() external view returns (bytes32); // solhint-disable-line func-name-mixedcase\\n}\\n\",\"keccak256\":\"0x8b0063cd06290dfc5d4bb20a9bdddff356f3100bd63d5a0c3f1b8d30d028fc10\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/interfaces/IEscrowDst.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IEscrow } from \\\"./IEscrow.sol\\\";\\n\\n/**\\n * @title Destination Escrow interface for cross-chain atomic swap.\\n * @notice Interface implies withdrawing funds initially and then unlocking them with verification of the secret presented.\\n * @custom:security-contact security@1inch.io\\n */\\ninterface IEscrowDst is IEscrow {\\n    /**\\n     * @notice Withdraws funds to maker\\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\\n     * @param secret The secret that unlocks the escrow.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function publicWithdraw(bytes32 secret, IEscrow.Immutables calldata immutables) external;\\n}\\n\",\"keccak256\":\"0x47e7f223fb5d3f14e66b42601ef0140be43168f8735ec685a63d5743267bd89f\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/interfaces/IEscrowFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Address } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\n\\nimport { Timelocks } from \\\"../libraries/TimelocksLib.sol\\\";\\n\\nimport { IBaseEscrow } from \\\"./IBaseEscrow.sol\\\";\\n\\n/**\\n * @title Escrow Factory interface for cross-chain atomic swap.\\n * @notice Interface to deploy escrow contracts for the destination chain and to get the deterministic address of escrow on both chains.\\n * @custom:security-contact security@1inch.io\\n */\\ninterface IEscrowFactory {\\n    struct ExtraDataArgs {\\n        bytes32 hashlockInfo; // Hash of the secret or the Merkle tree root if multiple fills are allowed\\n        uint256 dstChainId;\\n        Address dstToken;\\n        uint256 deposits;\\n        Timelocks timelocks;\\n    }\\n\\n    struct DstImmutablesComplement {\\n        Address maker;\\n        uint256 amount;\\n        Address token;\\n        uint256 safetyDeposit;\\n        uint256 chainId;\\n    }\\n\\n    error InsufficientEscrowBalance();\\n    error InvalidCreationTime();\\n    error InvalidPartialFill();\\n    error InvalidSecretsAmount();\\n\\n    /**\\n     * @notice Emitted on EscrowSrc deployment to recreate EscrowSrc and EscrowDst immutables off-chain.\\n     * @param srcImmutables The immutables of the escrow contract that are used in deployment on the source chain.\\n     * @param dstImmutablesComplement Additional immutables related to the escrow contract on the destination chain.\\n     */\\n    event SrcEscrowCreated(IBaseEscrow.Immutables srcImmutables, DstImmutablesComplement dstImmutablesComplement);\\n    /**\\n     * @notice Emitted on EscrowDst deployment.\\n     * @param escrow The address of the created escrow.\\n     * @param hashlock The hash of the secret.\\n     * @param taker The address of the taker.\\n     */\\n    event DstEscrowCreated(address escrow, bytes32 hashlock, Address taker);\\n\\n    /* solhint-disable func-name-mixedcase */\\n    /// @notice Returns the address of implementation on the source chain.\\n    function ESCROW_SRC_IMPLEMENTATION() external view returns (address);\\n\\n    /// @notice Returns the address of implementation on the destination chain.\\n    function ESCROW_DST_IMPLEMENTATION() external view returns (address);\\n\\n    /* solhint-enable func-name-mixedcase */\\n\\n    /**\\n     * @notice Creates a new escrow contract for taker on the destination chain.\\n     * @dev The caller must send the safety deposit in the native token along with the function call\\n     * and approve the destination token to be transferred to the created escrow.\\n     * @param dstImmutables The immutables of the escrow contract that are used in deployment.\\n     * @param srcCancellationTimestamp The start of the cancellation period for the source chain.\\n     */\\n    function createDstEscrow(\\n        IBaseEscrow.Immutables calldata dstImmutables,\\n        uint256 srcCancellationTimestamp\\n    ) external payable;\\n\\n    /**\\n     * @notice Returns the deterministic address of the source escrow based on the salt.\\n     * @param immutables The immutable arguments used to compute salt for escrow deployment.\\n     * @return The computed address of the escrow.\\n     */\\n    function addressOfEscrowSrc(IBaseEscrow.Immutables calldata immutables) external view returns (address);\\n\\n    /**\\n     * @notice Returns the deterministic address of the destination escrow based on the salt.\\n     * @param immutables The immutable arguments used to compute salt for escrow deployment.\\n     * @return The computed address of the escrow.\\n     */\\n    function addressOfEscrowDst(IBaseEscrow.Immutables calldata immutables) external view returns (address);\\n}\\n\",\"keccak256\":\"0x5c956efab4b9365a22ca99d569327b80c035f593356bf259992737fd4cc91a6f\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/interfaces/IEscrowSrc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IEscrow } from \\\"./IEscrow.sol\\\";\\n\\n/**\\n * @title Source Escrow interface for cross-chain atomic swap.\\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\\n * @custom:security-contact security@1inch.io\\n */\\ninterface IEscrowSrc is IEscrow {\\n    /**\\n     * @notice Withdraws funds to a specified target.\\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\\n     * The safety deposit is sent to the caller.\\n     * @param secret The secret that unlocks the escrow.\\n     * @param target The address to withdraw the funds to.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function withdrawTo(bytes32 secret, address target, IEscrow.Immutables calldata immutables) external;\\n\\n    /**\\n     * @notice Withdraws funds to the taker.\\n     * @dev Withdrawal can only be made during the public withdrawal period and with secret with hash matches the hashlock.\\n     * @param secret The secret that unlocks the escrow.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function publicWithdraw(bytes32 secret, Immutables calldata immutables) external;\\n\\n    /**\\n     * @notice Cancels the escrow and returns tokens to the maker.\\n     * @dev The escrow can only be cancelled during the public cancellation period.\\n     * The safety deposit is sent to the caller.\\n     * @param immutables The immutables of the escrow contract.\\n     */\\n    function publicCancel(IEscrow.Immutables calldata immutables) external;\\n}\\n\",\"keccak256\":\"0x76ef7eb0c58fcfe8dde20f2acf68265c499a437c3c7c8257939786dfb47599e1\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/interfaces/IMerkleStorageInvalidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title Merkle Storage Invalidator interface\\n * @notice Interface to invalidate hashed secrets from an order that supports multiple fills.\\n * @custom:security-contact security@1inch.io\\n */\\ninterface IMerkleStorageInvalidator {\\n    struct ValidationData {\\n        uint256 index;\\n        bytes32 leaf;\\n    }\\n\\n    struct TakerData {\\n        bytes32[] proof;\\n        uint256 idx;\\n        bytes32 secretHash;\\n    }\\n\\n    error AccessDenied();\\n    error InvalidProof();\\n\\n    /**\\n     * @notice Returns the index of the last validated hashed secret and the hashed secret itself.\\n     * @param key Hash of concatenated order hash and 30 bytes of root hash.\\n     * @return index Index of the last validated hashed secret.\\n     * @return secretHash Last validated hashed secret.\\n     */\\n    function lastValidated(bytes32 key) external view returns (uint256 index, bytes32 secretHash);\\n}\\n\",\"keccak256\":\"0xd17224d668d000818ff16b0546939c025230579122c5ff06ca39c2b11f0d6501\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/libraries/ImmutablesLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IBaseEscrow } from \\\"../interfaces/IBaseEscrow.sol\\\";\\n\\n/**\\n * @title Library for escrow immutables.\\n * @custom:security-contact security@1inch.io\\n */\\nlibrary ImmutablesLib {\\n    uint256 internal constant ESCROW_IMMUTABLES_SIZE = 0x100;\\n\\n    /**\\n     * @notice Returns the hash of the immutables.\\n     * @param immutables The immutables to hash.\\n     * @return ret The computed hash.\\n     */\\n    function hash(IBaseEscrow.Immutables calldata immutables) internal pure returns(bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, immutables, ESCROW_IMMUTABLES_SIZE)\\n            ret := keccak256(ptr, ESCROW_IMMUTABLES_SIZE)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the hash of the immutables.\\n     * @param immutables The immutables to hash.\\n     * @return ret The computed hash.\\n     */\\n    function hashMem(IBaseEscrow.Immutables memory immutables) internal pure returns(bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            ret := keccak256(immutables, ESCROW_IMMUTABLES_SIZE)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x61b4a772ba17cbb1e52d09c71903d694a6f032c7c3bff76ba109a2d2b606fcca\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/libraries/ProxyHashLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title Library to compute the hash of the proxy bytecode.\\n * @custom:security-contact security@1inch.io\\n */\\nlibrary ProxyHashLib {\\n    /**\\n     * @notice Returns the hash of the proxy bytecode concatenated with the implementation address.\\n     * @param implementation The address of the contract to clone.\\n     * @return bytecodeHash The hash of the resulting bytecode.\\n     */\\n    function computeProxyBytecodeHash(address implementation) internal pure returns (bytes32 bytecodeHash) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Stores the bytecode after address\\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\\n            // implementation address\\n            mstore(0x11, implementation)\\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            bytecodeHash := keccak256(0x09, 0x37)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9e899d11aa1548e1f30a61ad87668b0dfd2b3464fbc1abef8ec95352c8c34c0d\",\"license\":\"MIT\"},\"contracts/1inch/cross-chain-swap/libraries/TimelocksLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Timelocks for the source and the destination chains plus the deployment timestamp.\\n * Timelocks store the number of seconds from the time the contract is deployed to the start of a specific period.\\n * For illustrative purposes, it is possible to describe timelocks by two structures:\\n * struct SrcTimelocks {\\n *     uint256 withdrawal;\\n *     uint256 publicWithdrawal;\\n *     uint256 cancellation;\\n *     uint256 publicCancellation;\\n * }\\n *\\n * struct DstTimelocks {\\n *     uint256 withdrawal;\\n *     uint256 publicWithdrawal;\\n *     uint256 cancellation;\\n * }\\n *\\n * withdrawal: Period when only the taker with a secret can withdraw tokens for taker (source chain) or maker (destination chain).\\n * publicWithdrawal: Period when anyone with a secret can withdraw tokens for taker (source chain) or maker (destination chain).\\n * cancellation: Period when escrow can only be cancelled by the taker.\\n * publicCancellation: Period when escrow can be cancelled by anyone.\\n *\\n * @custom:security-contact security@1inch.io\\n */\\ntype Timelocks is uint256;\\n\\n/**\\n * @title Timelocks library for compact storage of timelocks in a uint256.\\n */\\nlibrary TimelocksLib {\\n    enum Stage {\\n        SrcWithdrawal,\\n        SrcPublicWithdrawal,\\n        SrcCancellation,\\n        SrcPublicCancellation,\\n        DstWithdrawal,\\n        DstPublicWithdrawal,\\n        DstCancellation\\n    }\\n\\n    uint256 private constant _DEPLOYED_AT_MASK = 0xffffffff00000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant _DEPLOYED_AT_OFFSET = 224;\\n\\n    /**\\n     * @notice Sets the Escrow deployment timestamp.\\n     * @param timelocks The timelocks to set the deployment timestamp to.\\n     * @param value The new Escrow deployment timestamp.\\n     * @return The timelocks with the deployment timestamp set.\\n     */\\n    function setDeployedAt(Timelocks timelocks, uint256 value) internal pure returns (Timelocks) {\\n        return Timelocks.wrap((Timelocks.unwrap(timelocks) & ~uint256(_DEPLOYED_AT_MASK)) | value << _DEPLOYED_AT_OFFSET);\\n    }\\n\\n    /**\\n     * @notice Returns the start of the rescue period.\\n     * @param timelocks The timelocks to get the rescue delay from.\\n     * @return The start of the rescue period.\\n     */\\n    function rescueStart(Timelocks timelocks, uint256 rescueDelay) internal pure returns (uint256) {\\n        unchecked {\\n            return rescueDelay + (Timelocks.unwrap(timelocks) >> _DEPLOYED_AT_OFFSET);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the timelock value for the given stage.\\n     * @param timelocks The timelocks to get the value from.\\n     * @param stage The stage to get the value for.\\n     * @return The timelock value for the given stage.\\n     */\\n    function get(Timelocks timelocks, Stage stage) internal pure returns (uint256) {\\n        uint256 data = Timelocks.unwrap(timelocks);\\n        uint256 bitShift = uint256(stage) * 32;\\n        // The maximum uint32 value will be reached in 2106.\\n        return (data >> _DEPLOYED_AT_OFFSET) + uint32(data >> bitShift);\\n    }\\n}\\n\",\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-protocol/interfaces/IOrderMixin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport \\\"../libraries/MakerTraitsLib.sol\\\";\\nimport \\\"../libraries/TakerTraitsLib.sol\\\";\\n\\n/**\\n * @title IOrderMixin\\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\\n */\\ninterface IOrderMixin {\\n    struct Order {\\n        uint256 salt;\\n        Address maker;\\n        Address receiver;\\n        Address makerAsset;\\n        Address takerAsset;\\n        uint256 makingAmount;\\n        uint256 takingAmount;\\n        MakerTraits makerTraits;\\n    }\\n\\n    error InvalidatedOrder();\\n    error TakingAmountExceeded();\\n    error PrivateOrder();\\n    error BadSignature();\\n    error OrderExpired();\\n    error WrongSeriesNonce();\\n    error SwapWithZeroAmount();\\n    error PartialFillNotAllowed();\\n    error OrderIsNotSuitableForMassInvalidation();\\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\\n    error ReentrancyDetected();\\n    error PredicateIsNotTrue();\\n    error TakingAmountTooHigh();\\n    error MakingAmountTooLow();\\n    error TransferFromMakerToTakerFailed();\\n    error TransferFromTakerToMakerFailed();\\n    error MismatchArraysLengths();\\n    error InvalidPermit2Transfer();\\n    error SimulationResults(bool success, bytes res);\\n\\n    /**\\n     * @notice Emitted when order gets filled\\n     * @param orderHash Hash of the order\\n     * @param remainingAmount Amount of the maker asset that remains to be filled\\n     */\\n    event OrderFilled(\\n        bytes32 orderHash,\\n        uint256 remainingAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\\n     * @param orderHash Hash of the order\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash\\n    );\\n\\n    /**\\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\\n     * @param maker Maker address\\n     * @param slotIndex Slot index that was updated\\n     * @param slotValue New slot value\\n     */\\n    event BitInvalidatorUpdated(\\n        address indexed maker,\\n        uint256 slotIndex,\\n        uint256 slotValue\\n    );\\n\\n    /**\\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\\n     * @dev The function always reverts and returns the simulation results in revert data.\\n     * @param target Addresses that will be delegated\\n     * @param data Data that will be passed to delegatee\\n     */\\n    function simulate(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Cancels order's quote\\n     * @param makerTraits Order makerTraits\\n     * @param orderHash Hash of the order to cancel\\n     */\\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\\n\\n    /**\\n     * @notice Cancels orders' quotes\\n     * @param makerTraits Orders makerTraits\\n     * @param orderHashes Hashes of the orders to cancel\\n     */\\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\\n\\n    /**\\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\\n     * @param makerTraits Order makerTraits\\n     * @param additionalMask Additional bitmask to invalidate orders\\n     */\\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\\n\\n    /**\\n     * @notice Fills order's quote, fully or partially (whichever is possible).\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrder(\\n        Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrderArgs(\\n        IOrderMixin.Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but uses contract-based signatures.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrder(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrderArgs(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param maker Maker address\\n     * @param slot Slot number to return bitmask for\\n     * @return result Each bit represents whether corresponding was already invalidated\\n     */\\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remaining Remaining amount of the order\\n     */\\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\\n     */\\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\\n\\n    /**\\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\\n     * @param order Order\\n     * @return orderHash Hash of the order\\n     */\\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\\n}\\n\",\"keccak256\":\"0x39cfb84ae74a276eae63d7b3be898104045f98163405190227ddae3e85f6dd11\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-protocol/interfaces/ITakerInteraction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\n/**\\n * @title Interface for interactor which acts after `maker -> taker` transfer but before `taker -> maker` transfer.\\n * @notice The order filling steps are `preInteraction` =>` Transfer \\\"maker -> taker\\\"` => **`Interaction`** => `Transfer \\\"taker -> maker\\\"` => `postInteraction`\\n */\\ninterface ITakerInteraction {\\n    /**\\n     * @dev This callback allows to interactively handle maker aseets to produce takers assets, doesn't supports ETH as taker assets\\n     * @notice Callback method that gets called after maker fund transfer but before taker fund transfer\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual making amount\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     */\\n    function takerInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\",\"keccak256\":\"0xd66e858e74309edb9de7866af1ccd92990b0f7367cf47b4b5acb94e336e57930\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-protocol/libraries/ExtensionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOrderMixin.sol\\\";\\nimport \\\"./OffsetsLib.sol\\\";\\n\\n/**\\n * @title ExtensionLib\\n * @notice Library for retrieving extensions information for the IOrderMixin Interface.\\n */\\nlibrary ExtensionLib {\\n    using AddressLib for Address;\\n    using OffsetsLib for Offsets;\\n\\n    enum DynamicField {\\n        MakerAssetSuffix,\\n        TakerAssetSuffix,\\n        MakingAmountData,\\n        TakingAmountData,\\n        Predicate,\\n        MakerPermit,\\n        PreInteractionData,\\n        PostInteractionData,\\n        CustomData\\n    }\\n\\n    /**\\n     * @notice Returns the MakerAssetSuffix from the provided extension calldata.\\n     * @param extension The calldata from which the MakerAssetSuffix is to be retrieved.\\n     * @return calldata Bytes representing the MakerAssetSuffix.\\n     */\\n    function makerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.MakerAssetSuffix);\\n    }\\n\\n    /**\\n     * @notice Returns the TakerAssetSuffix from the provided extension calldata.\\n     * @param extension The calldata from which the TakerAssetSuffix is to be retrieved.\\n     * @return calldata Bytes representing the TakerAssetSuffix.\\n     */\\n    function takerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.TakerAssetSuffix);\\n    }\\n\\n    /**\\n     * @notice Returns the MakingAmountData from the provided extension calldata.\\n     * @param extension The calldata from which the MakingAmountData is to be retrieved.\\n     * @return calldata Bytes representing the MakingAmountData.\\n     */\\n    function makingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.MakingAmountData);\\n    }\\n\\n    /**\\n     * @notice Returns the TakingAmountData from the provided extension calldata.\\n     * @param extension The calldata from which the TakingAmountData is to be retrieved.\\n     * @return calldata Bytes representing the TakingAmountData.\\n     */\\n    function takingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.TakingAmountData);\\n    }\\n\\n    /**\\n     * @notice Returns the order's predicate from the provided extension calldata.\\n     * @param extension The calldata from which the predicate is to be retrieved.\\n     * @return calldata Bytes representing the predicate.\\n     */\\n    function predicate(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.Predicate);\\n    }\\n\\n    /**\\n     * @notice Returns the maker's permit from the provided extension calldata.\\n     * @param extension The calldata from which the maker's permit is to be retrieved.\\n     * @return calldata Bytes representing the maker's permit.\\n     */\\n    function makerPermit(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.MakerPermit);\\n    }\\n\\n\\n    /**\\n     * @notice Returns the pre-interaction from the provided extension calldata.\\n     * @param extension The calldata from which the pre-interaction is to be retrieved.\\n     * @return calldata Bytes representing the pre-interaction.\\n     */\\n    function preInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.PreInteractionData);\\n    }\\n\\n    /**\\n     * @notice Returns the post-interaction from the provided extension calldata.\\n     * @param extension The calldata from which the post-interaction is to be retrieved.\\n     * @return calldata Bytes representing the post-interaction.\\n     */\\n    function postInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.PostInteractionData);\\n    }\\n\\n    /**\\n     * @notice Returns extra suffix data from the provided extension calldata.\\n     * @param extension The calldata from which the extra suffix data is to be retrieved.\\n     * @return calldata Bytes representing the extra suffix data.\\n     */\\n    function customData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        if (extension.length < 0x20) return msg.data[:0];\\n        uint256 offsets = uint256(bytes32(extension));\\n        unchecked {\\n            return extension[0x20 + (offsets >> 224):];\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves a specific field from the provided extension calldata.\\n     * @dev The first 32 bytes of an extension calldata contain offsets to the end of each field within the calldata.\\n     * @param extension The calldata from which the field is to be retrieved.\\n     * @param field The specific dynamic field to retrieve from the extension.\\n     * @return calldata Bytes representing the requested field.\\n     */\\n    function _get(bytes calldata extension, DynamicField field) private pure returns(bytes calldata) {\\n        if (extension.length < 0x20) return msg.data[:0];\\n\\n        Offsets offsets;\\n        bytes calldata concat;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            offsets := calldataload(extension.offset)\\n            concat.offset := add(extension.offset, 0x20)\\n            concat.length := sub(extension.length, 0x20)\\n        }\\n\\n        return offsets.get(concat, uint256(field));\\n    }\\n}\\n\",\"keccak256\":\"0x0e1ef5b959f77126f61c10e11fcd6043832baf9260cfb2bcf9bff8e446bae65d\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-protocol/libraries/MakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype MakerTraits is uint256;\\n\\n/**\\n * @title MakerTraitsLib\\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\\n * @dev\\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\\n * High bits are used for flags\\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\\n * 253 bit                                  - unused\\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\\n\\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n * uint80 last 10 bytes of allowed sender address (0 if any)\\n * uint40 expiration timestamp (0 if none)\\n * uint40 nonce or epoch\\n * uint40 series\\n */\\nlibrary MakerTraitsLib {\\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\\n    uint256 private constant _EXPIRATION_OFFSET = 80;\\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\\n    uint256 private constant _SERIES_OFFSET = 160;\\n    uint256 private constant _SERIES_MASK = type(uint40).max;\\n\\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\\n\\n    /**\\n     * @notice Checks if the order has the extension flag set.\\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the flag is set.\\n     */\\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker allows a specific taker to fill the order.\\n     * @param makerTraits The traits of the maker.\\n     * @param sender The address of the taker to be checked.\\n     * @return result A boolean indicating whether the taker is allowed.\\n     */\\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the expiration time of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The expiration timestamp of the order.\\n     */\\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the order has expired.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the order has expired.\\n     */\\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\\n        uint256 expiration = getExpirationTime(makerTraits);\\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Returns the nonce or epoch of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The nonce or epoch of the order.\\n     */\\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the series of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The series of the order.\\n     */\\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows partial fills.\\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows partial fills.\\n      */\\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs pre-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\\n     */\\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs post-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\\n     */\\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows multiple fills.\\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows multiple fills.\\n      */\\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the bit invalidator should be used.\\n      * True if the order requires the use of the bit invalidator.\\n      */\\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to check the epoch.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\\n     */\\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker uses permit2.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker uses permit2.\\n     */\\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to unwraps WETH.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\\n     */\\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9506febc99293a286356a03cb150ad82ccb88be1b4c908183e1273b41fcb902c\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-protocol/libraries/OffsetsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype Offsets is uint256;\\n\\n/// @title OffsetsLib\\n/// @dev A library for retrieving values by offsets from a concatenated calldata.\\nlibrary OffsetsLib {\\n\\n    /// @dev Error to be thrown when the offset is out of bounds.\\n    error OffsetOutOfBounds();\\n\\n    /**\\n     * @notice Retrieves the field value calldata corresponding to the provided field index from the concatenated calldata.\\n     * @dev \\n     * The function performs the following steps:\\n     * 1. Retrieve the start and end of the segment corresponding to the provided index from the offsets array.\\n     * 2. Get the value from segment using offset and length calculated based on the start and end of the segment.\\n     * 3. Throw `OffsetOutOfBounds` error if the length of the segment is greater than the length of the concatenated data.\\n     * @param offsets The offsets encoding the start and end of each segment within the concatenated calldata.\\n     * @param concat The concatenated calldata.\\n     * @param index The index of the segment to retrieve. The field index 0 corresponds to the lowest bytes of the offsets array.\\n     * @return result The calldata from a segment of the concatenated calldata corresponding to the provided index.\\n     */\\n    function get(Offsets offsets, bytes calldata concat, uint256 index) internal pure returns(bytes calldata result) {\\n        bytes4 exception = OffsetOutOfBounds.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            let bitShift := shl(5, index)                                   // bitShift = index * 32\\n            let begin := and(0xffffffff, shr(bitShift, shl(32, offsets)))   // begin = offsets[ bitShift : bitShift + 32 ]\\n            let end := and(0xffffffff, shr(bitShift, offsets))              // end   = offsets[ bitShift + 32 : bitShift + 64 ]\\n            result.offset := add(concat.offset, begin)\\n            result.length := sub(end, begin)\\n            if gt(end, concat.length) {\\n                mstore(0, exception)\\n                revert(0, 4)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb28030050b4c7b78e0ab596a98d3f437c1fce386b8de0a56a557209e0754636b\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-protocol/libraries/TakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype TakerTraits is uint256;\\n\\n/**\\n * @title TakerTraitsLib\\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\\n * @dev The TakerTraits are structured as follows:\\n * High bits are used for flags\\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker\\u2019s funds transfer.\\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\\n */\\nlibrary TakerTraitsLib {\\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\\n\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\\n\\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Checks if the args should contain target address.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the args should contain target address.\\n     */\\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the extension calldata encoded in the takerTraits.\\n     */\\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the interaction calldata encoded in the takerTraits.\\n     */\\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the taking amount should be calculated based on making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\\n     */\\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order should unwrap WETH.\\n     */\\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should skip maker's permit execution.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order don't apply permit.\\n     */\\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order uses the permit2 instead of permit.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order uses the permit2.\\n     */\\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the threshold amount from the takerTraits.\\n     * The maximum amount a taker agrees to give in exchange for a making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The threshold amount encoded in the takerTraits.\\n     */\\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x144f154a46e8daa0fec5b8215f1d8d3b694cb939236aa7bf89976b27965c2837\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/FeeBank.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\nimport { UniERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IFeeBankCharger } from \\\"./interfaces/IFeeBankCharger.sol\\\";\\nimport { IFeeBank } from \\\"./interfaces/IFeeBank.sol\\\";\\n\\n/**\\n * @title FeeBank\\n * @notice FeeBank contract introduces a credit system for paying fees.\\n * A user can deposit tokens to the FeeBank contract, obtain credits and then use them to pay fees.\\n * @dev FeeBank is coupled with FeeBankCharger to actually charge fees.\\n */\\ncontract FeeBank is IFeeBank, Ownable {\\n    using SafeERC20 for IERC20;\\n    using UniERC20 for IERC20;\\n\\n    error ZeroAddress();\\n\\n    IERC20 private immutable _FEE_TOKEN;\\n    IFeeBankCharger private immutable _CHARGER;\\n\\n    mapping(address account => uint256 availableCredit) private _accountDeposits;\\n\\n    constructor(IFeeBankCharger charger, IERC20 feeToken, address owner) Ownable(owner) {\\n        if (address(feeToken) == address(0)) revert ZeroAddress();\\n        _CHARGER = charger;\\n        _FEE_TOKEN = feeToken;\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-availableCredit}.\\n     */\\n    function availableCredit(address account) external view returns (uint256) {\\n        return _CHARGER.availableCredit(account);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-deposit}.\\n     */\\n    function deposit(uint256 amount) external returns (uint256) {\\n        return _depositFor(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-depositFor}.\\n     */\\n    function depositFor(address account, uint256 amount) external returns (uint256) {\\n        return _depositFor(account, amount);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-depositWithPermit}.\\n     */\\n    function depositWithPermit(uint256 amount, bytes calldata permit) external returns (uint256) {\\n        return depositForWithPermit(msg.sender, amount, permit);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-depositForWithPermit}.\\n     */\\n    function depositForWithPermit(address account, uint256 amount, bytes calldata permit) public returns (uint256) {\\n        _FEE_TOKEN.safePermit(permit);\\n        return _depositFor(account, amount);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-withdraw}.\\n     */\\n    function withdraw(uint256 amount) external returns (uint256) {\\n        return _withdrawTo(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBank-withdrawTo}.\\n     */\\n    function withdrawTo(address account, uint256 amount) external returns (uint256) {\\n        return _withdrawTo(account, amount);\\n    }\\n\\n    /**\\n     * @notice Admin method returns commissions spent by users.\\n     * @param accounts Accounts whose commissions are being withdrawn.\\n     * @return totalAccountFees The total amount of accounts commissions.\\n     */\\n    function gatherFees(address[] calldata accounts) external onlyOwner returns (uint256 totalAccountFees) {\\n        uint256 accountsLength = accounts.length;\\n        unchecked {\\n            for (uint256 i = 0; i < accountsLength; ++i) {\\n                address account = accounts[i];\\n                uint256 accountDeposit = _accountDeposits[account];\\n                uint256 availableCredit_ = _CHARGER.availableCredit(account);\\n                _accountDeposits[account] = availableCredit_;\\n                totalAccountFees += accountDeposit - availableCredit_; // overflow is impossible due to checks in FeeBankCharger\\n            }\\n        }\\n        _FEE_TOKEN.safeTransfer(msg.sender, totalAccountFees);\\n    }\\n\\n    function _depositFor(address account, uint256 amount) internal returns (uint256 totalAvailableCredit) {\\n        if (account == address(0)) revert ZeroAddress();\\n        _FEE_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\\n        unchecked {\\n            _accountDeposits[account] += amount; // overflow is impossible due to limited _FEE_TOKEN supply\\n        }\\n        totalAvailableCredit = _CHARGER.increaseAvailableCredit(account, amount);\\n    }\\n\\n    function _withdrawTo(address account, uint256 amount) internal returns (uint256 totalAvailableCredit) {\\n        totalAvailableCredit = _CHARGER.decreaseAvailableCredit(msg.sender, amount);\\n        unchecked {\\n            _accountDeposits[msg.sender] -= amount; // underflow is impossible due to checks in FeeBankCharger\\n        }\\n        _FEE_TOKEN.safeTransfer(account, amount);\\n    }\\n\\n    /**\\n     * @notice Retrieves funds accidently sent directly to the contract address\\n     * @param token ERC20 token to retrieve\\n     * @param amount amount to retrieve\\n     */\\n    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {\\n        token.uniTransfer(payable(msg.sender), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xa02a28c3cfd605d59cb08c9c7f85a773289c417b769e732ecf557cd335c87bf8\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/FeeBankCharger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IFeeBank } from \\\"./interfaces/IFeeBank.sol\\\";\\nimport { IFeeBankCharger } from \\\"./interfaces/IFeeBankCharger.sol\\\";\\nimport { FeeBank } from \\\"./FeeBank.sol\\\";\\n\\n/**\\n * @title FeeBankCharger\\n * @notice FeeBankCharger contract implements logic to increase or decrease users' credits in FeeBank.\\n */\\ncontract FeeBankCharger is IFeeBankCharger {\\n    error OnlyFeeBankAccess();\\n    error NotEnoughCredit();\\n\\n    /**\\n     * @notice See {IFeeBankCharger-feeBank}.\\n     */\\n    IFeeBank public immutable FEE_BANK;\\n    mapping(address => uint256) private _creditAllowance;\\n\\n    /**\\n     * @dev Modifier to check if the sender is a FEE_BANK contract.\\n     */\\n    modifier onlyFeeBank() {\\n        if (msg.sender != address(FEE_BANK)) revert OnlyFeeBankAccess();\\n        _;\\n    }\\n\\n    constructor(IERC20 feeToken, address owner) {\\n        FEE_BANK = new FeeBank(this, feeToken, owner);\\n    }\\n\\n    /**\\n     * @notice See {IFeeBankCharger-availableCredit}.\\n     */\\n    function availableCredit(address account) external view returns (uint256) {\\n        return _creditAllowance[account];\\n    }\\n\\n    /**\\n     * @notice See {IFeeBankCharger-increaseAvailableCredit}.\\n     */\\n    function increaseAvailableCredit(address account, uint256 amount) external onlyFeeBank returns (uint256 allowance) {\\n        allowance = _creditAllowance[account];\\n        unchecked {\\n            allowance += amount; // overflow is impossible due to limited _token supply\\n        }\\n        _creditAllowance[account] = allowance;\\n    }\\n\\n    /**\\n     * @notice See {IFeeBankCharger-decreaseAvailableCredit}.\\n     */\\n    function decreaseAvailableCredit(address account, uint256 amount) external onlyFeeBank returns (uint256 allowance) {\\n        return _creditAllowance[account] -= amount; // checked math is needed to prevent underflow\\n    }\\n\\n    /**\\n     * @notice Internal function that charges a specified fee from a given account's credit allowance.\\n     * @dev Reverts with 'NotEnoughCredit' if the account's credit allowance is insufficient to cover the fee.\\n     * @param account The address of the account from which the fee is being charged.\\n     * @param fee The amount of fee to be charged from the account.\\n     */\\n    function _chargeFee(address account, uint256 fee) internal virtual {\\n        if (fee > 0) {\\n            uint256 currentAllowance = _creditAllowance[account];\\n            if (currentAllowance < fee) revert NotEnoughCredit();\\n            unchecked {\\n                _creditAllowance[account] = currentAllowance - fee;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe02357d8d2dfaabfc0477fc4093aeea9bb33b81688e8a2d2b016d4dd2eafd4b2\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/extensions/BaseExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { IOrderMixin } from \\\"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\\\";\\nimport { IPostInteraction } from \\\"@1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol\\\";\\nimport { IPreInteraction } from \\\"@1inch/limit-order-protocol-contract/contracts/interfaces/IPreInteraction.sol\\\";\\nimport { IAmountGetter } from \\\"@1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol\\\";\\n\\n/**\\n * @title Base Extension contract\\n * @notice Contract to define the basic functionality for the limit orders settlement.\\n */\\ncontract BaseExtension is IPreInteraction, IPostInteraction, IAmountGetter {\\n    error OnlyLimitOrderProtocol();\\n\\n    uint256 private constant _BASE_POINTS = 10_000_000; // 100%\\n    uint256 private constant _GAS_PRICE_BASE = 1_000_000; // 1000 means 1 Gwei\\n\\n    address private immutable _LIMIT_ORDER_PROTOCOL;\\n\\n    /// @dev Modifier to check if the caller is the limit order protocol contract.\\n    modifier onlyLimitOrderProtocol() {\\n        if (msg.sender != _LIMIT_ORDER_PROTOCOL) revert OnlyLimitOrderProtocol();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract.\\n     * @param limitOrderProtocol The limit order protocol contract.\\n     */\\n    constructor(address limitOrderProtocol) {\\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\\n    }\\n\\n    /**\\n     * See {IAmountGetter-getMakingAmount}\\n     */\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata /* extension */,\\n        bytes32 /* orderHash */,\\n        address /* taker */,\\n        uint256 takingAmount,\\n        uint256 /* remainingMakingAmount */,\\n        bytes calldata extraData\\n    ) external view returns (uint256) {\\n        uint256 rateBump = _getRateBump(extraData);\\n        return\\n            Math.mulDiv(\\n                order.makingAmount,\\n                takingAmount * _BASE_POINTS,\\n                order.takingAmount * (_BASE_POINTS + rateBump)\\n            );\\n    }\\n\\n    /**\\n     * See {IAmountGetter-getTakingAmount}\\n     */\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata /* extension */,\\n        bytes32 /* orderHash */,\\n        address /* taker */,\\n        uint256 makingAmount,\\n        uint256 /* remainingMakingAmount */,\\n        bytes calldata extraData\\n    ) external view returns (uint256) {\\n        uint256 rateBump = _getRateBump(extraData);\\n        return\\n            Math.mulDiv(\\n                order.takingAmount,\\n                makingAmount * (_BASE_POINTS + rateBump),\\n                order.makingAmount * _BASE_POINTS,\\n                Math.Rounding.Ceil\\n            );\\n    }\\n\\n    /**\\n     * See {IPreInteraction-preInteraction}\\n     */\\n    function preInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external onlyLimitOrderProtocol {\\n        _preInteraction(\\n            order,\\n            extension,\\n            orderHash,\\n            taker,\\n            makingAmount,\\n            takingAmount,\\n            remainingMakingAmount,\\n            extraData\\n        );\\n    }\\n\\n    /**\\n     * See {IPostInteraction-postInteraction}\\n     */\\n    function postInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external onlyLimitOrderProtocol {\\n        _postInteraction(\\n            order,\\n            extension,\\n            orderHash,\\n            taker,\\n            makingAmount,\\n            takingAmount,\\n            remainingMakingAmount,\\n            extraData\\n        );\\n    }\\n\\n    function _preInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) internal virtual {}\\n\\n    function _postInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) internal virtual {\\n        // Allows to add custom postInteractions\\n        if (extraData.length > 20) {\\n            IPostInteraction(address(bytes20(extraData))).postInteraction(\\n                order,\\n                extension,\\n                orderHash,\\n                taker,\\n                makingAmount,\\n                takingAmount,\\n                remainingMakingAmount,\\n                extraData[20:extraData.length - 1]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Parses auction rate bump data from the `auctionDetails` field.\\n     * `gasBumpEstimate` and `gasPriceEstimate` are used to estimate the transaction costs\\n     * which are then offset from the auction rate bump.\\n     * @param auctionDetails AuctionDetails is a tightly packed struct of the following format:\\n     * ```\\n     * struct AuctionDetails {\\n     *     bytes3 gasBumpEstimate;\\n     *     bytes4 gasPriceEstimate;\\n     *     bytes4 auctionStartTime;\\n     *     bytes3 auctionDuration;\\n     *     bytes3 initialRateBump;\\n     *     (bytes3,bytes2)[N] pointsAndTimeDeltas;\\n     * }\\n     * ```\\n     * @return rateBump The rate bump.\\n     */\\n    function _getRateBump(bytes calldata auctionDetails) private view returns (uint256) {\\n        unchecked {\\n            uint256 gasBumpEstimate = uint24(bytes3(auctionDetails[0:3]));\\n            uint256 gasPriceEstimate = uint32(bytes4(auctionDetails[3:7]));\\n            uint256 gasBump = gasBumpEstimate == 0 || gasPriceEstimate == 0\\n                ? 0\\n                : (gasBumpEstimate * block.basefee) / gasPriceEstimate / _GAS_PRICE_BASE;\\n            uint256 auctionStartTime = uint32(bytes4(auctionDetails[7:11]));\\n            uint256 auctionFinishTime = auctionStartTime + uint24(bytes3(auctionDetails[11:14]));\\n            uint256 initialRateBump = uint24(bytes3(auctionDetails[14:17]));\\n            uint256 auctionBump = _getAuctionBump(\\n                auctionStartTime,\\n                auctionFinishTime,\\n                initialRateBump,\\n                auctionDetails[17:]\\n            );\\n            return auctionBump > gasBump ? auctionBump - gasBump : 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates auction price bump. Auction is represented as a piecewise linear function with `N` points.\\n     * Each point is represented as a pair of `(rateBump, timeDelta)`, where `rateBump` is the\\n     * rate bump in basis points and `timeDelta` is the time delta in seconds.\\n     * The rate bump is interpolated linearly between the points.\\n     * The last point is assumed to be `(0, auctionDuration)`.\\n     * @param auctionStartTime The time when the auction starts.\\n     * @param auctionFinishTime The time when the auction finishes.\\n     * @param initialRateBump The initial rate bump.\\n     * @param pointsAndTimeDeltas The points and time deltas structure.\\n     * @return The rate bump at the current time.\\n     */\\n    function _getAuctionBump(\\n        uint256 auctionStartTime,\\n        uint256 auctionFinishTime,\\n        uint256 initialRateBump,\\n        bytes calldata pointsAndTimeDeltas\\n    ) private view returns (uint256) {\\n        unchecked {\\n            if (block.timestamp <= auctionStartTime) {\\n                return initialRateBump;\\n            } else if (block.timestamp >= auctionFinishTime) {\\n                return 0;\\n            }\\n\\n            uint256 currentPointTime = auctionStartTime;\\n            uint256 currentRateBump = initialRateBump;\\n\\n            while (pointsAndTimeDeltas.length > 0) {\\n                uint256 nextRateBump = uint24(bytes3(pointsAndTimeDeltas[:3]));\\n                uint256 nextPointTime = currentPointTime + uint16(bytes2(pointsAndTimeDeltas[3:5]));\\n                if (block.timestamp <= nextPointTime) {\\n                    return\\n                        ((block.timestamp - currentPointTime) *\\n                            nextRateBump +\\n                            (nextPointTime - block.timestamp) *\\n                            currentRateBump) / (nextPointTime - currentPointTime);\\n                }\\n                currentRateBump = nextRateBump;\\n                currentPointTime = nextPointTime;\\n                pointsAndTimeDeltas = pointsAndTimeDeltas[5:];\\n            }\\n            return ((auctionFinishTime - block.timestamp) * currentRateBump) / (auctionFinishTime - currentPointTime);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdc8faa16c9267f8a2d12bceb9cbb56d7c35863b91459bdbacf3c77faa41980c6\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/extensions/ExtensionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Extension Library\\n * @notice Library to retrieve data from the bitmap.\\n */\\nlibrary ExtensionLib {\\n    bytes1 private constant _RESOLVER_FEE_FLAG = 0x01;\\n    bytes1 private constant _INTEGRATOR_FEE_FLAG = 0x02;\\n    bytes1 private constant _CUSTOM_RECEIVER_FLAG = 0x04;\\n    uint256 private constant _WHITELIST_SHIFT = 3;\\n\\n    /**\\n     * @notice Checks if the resolver fee is enabled\\n     * @param extraData Data to be processed in the extension\\n     * @return True if the resolver fee is enabled\\n     */\\n    function resolverFeeEnabled(bytes calldata extraData) internal pure returns (bool) {\\n        return extraData[extraData.length - 1] & _RESOLVER_FEE_FLAG == _RESOLVER_FEE_FLAG;\\n    }\\n\\n    /**\\n     * @notice Checks if the integrator fee is enabled\\n     * @param extraData Data to be processed in the extension\\n     * @return True if the integrator fee is enabled\\n     */\\n    function integratorFeeEnabled(bytes calldata extraData) internal pure returns (bool) {\\n        return extraData[extraData.length - 1] & _INTEGRATOR_FEE_FLAG == _INTEGRATOR_FEE_FLAG;\\n    }\\n\\n    /**\\n     * @notice Checks if the custom receiver is enabled\\n     * @param extraData Data to be processed in the extension\\n     * @return True if the custom receiver is specified\\n     */\\n    function hasCustomReceiver(bytes calldata extraData) internal pure returns (bool) {\\n        return extraData[extraData.length - 1] & _CUSTOM_RECEIVER_FLAG == _CUSTOM_RECEIVER_FLAG;\\n    }\\n\\n    /**\\n     * @notice Gets the number of resolvers in the whitelist\\n     * @param extraData Data to be processed in the extension\\n     * @return The number of resolvers in the whitelist\\n     */\\n    function resolversCount(bytes calldata extraData) internal pure returns (uint256) {\\n        return uint8(extraData[extraData.length - 1]) >> _WHITELIST_SHIFT;\\n    }\\n}\\n\",\"keccak256\":\"0xaa8ce41f4681d88b4bc2f109c538031248b3a6d384a959777383ab33f5ef4696\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/extensions/ResolverValidationExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IOrderMixin } from \\\"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\\\";\\nimport { FeeBankCharger } from \\\"../FeeBankCharger.sol\\\";\\nimport { BaseExtension } from \\\"./BaseExtension.sol\\\";\\nimport { ExtensionLib } from \\\"./ExtensionLib.sol\\\";\\n\\n/**\\n * @title Resolver Validation Extension\\n * @notice This abstract contract combines functionalities to enhance security and compliance in the order execution process.\\n * Ensures that only transactions from whitelisted resolvers or resolvers who own specific accessToken are processed within the post-interaction phase of order execution.\\n * Additionally, it allows charging a fee to resolvers in the `postInteraction` method, providing a mechanism for resolver fee management.\\n */\\nabstract contract ResolverValidationExtension is BaseExtension, FeeBankCharger {\\n    using ExtensionLib for bytes;\\n\\n    error ResolverCanNotFillOrder();\\n\\n    uint256 private constant _ORDER_FEE_BASE_POINTS = 1e15;\\n    /// @notice Contract address whose tokens allow filling limit orders with a fee for resolvers that are outside the whitelist\\n    IERC20 private immutable _ACCESS_TOKEN;\\n\\n    constructor(IERC20 feeToken, IERC20 accessToken, address owner) FeeBankCharger(feeToken, owner) {\\n        _ACCESS_TOKEN = accessToken;\\n    }\\n\\n    /**\\n     * @dev Validates whether the resolver is whitelisted.\\n     * @param allowedTime The time after which interaction with the order is allowed.\\n     * @param whitelist Whitelist is tightly packed struct of the following format:\\n     * ```\\n     * (bytes10,bytes2)[N] resolversAddressesAndTimeDeltas;\\n     * ```\\n     * Resolvers in the list are sorted in ascending order by the time when they are allowed to interact with the order.\\n     * Time deltas represent the time in seconds between the adjacent resolvers.\\n     * Only 10 lowest bytes of the resolver address are used for comparison.\\n     * @param whitelistSize The amount of resolvers in the whitelist.\\n     * @param resolver The resolver to check.\\n     * @return Whether the resolver is whitelisted.\\n     */\\n    function _isWhitelisted(\\n        uint256 allowedTime,\\n        bytes calldata whitelist,\\n        uint256 whitelistSize,\\n        address resolver\\n    ) internal view virtual returns (bool) {\\n        unchecked {\\n            uint80 maskedResolverAddress = uint80(uint160(resolver));\\n            for (uint256 i = 0; i < whitelistSize; i++) {\\n                uint80 whitelistedAddress = uint80(bytes10(whitelist[:10]));\\n                allowedTime += uint16(bytes2(whitelist[10:12])); // add next time delta\\n                if (maskedResolverAddress == whitelistedAddress) {\\n                    return allowedTime <= block.timestamp;\\n                } else if (allowedTime > block.timestamp) {\\n                    return false;\\n                }\\n                whitelist = whitelist[12:];\\n            }\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the resolver fee.\\n     * @param fee Scaled resolver fee.\\n     * @param orderMakingAmount Making amount from the order.\\n     * @param actualMakingAmount Making amount that was actually filled.\\n     * @return resolverFee Calculated resolver fee.\\n     */\\n    function _getResolverFee(\\n        uint256 fee,\\n        uint256 orderMakingAmount,\\n        uint256 actualMakingAmount\\n    ) internal pure virtual returns (uint256) {\\n        return (fee * _ORDER_FEE_BASE_POINTS * actualMakingAmount) / orderMakingAmount;\\n    }\\n\\n    /**\\n     * @param extraData Structured data of length n bytes, segmented as follows:\\n     * [0:4] - Resolver fee information.\\n     * [4:8] - The time after which interaction with the order is allowed.\\n     * [8:k] - Data as defined by the `whitelist` parameter for the `_isWhitelisted` method,\\n     *         where k depends on the amount of resolvers in the whitelist, as indicated by the bitmap in the last byte.\\n     * [k:n] - ExtraData for other extensions, not utilized by this validation extension.\\n     * [n] - Bitmap indicating various usage flags and values.\\n     *       The bitmask xxxx xxx1 signifies resolver fee usage.\\n     *       The bitmask VVVV Vxxx represents the number of resolvers in the whitelist, where the V bits denote the count of resolvers.\\n     *       The remaining bits in this bitmap are not used by this extension.\\n     */\\n    function _postInteraction(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) internal virtual override {\\n        bool feeEnabled = extraData.resolverFeeEnabled();\\n        uint256 resolversCount = extraData.resolversCount();\\n        unchecked {\\n            uint256 resolverFee;\\n            if (feeEnabled) {\\n                resolverFee = _getResolverFee(uint256(uint32(bytes4(extraData[:4]))), order.makingAmount, makingAmount);\\n                extraData = extraData[4:];\\n            }\\n\\n            uint256 allowedTime = uint32(bytes4(extraData[0:4]));\\n            extraData = extraData[4:];\\n            uint256 whitelistSize = resolversCount * 12;\\n            if (!_isWhitelisted(allowedTime, extraData[:whitelistSize], resolversCount, taker)) {\\n                // resolversCount always > 0 on prod\\n                if (allowedTime > block.timestamp || _ACCESS_TOKEN.balanceOf(taker) == 0)\\n                    revert ResolverCanNotFillOrder();\\n                if (feeEnabled) {\\n                    _chargeFee(taker, resolverFee);\\n                }\\n            }\\n            super._postInteraction(\\n                order,\\n                extension,\\n                orderHash,\\n                taker,\\n                makingAmount,\\n                takingAmount,\\n                remainingMakingAmount,\\n                extraData[whitelistSize:]\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xecdf8b8b6b92eca690c4ff7c2bd14aae29370a4ef9d22904a9cbb54b6a3eed2a\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/interfaces/IFeeBank.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFeeBank {\\n    /**\\n     * @notice Returns the available credit for a given account in the FeeBank contract.\\n     * @param account The address of the account for which the available credit is being queried.\\n     * @return availableCredit The available credit of the queried account.\\n     */\\n    function availableCredit(address account) external view returns (uint256 availableCredit);\\n\\n    /**\\n     * @notice Increases the caller's available credit by the specified amount.\\n     * @param amount The amount of credit to be added to the caller's account.\\n     * @return totalAvailableCredit The updated available credit of the caller's account.\\n     */\\n    function deposit(uint256 amount) external returns (uint256 totalAvailableCredit);\\n\\n    /**\\n     * @notice Increases the specified account's available credit by the specified amount.\\n     * @param account The address of the account for which the available credit is being increased.\\n     * @param amount The amount of credit to be added to the account.\\n     * @return totalAvailableCredit The updated available credit of the specified account.\\n     */\\n    function depositFor(address account, uint256 amount) external returns (uint256 totalAvailableCredit);\\n\\n    /**\\n     * @notice Increases the caller's available credit by a specified amount with permit.\\n     * @param amount The amount of credit to be added to the caller's account.\\n     * @param permit The permit data authorizing the transaction.\\n     * @return totalAvailableCredit The updated available credit of the caller's account.\\n     */\\n    function depositWithPermit(uint256 amount, bytes calldata permit) external returns (uint256 totalAvailableCredit);\\n\\n    /**\\n     * @notice Increases the specified account's available credit by a specified amount with permit.\\n     * @param account The address of the account for which the available credit is being increased.\\n     * @param amount The amount of credit to be added to the account.\\n     * @param permit The permit data authorizing the transaction.\\n     * @return totalAvailableCredit The updated available credit of the specified account.\\n     */\\n    function depositForWithPermit(\\n        address account,\\n        uint256 amount,\\n        bytes calldata permit\\n    ) external returns (uint256 totalAvailableCredit);\\n\\n    /**\\n     * @notice Withdraws a specified amount of credit from the caller's account.\\n     * @param amount The amount of credit to be withdrawn from the caller's account.\\n     * @return totalAvailableCredit The updated available credit of the caller's account.\\n     */\\n    function withdraw(uint256 amount) external returns (uint256 totalAvailableCredit);\\n\\n    /**\\n     * @notice Withdraws a specified amount of credit to the specified account.\\n     * @param account The address of the account to which the credit is being withdrawn.\\n     * @param amount The amount of credit to be withdrawn.\\n     * @return totalAvailableCredit The updated available credit of the caller's account.\\n     */\\n    function withdrawTo(address account, uint256 amount) external returns (uint256 totalAvailableCredit);\\n}\\n\",\"keccak256\":\"0xa881e76f17f764a9de8aa1b4eaad4e190541485badd5396d46ca609bf03dd586\",\"license\":\"MIT\"},\"contracts/1inch/limit-order-settlement/interfaces/IFeeBankCharger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IFeeBank } from \\\"./IFeeBank.sol\\\";\\n\\ninterface IFeeBankCharger {\\n    /**\\n     * @notice Returns the instance of the FeeBank contract.\\n     * @return The instance of the FeeBank contract.\\n     */\\n    function FEE_BANK() external view returns (IFeeBank); // solhint-disable-line func-name-mixedcase\\n\\n    /**\\n     * @notice Returns the available credit for a given account.\\n     * @param account The address of the account for which the available credit is being queried.\\n     * @return The available credit of the queried account.\\n     */\\n    function availableCredit(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice Increases the available credit of a given account by a specified amount.\\n     * @param account The address of the account for which the available credit is being increased.\\n     * @param amount The amount by which the available credit will be increased.\\n     * @return allowance The updated available credit of the specified account.\\n     */\\n    function increaseAvailableCredit(address account, uint256 amount) external returns (uint256 allowance);\\n\\n    /**\\n     * @notice Decreases the available credit of a given account by a specified amount.\\n     * @param account The address of the account for which the available credit is being decreased.\\n     * @param amount The amount by which the available credit will be decreased.\\n     * @return allowance The updated available credit of the specified account.\\n     */\\n    function decreaseAvailableCredit(address account, uint256 amount) external returns (uint256 allowance);\\n}\\n\",\"keccak256\":\"0xef4750e40bf2488873716b2e2f9315e69ac9e9c65bb5de2a16e39be6f3b483ea\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101803462000310576001600160401b03601f62003bf438819003918201601f19168401919083831185841017620002fa578160c092869260409586528339810103126200031057620000528362000315565b92620000616020820162000315565b926200006f83830162000315565b6200007d6060840162000315565b926200009a60a062000092608084016200032a565b92016200032a565b96806080528551610dc59788820198828a10878b1117620002fa5762002e2f83393089526001600160a01b0390811660208a0152958616878901526000978190036060019088f08015620002f057851660a0528260c05260e052845190610baa8083019083821086831117620002dc5783926200013992869262002285863963ffffffff90911681526001600160a01b03909116602082015260400190565b039086f0958615620002d25783610100971687528451926108fe8085019185831090831117620002be5791849391620001929362001987863963ffffffff90911681526001600160a01b03909116602082015260400190565b039084f0928315620002b3575080610120931683526200023b620001f282865116763d602d80600a3d3981f3363d3d373d3d3d363d73000000906e5af43d82803e903d91602b57fd5bf36020528060115260881c17600052603760092090565b91610140928352845116763d602d80600a3d3981f3363d3d373d3d3d363d73000000906e5af43d82803e903d91602b57fd5bf36020528060115260881c17600052603760092090565b91610160928352519261164a94856200033d863960805185818161079f0152610fae015260a05185818161069c01528181610eb30152610f15015260c05185610dba015260e051856104640152518481816107170152610a9f0152518381816101e5015261041b0152518260f0015251816103df0152f35b8251903d90823e3d90fd5b634e487b7160e01b88526041600452602488fd5b84513d87823e3d90fd5b634e487b7160e01b89526041600452602489fd5b86513d89823e3d90fd5b634e487b7160e01b600052604160045260246000fd5b600080fd5b51906001600160a01b03821682036200031057565b519063ffffffff82168203620003105756fe60a080604052600436101561001357600080fd5b60006080526080513560e01c9081630986bdd514610f9b575080631d9671c314610f445780632ce26aeb14610efe5780633ee5ef1f14610e8f578063462ebde2146107835780635886216f146107465780637040f1731461070057806385eda2de14610678578063acf4ce5c14610641578063adf38ba11461044a578063ba55117714610404578063be58e91c146103b9578063d7ff8a8014610305578063dea024e41461012d5763fb6bd47e146100ca57600080fd5b3461012757610100806003193601126101275761011560209160405181600482372030907f0000000000000000000000000000000000000000000000000000000000000000906114c4565b6040516001600160a01b039091168152f35b60805180fd5b3660031901610120811261012757610100809112610127576001600160a01b036084358181168015929060c43580856102f3575b34036102e1576040516101738161119f565b600435815260243596876020830152604435604083015260643595866060840152608083015260a082019260a435845260c08301524260e01b60018060e01b0360e43516178060e08401526101d9610104359163ffffffff8160c01c169060e01c611169565b116102cf5761020991207f00000000000000000000000000000000000000000000000000000000000000006114e4565b941561024f575b7fc30e111dcc74fddc2c3a4d98ffb97adec4485c0a687946bf5b22c2a99c7ff96d6060868689876040519316835260208301526040820152a160805180f35b516040516323b872dd60e01b81523360048201526024810186905260448101919091526080519294939260209160649082855af190816102ab575b50156102995790918480610210565b60405163f405907160e01b8152600490fd5b90503d156102c7575060016080515114601f3d11165b8561028a565b3b15156102c1565b604051637a42074b60e11b8152600490fd5b6040516334f5151d60e01b8152600490fd5b6103009060a43590611169565b610161565b3461012757610324610316366110c5565b9550935050959350506111fe565b9060c08101359262989680928301908184116103895760a09161034691611140565b910135828102928184041490151715610389576103648282856112a9565b9282156103a1570961037c575b602090604051908152f35b6001810180911115610371575b634e487b7160e01b6080515260116004526024608051fd5b634e487b7160e01b6080515260126004526024608051fd5b3461012757610100806003193601126101275761011560209160405181600482372030907f0000000000000000000000000000000000000000000000000000000000000000906114c4565b3461012757608051366003190112610127576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101275761045836611043565b509750939594935050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303905061062f5761049d91611479565b60408051602080820195865292909301609f190135601081901b61ffff19169184019190915290926001600160f01b0392918316916104e981605e81015b03601f1981018352826111bc565b519020908435601e19863603018112156101275767ffffffffffffffff939086018035858111610127576005918160051b360388820113610127576040888a0135990135966040518981019167ffffffffffffffff60c01b8c60c01b16835289602883015260288252606082019082821090821117610619576040959493955251902092608051925b8284106105d5575050505016036105c35760018401809411610389576001928391604051956105a087611183565b865281860193845260805152526040608051209251835551910155608051608051f35b6040516309bde33960e01b8152600490fd5b92939192909184821b83018a013590818110156106055760805152895260016040608051205b9401929190610572565b9060805152895260016040608051206105fb565b634e487b7160e01b600052604160045260246000fd5b604051634ca8886760e01b8152600490fd5b3461012757602036600319011261012757600435608051526001602052604080608051206001815491015482519182526020820152f35b346101275760403660031901126101275761069161102d565b6001600160a01b03907f0000000000000000000000000000000000000000000000000000000000000000821633036106ee57166080515260805160205260206040608051206106e36024358254611176565b809155604051908152f35b60405163a454419960e01b8152600490fd5b3461012757608051366003190112610127576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610127576020366003190112610127576001600160a01b0361076761102d565b1660805152608051602052602060406080512054604051908152f35b346101275761079136611043565b9598939793969294909390927f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610e7d5786609f1981011161038957609f198701908560a0198901831061038957600160f81b8061080360a0198c01609f198d018b61154c565b35161461081960a0198b01609f198c018a61154c565b608051903560fb1c9180610e25575b8560041161012757833560e01c6003198701600c850211610127576108568a85600c8102600489018561156e565b15610d12575b5050506014600319600c830286030111610b67575b50505050838601609f1901905060e0870135600160fe1b1615610b5f57358060f01c60028110610b4d5760408051602081018c815260109490941b61ffff19169181019190915261090792906108ca81605e81016104db565b5190206080515260016020526040608051209060206040516108eb81611183565b6001845494858352015491829101529360a08a0135908b6113e1565b15610b3b575b6040519761091a8961119f565b885260208801526020850135604088015260018060a01b03166060870152606084013560808701528460a0870152603f19838201013560801c60c08701524260e01b60018060e01b03601f198584010135161760e087015260408401356080515060018060a01b03811615600014610b36575060208401355b604051928360a081011067ffffffffffffffff60a08601111761061957610ac3947f0e534c62f0afd2fa0f0fa71198e8aa2d549f24daf2bb47de0d5486c7ce9288ca936101a09360a0870160405286526020860192835260408601605f198383010135815260608701916fffffffffffffffffffffffffffffffff603f1985830101351683526080880193607f19910101358352604051938b51855260208c0151602086015260408c0151604086015260608c0151606086015260808c0151608086015260a08c015160a086015260c08c015160c086015260e08c015160e086015261010097518886015251610120850152516101408401525161016083015251610180820152a184207f00000000000000000000000000000000000000000000000000000000000000006114e4565b9260c0843191015111928315610ae1575b5050506102e15760805180f35b608080516370a0823160e01b905260049190915251919250602091906024908290606001356001600160a01b03165afa60805151901560203d1017610b295710818080610ad4565b6040513d608051823e3d90fd5b610993565b604051633aace85d60e21b8152600490fd5b6040516310d629d360e01b8152600490fd5b90503561090d565b6bffffffffffffffffffffffff19600c82028381016004013582811694929160149088036003190110610cf5575b5050600c8202850360031981016004199091011161038957600c8202850360041901601411610127578260601c3b1561012757610ca68e60e0938f8f948e6018928e610c546040519e8f9d8e9c8d9c8d6323175ef160e11b90528d600482359101528d602460208301359101528d604460408301359101528d606460608301359101528d608460808301359101528d60a460a08301359101528d60c460c0830135910152013560e48d01526101e06101048d01526101e48c01916115f3565b6101248a01979097526001600160a01b03166101448901526101648801526101848701526101a486018c9052858403600319016101c487015260805199600c93909302928390038219019201016115f3565b03916080519060601c5af18015610b2957610cc5575b80808080610871565b67ffffffffffffffff8111610cdd5760405288610cbc565b634e487b7160e01b6080515260416004526024608051fd5b600c8402870360140360040160031b82901b161692508e80610b95565b42108015610d90575b610d7e57610d2b575b808061085c565b8015610d245760018060a01b03881680608051526080516020526040608051205490828210610d6c576080515260805160205203604060805120558d610d24565b6040516353fe9bc960e11b8152600490fd5b6040516379288a5360e11b8152600490fd5b506040516370a0823160e01b81526001600160a01b038a81166004830152602090829060249082907f0000000000000000000000000000000000000000000000000000000000000000165afa908115610b295760805191610df3575b5015610d1b565b90506020813d602011610e1d575b81610e0e602093836111bc565b81010312610127575138610dec565b3d9150610e01565b9450509050609f19890160041161012757863560e01c66038d7ea4c6800090808281020482148115171561038957610e678d610e6c9360a08f01359302611140565b6111de565b90600488019160a3198b0194610828565b60405163692d508360e11b8152600490fd5b3461012757604036600319011261012757610ea861102d565b6001600160a01b03907f0000000000000000000000000000000000000000000000000000000000000000821633036106ee5716608051526080516020526020604060805120602435815401809155604051908152f35b3461012757608051366003190112610127576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461012757610f55610316366110c5565b906298968091828402938085048414901517156103895782018092116103895760209260a0610f8b610f939460c0850135611140565b9201356112a9565b604051908152f35b3461012757610fa936611043565b5050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633039650610feb955050505050505760805180f35b63692d508360e11b8152600490fd5b9181601f840112156110285782359167ffffffffffffffff8311611028576020838186019501011161102857565b600080fd5b600435906001600160a01b038216820361102857565b60031981016101e0811261102857610100136110285760049167ffffffffffffffff61010435818111611028578361107d91600401610ffa565b909390926101243592610144356001600160a01b03811681036110285792610164359261018435926101a435926101c435918211611028576110c191600401610ffa565b9091565b9060031982016101c0811261102857610100136110285760049167ffffffffffffffff9061010435828111611028578161110191600401610ffa565b909390926101243592610144356001600160a01b03811681036110285792610164359261018435926101a435918211611028576110c191600401610ffa565b8181029291811591840414171561115357565b634e487b7160e01b600052601160045260246000fd5b9190820180921161115357565b9190820391821161115357565b6040810190811067ffffffffffffffff82111761061957604052565b610100810190811067ffffffffffffffff82111761061957604052565b90601f8019910116810190811067ffffffffffffffff82111761061957604052565b81156111e8570490565b634e487b7160e01b600052601260045260246000fd5b908060031161102857813560e81c8160071161102857600383013560e01c90801580156112a1575b1561128a5750506000915b81600b1161102857600781013560e01c82600e116110285782601111611028576112779260101901916011810191600b600e83013560e81c92013560e81c810190611341565b81811115611283570390565b5050600090565b620f42409161129a9148026111de565b0491611231565b508115611226565b90918282029160001984820993838086109503948086039514611331578483111561131f5782910981600003821680920460028082600302188083028203028083028203028083028203028083028203028083028203028092029003029360018380600003040190848311900302920304170290565b60405163227bc15360e01b8152600490fd5b50509061133e92506111de565b90565b9193929091428110611354575050505090565b82939594924210156113d75790855b61137a575061133e939450820391429003026111de565b9060039086821161102857823560e81c906005928884116110285784013560f01c810194854211156113b757505092910194600419019485611363565b92509361133e9697508095508491935003934290030291420302016111de565b5060009450505050565b9291906113f7846113f28385611176565b611169565b60001991908281019081116111535783610e678661141493611140565b94810361142e575050505060028101809111611153571490565b808303611449575b5050505060018101809111611153571490565b6114539083611176565b9081019081116111535761146a92610e6791611140565b81146112835738808080611436565b919091602083106114bb5780359063ffffffff8260c01c169160e01c93601f190184116114aa578101602001920390565b6309605a0160e41b60005260046000fd5b50600091508190565b90605592600b92604051926040840152602083015281520160ff81532090565b6e5af43d82803e903d91602b57fd5bf390763d602d80600a3d3981f3363d3d373d3d3d363d7300000062ffffff8260881c161760005260781b17602052603760096000f5906001600160a01b0382161561153a57565b6040516330be1a3d60e21b8152600490fd5b90821015611558570190565b634e487b7160e01b600052603260045260246000fd5b9369ffffffffffffffffffff1692916000915b83831061159357505050505050600090565b600a9582871161102857600c968388116110285782013560f01c0195813560b01c86036115c65750505050505042101590565b95929394954284116115e7579295949360010192600b199092019101611581565b50505050505050600090565b908060209392818452848401376000828201840152601f01601f191601019056fea2646970667358221220a59aca2d89ac32c28ca38fc7a9b867efedc5590f33103149fce33e79671baebc64736f6c634300081700336101003461010f57601f6108fe38819003918201601f19168301916001600160401b0383118484101761011457808492604094855283398101031261010f5780519063ffffffff821680920361010f5760200151906001600160a01b038216820361010f573360c05260a0526080526e5af43d82803e903d91602b57fd5bf360205230601152763d602d80600a3d3981f3363d3d373d3d3d363d730000003060881c17600052603760092060e0526040516107d3908161012b82396080518161043d015260a051818181608a015261028f015260c0518181816101180152818161025801528181610379015261059c015260e05181818160ee0152818161022e0152818161034001526105720152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060408181526004918236101561001657600080fd5b60009260e08435811c9283630af97558146104115750826323305703146103a85782632dd310001461036357826334862b6a146103275782634649088b146101d15750816390d3252f146100b1575063f56cd69c1461007457600080fd5b346100ad57816003193601126100ad57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5080fd5b8383346100ad57610100806003193601126101cd576001600160a01b0391606435831691338390036101bd57600b605591835181898237208351907f00000000000000000000000000000000000000000000000000000000000000008583015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff81532083309116036101ae5761015360e435610672565b421061019f57509061016c9160a43591608435166106a2565b61017860c43533610727565b7f6e3be9294e58d10b9c8053cfd5e09871b67e442fe394d6b0870d336b9df984a98180a180f35b516337bf561360e11b81528490fd5b51635134a42560e11b81528490fd5b81516348f5c3ed60e01b81528690fd5b8280fd5b838591346101cd576101403660031901126101cd578335936001600160a01b038086169290919083870361032357602435926101008060431936011261031f578160a43516330361030f57600b60559188518160448237208851907f00000000000000000000000000000000000000000000000000000000000000008a83015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff815320309116036103005761012435901c7f00000000000000000000000000000000000000000000000000000000000000000142106102f257506102e4817fc4474c2790e13695f6d2b6f1d8e164290b55370f87a542fd7711abe0a1bf40ac959633906106a2565b82519182526020820152a180f35b83516337bf561360e11b8152fd5b508351635134a42560e11b8152fd5b86516348f5c3ed60e01b81528490fd5b8780fd5b8580fd5b505050346100ad57816003193601126100ad57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b505050346100ad57816003193601126100ad57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b838591346101cd576103b9366104e6565b92909160608401356001600160a01b031633036101bd5763ffffffff8185013580921c9160801c1681018091116103fe57421061019f5750906103fb91610546565b80f35b634e487b7160e01b855260118652602485fd5b90859185346104e257610423366104e6565b6370a0823160e01b845233878501529390926020816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa9081156104d85786916104a6575b50156101bd5763ffffffff8185013580921c9160a01c1681018091116103fe57421061019f5750906103fb91610546565b90506020813d6020116104d0575b816104c16020938361050e565b81010312610323575187610475565b3d91506104b4565b83513d88823e3d90fd5b8380fd5b906101206003198301126105095761010060043592602319011261050957602490565b600080fd5b90601f8019910116810190811067ffffffffffffffff82111761053057604052565b634e487b7160e01b600052604160045260246000fd5b9061055460e0820135610672565b421015610660576040906055600b83516101009081858237208451907f00000000000000000000000000000000000000000000000000000000000000008683015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153206001600160a01b0390309082160361064f5783600052602060002060208301350361063e579161063760c08361062f60209660a07fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc171059997013590808785013516906080850135166106a2565b013533610727565b51908152a1565b825163abab6bd760e01b8152600490fd5b8251635134a42560e11b8152600490fd5b6040516337bf561360e11b8152600490fd5b63ffffffff8160e01c9160c01c16810180911161068c5790565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b03169190826106be576106bc9250610727565b565b9060446020926000926040519163a9059cbb60e01b83526004830152602482015282855af19081610704575b50156106f257565b60405163fb7f507960e01b8152600490fd5b90503d1561071f5750600160005114601f3d11165b386106ea565b3b1515610719565b60008080809481945af1903d15610797573d9067ffffffffffffffff82116107835760405191610761601f8201601f19166020018461050e565b825260203d92013e5b1561077157565b604051638a0332d560e01b8152600490fd5b634e487b7160e01b81526041600452602490fd5b5061076a56fea2646970667358221220d18f767d07896f51a4caaf9b59be29080e55f33b7bc47a580184f9dcda649ab964736f6c634300081700336101003461011757601f610baa38819003918201601f19168301916001600160401b0383118484101761011c5780849260409485528339810103126101175780519063ffffffff82168092036101175760200151906001600160a01b0382168203610117573360c05260a0526080526e5af43d82803e903d91602b57fd5bf360205230601152763d602d80600a3d3981f3363d3d373d3d3d363d730000003060881c17600052603760092060e052604051610a779081610133823960805181818161010001526105ea015260a05181818160a101526103cf015260c0518181816104c00152818161081f015281816108ad0152610928015260e051818181610487015281816107f40152818161088201526108fd0152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060408181526004918236101561001657600080fd5b60009260e0908435821c9283630af97558146105b15750826323305703146104ef5782632dd31000146104aa57826334862b6a1461046e5782634649088b146103795782636c10c0c81461027357826390d3252f1461021b578263daff233e146100c857505063f56cd69c1461008b57600080fd5b346100c457816003193601126100c457602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5080fd5b91509134610217576101003660031901126102175780516370a0823160e01b815233838201526001600160a01b0393906020816024817f000000000000000000000000000000000000000000000000000000000000000089165afa90811561020d5786916101d7575b50156101c95763ffffffff60e43580921c9160601c1681018091116101b65742106101a957836101768461016361086b565b60a4359080604435169060843516610962565b61018260c435336109cb565b7f6e3be9294e58d10b9c8053cfd5e09871b67e442fe394d6b0870d336b9df984a98180a180f35b516337bf561360e11b8152fd5b634e487b7160e01b855260118352602485fd5b50516348f5c3ed60e01b8152fd5b90506020813d602011610205575b816101f26020938361075e565b81010312610201575138610131565b8580fd5b3d91506101e5565b83513d88823e3d90fd5b8380fd5b9150503461026f5761010036600319011261026f576001600160a01b0391606435831633036102625761024f60e435610796565b42106101a957836101768461016361086b565b516348f5c3ed60e01b8152fd5b8280fd5b8490843461026f5761014036600319011261026f578135916001600160a01b039060243590828216820361020157610100366043190112610201578260a43516330361036b57610124356102c6816107c6565b421061035c576102d590610796565b42101561034e576102e46107dd565b848652602086206064350361034057509161032b7fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc17105949260209460e4359160c43516610962565b61033861010435336109cb565b51908152a180f35b835163abab6bd760e01b8152fd5b83516337bf561360e11b8152fd5b5083516337bf561360e11b8152fd5b83516348f5c3ed60e01b8152fd5b8484833461026f5761014036600319011261026f576001600160a01b038435818116929083900361046a57602435916101003660431901126102015760a43516330361045a576103c76107dd565b61012435901c7f000000000000000000000000000000000000000000000000000000000000000001421061044a577fc4474c2790e13695f6d2b6f1d8e164290b55370f87a542fd7711abe0a1bf40ac939450811560001461043a5761042c81336109cb565b82519182526020820152a180f35b610445813384610962565b61042c565b82516337bf561360e11b81528590fd5b83516348f5c3ed60e01b81528690fd5b8480fd5b505050346100c457816003193601126100c457602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b505050346100c457816003193601126100c457517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b929150346102175761050036610736565b909390916001600160a01b0391906060840135831633036105a257830135610527816107c6565b421061035c5761053690610796565b42101561034e57610546836108e7565b8486526020862060208401350361034057509161033860c08361059a60209660a07fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc1710599970135903390608085013516610962565b0135336109cb565b5083516348f5c3ed60e01b8152fd5b85918534610217576105c236610736565b6370a0823160e01b855233858501529560209491936001600160a01b039290919086816024817f000000000000000000000000000000000000000000000000000000000000000088165afa90811561072c5788916106fb575b50156106ec578088013580911c63ffffffff82881c1681018091116106d95742106106ca5761064990610796565b4210156106bc57610659876108e7565b83865284862085880135036106ae575060c08661059a6103389360a07fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc17105999a0135908060608501351690608085013516610962565b825163abab6bd760e01b8152fd5b82516337bf561360e11b8152fd5b5082516337bf561360e11b8152fd5b634e487b7160e01b885260118352602488fd5b5082516348f5c3ed60e01b8152fd5b90508681813d8311610725575b610712818361075e565b8101031261072157518961061b565b8780fd5b503d610708565b85513d8a823e3d90fd5b906101206003198301126107595761010060043592602319011261075957602490565b600080fd5b90601f8019910116810190811067ffffffffffffffff82111761078057604052565b634e487b7160e01b600052604160045260246000fd5b63ffffffff8160e01c9160401c1681018091116107b05790565b634e487b7160e01b600052601160045260246000fd5b63ffffffff8160e01c911681018091116107b05790565b6055600b60405161010090816044823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff815320306001600160a01b039091160361085957565b604051635134a42560e11b8152600490fd5b6055600b60405161010090816004823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff815320306001600160a01b039091160361085957565b600b6055916040516101008092823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff815320306001600160a01b039091160361085957565b9160446020926000926040519163a9059cbb60e01b83526004830152602482015282855af190816109a8575b501561099657565b60405163fb7f507960e01b8152600490fd5b90503d156109c35750600160005114601f3d11165b3861098e565b3b15156109bd565b60008080809481945af1903d15610a3b573d9067ffffffffffffffff8211610a275760405191610a05601f8201601f19166020018461075e565b825260203d92013e5b15610a1557565b604051638a0332d560e01b8152600490fd5b634e487b7160e01b81526041600452602490fd5b50610a0e56fea2646970667358221220d6d35da45008eeaeeaa7aa59016bbc7d6db528f635476dd1679c84dee14bec4464736f6c6343000817003360c03461013257601f610dc538819003918201601f19168301916001600160401b03831184841017610137578084926060946040528339810103126101325780516001600160a01b0380821682036101325760208301519281841690818503610132576040015182811680910361013257801561011957600080546001600160a01b03198116831782556040519416907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a31561010a575060a052608052604051610c77908161014e823960805181818161023501528181610676015281816109ee0152610a6c015260a051818181610202015281816104f4015281816109a50152610b060152f35b63d92e233d60e01b8152600490fd5b604051631e4fbdf760e01b815260006004820152602490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe6040608081526004908136101561001557600080fd5b600091823560e01c8063205c2878146105ff5780632e1a7d4d146105de5780632f4f21e2146105b557806332d323a5146105695780635886216f146104ae578063715018a61461045457806378e3214f146103485780638da5cb5b1461031c57806397a2cb641461019a578063b6b55f2514610179578063bfe917341461012e5763f2fde38b146100a557600080fd5b3461012a57602036600319011261012a576100be610628565b906100c7610bac565b6001600160a01b0391821692831561011457505082546001600160a01b0319811683178455167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b51631e4fbdf760e01b8152908101849052602490fd5b8280fd5b5091346101765781600319360112610176576024359067ffffffffffffffff8211610176575060209261016761016f9236908301610643565b913533610671565b9051908152f35b80fd5b509134610176576020366003190112610176575061016f6020923533610a54565b50903461012a576020928360031936011261017657823567ffffffffffffffff80821161012a573660238301121561012a578185013590811161012a576024943660248360051b85010111610318579492916101f4610bac565b8295839460018060a01b03807f000000000000000000000000000000000000000000000000000000000000000016935b85881061025f578a8a8a61025982337f0000000000000000000000000000000000000000000000000000000000000000610bd8565b51908152f35b9091929394959698838a60051b83010135838116809103610314578089526001808d528a8a20548b51635886216f60e01b81528881018490529392918e8589818d5afa92831561030a578f908d946102ce575b600196508d5252818c8c20550301990196959493929190610224565b94958092939450813d8311610303575b6102e8818361093c565b810103126102ff57908e60019594939251936102b2565b8b80fd5b503d6102de565b8d513d8e823e3d90fd5b8880fd5b8380fd5b505034610344578160031936011261034457905490516001600160a01b039091168152602090f35b5080fd5b50903461012a578060031936011261012a5781356001600160a01b03811690818103610450576024359161037a610bac565b82610383578580f35b8015908115610432575b501561041e5750804710610410578380808093335af13d1561040b573d67ffffffffffffffff81116103f8578251906103d0601f8201601f19166020018361093c565b81528460203d92013e5b156103eb5750505b38808080808580f35b5163b12d13eb60e01b8152fd5b634e487b7160e01b855260418452602485fd5b6103da565b5051631e9acf1760e31b8152fd5b90915061042d92503390610bd8565b6103e2565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee9150143861038d565b8480fd5b833461017657806003193601126101765761046d610bac565b80546001600160a01b03198116825581906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b50919034610344576020928360031936011261012a57836104cd610628565b8351635886216f60e01b81526001600160a01b0391821693810193909352829060249082907f0000000000000000000000000000000000000000000000000000000000000000165afa92831561055e57809361052c575b505051908152f35b909192508382813d8311610557575b610545818361093c565b81010312610176575051903880610524565b503d61053b565b8251903d90823e3d90fd5b503461012a57606036600319011261012a57610583610628565b926044359067ffffffffffffffff82116101765750926105ab61016f92602095369101610643565b9160243590610671565b50503461034457806003193601126103445760209061016f6105d5610628565b60243590610a54565b509134610176576020366003190112610176575061016f6020923533610974565b50503461034457806003193601126103445760209061016f61061f610628565b60243590610974565b600435906001600160a01b038216820361063e57565b600080fd5b9181601f8401121561063e5782359167ffffffffffffffff831161063e576020838186019501011161063e57565b9290917f000000000000000000000000000000000000000000000000000000000000000090600090468061014414610926578061012c146109265761010414610911576e22d473030f116ddee9f6b43ac78ba35b604051928590816064146108a8575091600095918387969594604814610836578060e0146108145780610100146107f05780606014610761576101601461073e5750639fd5a6cf60e01b8352849160049181908584013701925af15b156107325761072f91610a54565b90565b6040513d6000823e3d90fd5b6302b67b5760e41b84526101649450859250906101609060048501375af1610721565b50908592506040602091610164966302b67b5760e41b875233600488015260248701526014816050880137841965ffffffffffff9080601484013560e01c0182166064890152601883013560e01c60848901523060a4890152601c83013560e01c011660c487015261010060e48701528161010487015282808201610124880137016101448501375af1610721565b50506323f2ebc360e21b835261010493859250906101009060048501375af1610721565b505063d505accf60e01b835260e4938592509060e09060048501375af1610721565b505084915092610104936323f2ebc360e21b845233600485015230602485015260206008602883013592803560e01c60448801528519600482013560e01c016064880152600160848801528360ff1c601b0160a48801520160c48601376001600160ff1b031660e48401525af1610721565b955050509083809360e49363d505accf60e01b845233600485015230602485015260206024604483013592828160448901376000198382013560e01c0160648801528360ff1c601b0160848801520160a48601376001600160ff1b031660c48401525af1610721565b6e225e31d15943971f47ad3022f714fa6106c5565b506e225e31d15943971f47ad3022f714fa6106c5565b90601f8019910116810190811067ffffffffffffffff82111761095e57604052565b634e487b7160e01b600052604160045260246000fd5b6040516342f6d16f60e11b815233600482015260248101839052600093929091602083604481886001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165af1928315610a49578593610a14575b506040610a1293953381526001602052208281540390557f0000000000000000000000000000000000000000000000000000000000000000610bd8565b565b92506020833d602011610a41575b81610a2f6020938361093c565b810103126104505791519160406109d5565b3d9150610a22565b6040513d87823e3d90fd5b6001600160a01b0391818316908115610b9a576064937f00000000000000000000000000000000000000000000000000000000000000006000604051906323b872dd60e01b8252336004830152306024830152846044830152602097889282855af19081610b77575b5015610b6557600092835260018552604080842080548401905551633ee5ef1f60e01b81526001600160a01b0394909416600485015260248401919091528391839160449183917f0000000000000000000000000000000000000000000000000000000000000000165af191821561073257600092610b3b57505090565b90809250813d8311610b5e575b610b52818361093c565b8101031261063e575190565b503d610b48565b60405163f405907160e01b8152600490fd5b90503d15610b925750600160005114601f3d11165b38610abd565b3b1515610b8c565b60405163d92e233d60e01b8152600490fd5b6000546001600160a01b03163303610bc057565b60405163118cdaa760e01b8152336004820152602490fd5b9160446020926000926040519163a9059cbb60e01b83526004830152602482015282855af19081610c1e575b5015610c0c57565b60405163fb7f507960e01b8152600490fd5b90503d15610c395750600160005114601f3d11165b38610c04565b3b1515610c3356fea2646970667358221220f2277cbc585cd22f12c90b2b5d6964ea6f5e4c0d87e6b226919f6d14487d425f64736f6c63430008170033",
  "deployedBytecode": "0x60a080604052600436101561001357600080fd5b60006080526080513560e01c9081630986bdd514610f9b575080631d9671c314610f445780632ce26aeb14610efe5780633ee5ef1f14610e8f578063462ebde2146107835780635886216f146107465780637040f1731461070057806385eda2de14610678578063acf4ce5c14610641578063adf38ba11461044a578063ba55117714610404578063be58e91c146103b9578063d7ff8a8014610305578063dea024e41461012d5763fb6bd47e146100ca57600080fd5b3461012757610100806003193601126101275761011560209160405181600482372030907f0000000000000000000000000000000000000000000000000000000000000000906114c4565b6040516001600160a01b039091168152f35b60805180fd5b3660031901610120811261012757610100809112610127576001600160a01b036084358181168015929060c43580856102f3575b34036102e1576040516101738161119f565b600435815260243596876020830152604435604083015260643595866060840152608083015260a082019260a435845260c08301524260e01b60018060e01b0360e43516178060e08401526101d9610104359163ffffffff8160c01c169060e01c611169565b116102cf5761020991207f00000000000000000000000000000000000000000000000000000000000000006114e4565b941561024f575b7fc30e111dcc74fddc2c3a4d98ffb97adec4485c0a687946bf5b22c2a99c7ff96d6060868689876040519316835260208301526040820152a160805180f35b516040516323b872dd60e01b81523360048201526024810186905260448101919091526080519294939260209160649082855af190816102ab575b50156102995790918480610210565b60405163f405907160e01b8152600490fd5b90503d156102c7575060016080515114601f3d11165b8561028a565b3b15156102c1565b604051637a42074b60e11b8152600490fd5b6040516334f5151d60e01b8152600490fd5b6103009060a43590611169565b610161565b3461012757610324610316366110c5565b9550935050959350506111fe565b9060c08101359262989680928301908184116103895760a09161034691611140565b910135828102928184041490151715610389576103648282856112a9565b9282156103a1570961037c575b602090604051908152f35b6001810180911115610371575b634e487b7160e01b6080515260116004526024608051fd5b634e487b7160e01b6080515260126004526024608051fd5b3461012757610100806003193601126101275761011560209160405181600482372030907f0000000000000000000000000000000000000000000000000000000000000000906114c4565b3461012757608051366003190112610127576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101275761045836611043565b509750939594935050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303905061062f5761049d91611479565b60408051602080820195865292909301609f190135601081901b61ffff19169184019190915290926001600160f01b0392918316916104e981605e81015b03601f1981018352826111bc565b519020908435601e19863603018112156101275767ffffffffffffffff939086018035858111610127576005918160051b360388820113610127576040888a0135990135966040518981019167ffffffffffffffff60c01b8c60c01b16835289602883015260288252606082019082821090821117610619576040959493955251902092608051925b8284106105d5575050505016036105c35760018401809411610389576001928391604051956105a087611183565b865281860193845260805152526040608051209251835551910155608051608051f35b6040516309bde33960e01b8152600490fd5b92939192909184821b83018a013590818110156106055760805152895260016040608051205b9401929190610572565b9060805152895260016040608051206105fb565b634e487b7160e01b600052604160045260246000fd5b604051634ca8886760e01b8152600490fd5b3461012757602036600319011261012757600435608051526001602052604080608051206001815491015482519182526020820152f35b346101275760403660031901126101275761069161102d565b6001600160a01b03907f0000000000000000000000000000000000000000000000000000000000000000821633036106ee57166080515260805160205260206040608051206106e36024358254611176565b809155604051908152f35b60405163a454419960e01b8152600490fd5b3461012757608051366003190112610127576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610127576020366003190112610127576001600160a01b0361076761102d565b1660805152608051602052602060406080512054604051908152f35b346101275761079136611043565b9598939793969294909390927f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610e7d5786609f1981011161038957609f198701908560a0198901831061038957600160f81b8061080360a0198c01609f198d018b61154c565b35161461081960a0198b01609f198c018a61154c565b608051903560fb1c9180610e25575b8560041161012757833560e01c6003198701600c850211610127576108568a85600c8102600489018561156e565b15610d12575b5050506014600319600c830286030111610b67575b50505050838601609f1901905060e0870135600160fe1b1615610b5f57358060f01c60028110610b4d5760408051602081018c815260109490941b61ffff19169181019190915261090792906108ca81605e81016104db565b5190206080515260016020526040608051209060206040516108eb81611183565b6001845494858352015491829101529360a08a0135908b6113e1565b15610b3b575b6040519761091a8961119f565b885260208801526020850135604088015260018060a01b03166060870152606084013560808701528460a0870152603f19838201013560801c60c08701524260e01b60018060e01b03601f198584010135161760e087015260408401356080515060018060a01b03811615600014610b36575060208401355b604051928360a081011067ffffffffffffffff60a08601111761061957610ac3947f0e534c62f0afd2fa0f0fa71198e8aa2d549f24daf2bb47de0d5486c7ce9288ca936101a09360a0870160405286526020860192835260408601605f198383010135815260608701916fffffffffffffffffffffffffffffffff603f1985830101351683526080880193607f19910101358352604051938b51855260208c0151602086015260408c0151604086015260608c0151606086015260808c0151608086015260a08c015160a086015260c08c015160c086015260e08c015160e086015261010097518886015251610120850152516101408401525161016083015251610180820152a184207f00000000000000000000000000000000000000000000000000000000000000006114e4565b9260c0843191015111928315610ae1575b5050506102e15760805180f35b608080516370a0823160e01b905260049190915251919250602091906024908290606001356001600160a01b03165afa60805151901560203d1017610b295710818080610ad4565b6040513d608051823e3d90fd5b610993565b604051633aace85d60e21b8152600490fd5b6040516310d629d360e01b8152600490fd5b90503561090d565b6bffffffffffffffffffffffff19600c82028381016004013582811694929160149088036003190110610cf5575b5050600c8202850360031981016004199091011161038957600c8202850360041901601411610127578260601c3b1561012757610ca68e60e0938f8f948e6018928e610c546040519e8f9d8e9c8d9c8d6323175ef160e11b90528d600482359101528d602460208301359101528d604460408301359101528d606460608301359101528d608460808301359101528d60a460a08301359101528d60c460c0830135910152013560e48d01526101e06101048d01526101e48c01916115f3565b6101248a01979097526001600160a01b03166101448901526101648801526101848701526101a486018c9052858403600319016101c487015260805199600c93909302928390038219019201016115f3565b03916080519060601c5af18015610b2957610cc5575b80808080610871565b67ffffffffffffffff8111610cdd5760405288610cbc565b634e487b7160e01b6080515260416004526024608051fd5b600c8402870360140360040160031b82901b161692508e80610b95565b42108015610d90575b610d7e57610d2b575b808061085c565b8015610d245760018060a01b03881680608051526080516020526040608051205490828210610d6c576080515260805160205203604060805120558d610d24565b6040516353fe9bc960e11b8152600490fd5b6040516379288a5360e11b8152600490fd5b506040516370a0823160e01b81526001600160a01b038a81166004830152602090829060249082907f0000000000000000000000000000000000000000000000000000000000000000165afa908115610b295760805191610df3575b5015610d1b565b90506020813d602011610e1d575b81610e0e602093836111bc565b81010312610127575138610dec565b3d9150610e01565b9450509050609f19890160041161012757863560e01c66038d7ea4c6800090808281020482148115171561038957610e678d610e6c9360a08f01359302611140565b6111de565b90600488019160a3198b0194610828565b60405163692d508360e11b8152600490fd5b3461012757604036600319011261012757610ea861102d565b6001600160a01b03907f0000000000000000000000000000000000000000000000000000000000000000821633036106ee5716608051526080516020526020604060805120602435815401809155604051908152f35b3461012757608051366003190112610127576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461012757610f55610316366110c5565b906298968091828402938085048414901517156103895782018092116103895760209260a0610f8b610f939460c0850135611140565b9201356112a9565b604051908152f35b3461012757610fa936611043565b5050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633039650610feb955050505050505760805180f35b63692d508360e11b8152600490fd5b9181601f840112156110285782359167ffffffffffffffff8311611028576020838186019501011161102857565b600080fd5b600435906001600160a01b038216820361102857565b60031981016101e0811261102857610100136110285760049167ffffffffffffffff61010435818111611028578361107d91600401610ffa565b909390926101243592610144356001600160a01b03811681036110285792610164359261018435926101a435926101c435918211611028576110c191600401610ffa565b9091565b9060031982016101c0811261102857610100136110285760049167ffffffffffffffff9061010435828111611028578161110191600401610ffa565b909390926101243592610144356001600160a01b03811681036110285792610164359261018435926101a435918211611028576110c191600401610ffa565b8181029291811591840414171561115357565b634e487b7160e01b600052601160045260246000fd5b9190820180921161115357565b9190820391821161115357565b6040810190811067ffffffffffffffff82111761061957604052565b610100810190811067ffffffffffffffff82111761061957604052565b90601f8019910116810190811067ffffffffffffffff82111761061957604052565b81156111e8570490565b634e487b7160e01b600052601260045260246000fd5b908060031161102857813560e81c8160071161102857600383013560e01c90801580156112a1575b1561128a5750506000915b81600b1161102857600781013560e01c82600e116110285782601111611028576112779260101901916011810191600b600e83013560e81c92013560e81c810190611341565b81811115611283570390565b5050600090565b620f42409161129a9148026111de565b0491611231565b508115611226565b90918282029160001984820993838086109503948086039514611331578483111561131f5782910981600003821680920460028082600302188083028203028083028203028083028203028083028203028083028203028092029003029360018380600003040190848311900302920304170290565b60405163227bc15360e01b8152600490fd5b50509061133e92506111de565b90565b9193929091428110611354575050505090565b82939594924210156113d75790855b61137a575061133e939450820391429003026111de565b9060039086821161102857823560e81c906005928884116110285784013560f01c810194854211156113b757505092910194600419019485611363565b92509361133e9697508095508491935003934290030291420302016111de565b5060009450505050565b9291906113f7846113f28385611176565b611169565b60001991908281019081116111535783610e678661141493611140565b94810361142e575050505060028101809111611153571490565b808303611449575b5050505060018101809111611153571490565b6114539083611176565b9081019081116111535761146a92610e6791611140565b81146112835738808080611436565b919091602083106114bb5780359063ffffffff8260c01c169160e01c93601f190184116114aa578101602001920390565b6309605a0160e41b60005260046000fd5b50600091508190565b90605592600b92604051926040840152602083015281520160ff81532090565b6e5af43d82803e903d91602b57fd5bf390763d602d80600a3d3981f3363d3d373d3d3d363d7300000062ffffff8260881c161760005260781b17602052603760096000f5906001600160a01b0382161561153a57565b6040516330be1a3d60e21b8152600490fd5b90821015611558570190565b634e487b7160e01b600052603260045260246000fd5b9369ffffffffffffffffffff1692916000915b83831061159357505050505050600090565b600a9582871161102857600c968388116110285782013560f01c0195813560b01c86036115c65750505050505042101590565b95929394954284116115e7579295949360010192600b199092019101611581565b50505050505050600090565b908060209392818452848401376000828201840152601f01601f191601019056fea2646970667358221220a59aca2d89ac32c28ca38fc7a9b867efedc5590f33103149fce33e79671baebc64736f6c63430008170033",
  "devdoc": {
    "custom:security-contact": "security@1inch.io",
    "errors": {
      "ERC1167FailedCreateClone()": [
        {
          "details": "A clone instance deployment failed."
        }
      ],
      "MathOverflowedMulDiv()": [
        {
          "details": "Muldiv operation overflow."
        }
      ]
    },
    "events": {
      "DstEscrowCreated(address,bytes32,uint256)": {
        "params": {
          "escrow": "The address of the created escrow.",
          "hashlock": "The hash of the secret.",
          "taker": "The address of the taker."
        }
      },
      "SrcEscrowCreated((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256))": {
        "params": {
          "dstImmutablesComplement": "Additional immutables related to the escrow contract on the destination chain.",
          "srcImmutables": "The immutables of the escrow contract that are used in deployment on the source chain."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "takerInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)": {
        "details": "Verifies the proof and stores the last validated index and hashed secret. Only Limit Order Protocol can call this function."
      }
    },
    "title": "Escrow Factory contract",
    "version": 1
  },
  "userdoc": {
    "events": {
      "DstEscrowCreated(address,bytes32,uint256)": {
        "notice": "Emitted on EscrowDst deployment."
      },
      "SrcEscrowCreated((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256))": {
        "notice": "Emitted on EscrowSrc deployment to recreate EscrowSrc and EscrowDst immutables off-chain."
      }
    },
    "kind": "user",
    "methods": {
      "ESCROW_DST_IMPLEMENTATION()": {
        "notice": "See {IEscrowFactory-ESCROW_DST_IMPLEMENTATION}."
      },
      "ESCROW_SRC_IMPLEMENTATION()": {
        "notice": "See {IEscrowFactory-ESCROW_SRC_IMPLEMENTATION}."
      },
      "FEE_BANK()": {
        "notice": "See {IFeeBankCharger-feeBank}."
      },
      "addressOfEscrowDst((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "notice": "See {IEscrowFactory-addressOfEscrowDst}."
      },
      "addressOfEscrowSrc((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "notice": "See {IEscrowFactory-addressOfEscrowSrc}."
      },
      "availableCredit(address)": {
        "notice": "See {IFeeBankCharger-availableCredit}."
      },
      "createDstEscrow((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256),uint256)": {
        "notice": "See {IEscrowFactory-createDstEscrow}."
      },
      "decreaseAvailableCredit(address,uint256)": {
        "notice": "See {IFeeBankCharger-decreaseAvailableCredit}."
      },
      "getMakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)": {
        "notice": "See {IAmountGetter-getMakingAmount}"
      },
      "getTakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)": {
        "notice": "See {IAmountGetter-getTakingAmount}"
      },
      "increaseAvailableCredit(address,uint256)": {
        "notice": "See {IFeeBankCharger-increaseAvailableCredit}."
      },
      "lastValidated(bytes32)": {
        "notice": "See {IMerkleStorageInvalidator-lastValidated}."
      },
      "postInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)": {
        "notice": "See {IPostInteraction-postInteraction}"
      },
      "preInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)": {
        "notice": "See {IPreInteraction-preInteraction}"
      },
      "takerInteraction((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,uint256,bytes)": {
        "notice": "See {ITakerInteraction-takerInteraction}."
      }
    },
    "notice": "Contract to create escrow contracts for cross-chain atomic swap.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 23562,
        "contract": "contracts/1inch/cross-chain-swap/EscrowFactory.sol:EscrowFactory",
        "label": "_creditAllowance",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 13081,
        "contract": "contracts/1inch/cross-chain-swap/EscrowFactory.sol:EscrowFactory",
        "label": "lastValidated",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(ValidationData)13482_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_struct(ValidationData)13482_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct IMerkleStorageInvalidator.ValidationData)",
        "numberOfBytes": "32",
        "value": "t_struct(ValidationData)13482_storage"
      },
      "t_struct(ValidationData)13482_storage": {
        "encoding": "inplace",
        "label": "struct IMerkleStorageInvalidator.ValidationData",
        "members": [
          {
            "astId": 13479,
            "contract": "contracts/1inch/cross-chain-swap/EscrowFactory.sol:EscrowFactory",
            "label": "index",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 13481,
            "contract": "contracts/1inch/cross-chain-swap/EscrowFactory.sol:EscrowFactory",
            "label": "leaf",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}